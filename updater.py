#!/usr/bin/env python3
"""
Firmware Downloader for MTK Client
Downloads firmware releases from XML manifest and processes them with mtk.py
"""

import sys
import os
import re
import zipfile
import subprocess
import threading
import requests
import configparser
import json
import pickle
import shutil
import tempfile
import argparse
import webbrowser
import fnmatch
import shlex
from pathlib import Path
from urllib.parse import urlparse
import urllib.parse
from xml.etree import ElementTree as ET
from datetime import datetime, date
import random
# 2025-11-09 12:00:00 - original: PySide6.QtWidgets import did not include QListView, QTreeView, or QAbstractItemView which are now required for the transfer picker dialog.
from PySide6.QtWidgets import (QApplication, QMainWindow, QVBoxLayout, QHBoxLayout,
                               QWidget, QListWidget, QListWidgetItem, QListView, QPushButton, QTextEdit,
                               QLabel, QComboBox, QProgressBar, QMessageBox,
                               QGroupBox, QSplitter, QStackedWidget, QCheckBox, QProgressDialog,
                               QFileDialog, QDialog, QDialogButtonBox, QTabWidget, QScrollArea, QTextBrowser, QLineEdit,
                               QTreeWidget, QTreeWidgetItem, QTreeView, QAbstractItemView)
from PySide6.QtCore import QThread, Signal, Qt, QSize, QTimer, QPropertyAnimation, QEasingCurve, QObject, QMimeData, QEvent
from PySide6.QtGui import (QFont, QPixmap, QTextDocument, QPalette, QDragEnterEvent,
                           QDropEvent, QIcon, QImage, QPainter, QColor)
import platform
import time
import logging
from collections import defaultdict, deque
import random
from concurrent.futures import ThreadPoolExecutor, as_completed

# Import AppKit for macOS Dock hiding (only on macOS)
if platform.system() == "Darwin":
    try:
        import AppKit
    except ImportError:
        AppKit = None

# Global silent mode flag - controls terminal output
SILENT_MODE = True

APP_VERSION = "1.9.1"
UPDATE_SCRIPT_PATH = "/data/data/update/update.sh"
FASTUPDATE_MARKER_PATH = "/storage/sdcard0/.fastupdate"
LEGACY_FASTUPDATE_MARKER_PATH = "/data/data/update/.fastupdate"


def _extract_signal_value(value):
    """Normalize RSSI/level strings to integer dBm for comparisons."""
    if value is None:
        return -200
    if isinstance(value, (int, float)):
        try:
            return int(value)
        except Exception:
            return -200
    try:
        cleaned = str(value).replace("dBm", "").replace("dB", "").strip()
        if cleaned:
            return int(float(cleaned))
    except Exception:
        pass
    return -200

class UpdateCheckEvent(QEvent):
    """Custom event for update check results from worker thread"""
    EventType = QEvent.Type(QEvent.registerEventType())
    
    def __init__(self, latest_version, current_version):
        super().__init__(UpdateCheckEvent.EventType)
        self.latest_version = latest_version
        self.current_version = current_version

def parse_version_designations(version_name):
    """Parse version names and extract designations with flexible adjective handling"""
    designations = []
    
    # Define adjectives that can modify their nearest neighbor
    adjectives = ['compatible', 'aware', 'supported', 'enabled', 'disabled', 'ready', 'optimized', 'enhanced']
    
    # Define parts to exclude from parsing and display
    excluded_parts = ['type', 'b', 'base']
    
    # Extract only the part after the last dash (this is the actual version number)
    import re
    # First remove long hex strings at the end (like -13057e75dc29a1a7!)
    clean_version = re.sub(r'-[a-f0-9]{16,}!?$', '', version_name)
    # Remove any remaining trailing dashes or exclamation marks
    clean_version = clean_version.rstrip('-!')
    
    # Extract only the numbers after the last dash
    if '-' in clean_version:
        last_part = clean_version.split('-')[-1]
        # Check if the last part contains only numbers (and possibly dots)
        if re.match(r'^[\d.]+$', last_part):
            clean_version = last_part
    
    # Parse designations from the original version name
    # Split by dashes and process each part
    parts = version_name.split('-')
    
    for i, part in enumerate(parts):
        # Skip if it's the version number part
        if re.match(r'^[\d.]+$', part):
            continue
            
        # Skip if it's a hex string
        if re.match(r'^[a-f0-9]{16,}!?$', part):
            continue
            
        # Skip excluded parts (type, b, base)
        if part.lower() in excluded_parts:
            continue
            
        # Handle special cases first
        if part == 'nightly':
            designations.append('Nightly')
        elif part == '360p':
            designations.append('360p / Y1 Theme Compatible')
        elif part == 'wifi' or part == 'wi-fi':
            designations.append('Wi-Fi')
        elif part == 'rockbox':
            designations.append('with Rockbox')
        elif part == 'usb':
            designations.append('USB')
        elif part == 'ethernet':
            designations.append('Ethernet')
        elif part == 'hdmi':
            designations.append('HDMI')
        elif part == 'audio':
            designations.append('Audio')
        elif part == 'video':
            designations.append('Video')
        elif part == 'camera':
            designations.append('Camera')
        elif part == 'gps':
            designations.append('GPS')
        elif part == 'nfc':
            designations.append('NFC')
        elif part == 'lte':
            designations.append('LTE')
        elif part == '5g':
            designations.append('5G')
        elif part == 'ipod' and i + 1 < len(parts) and parts[i + 1] == 'theme':
            # Handle "ipod-theme" case
            if i + 2 < len(parts) and parts[i + 2] in adjectives:
                # Check for adjective after "ipod-theme"
                adjective = parts[i + 2]
                designations.append(f'240p iPod / 360p Y1 Themes {adjective.title()}')
            else:
                designations.append('240p iPod themes / 360p Y1 Themes')
        elif part == 'theme' and i > 0 and parts[i - 1] == 'ipod':
            # Skip this as it's handled above
            continue
        else:
            # Check if this part is followed by an adjective
            if i + 1 < len(parts) and parts[i + 1] in adjectives:
                adjective = parts[i + 1]
                # Capitalize the main part and add the adjective
                main_part = part.replace('-', ' ').title()
                designations.append(f'{main_part} {adjective.title()}')
            else:
                # Just add the part as-is, capitalized
                if part not in adjectives:  # Don't add standalone adjectives
                    designations.append(part.replace('-', ' ').title())
    
    return {
        'clean_version': clean_version.strip(),
        'designations': designations
    }

def get_display_version(version_info, published_date):
    """Get the display version - either version number or published date based on length"""
    version_text = version_info['clean_version']
    
    # If version is longer than 8 characters, use published date instead
    if len(version_text) > 8:
        if published_date:
            try:
                from datetime import datetime
                date_obj = datetime.fromisoformat(published_date.replace('Z', '+00:00'))
                return format_fancy_date(date_obj)
            except:
                return published_date
        else:
            return "Unknown Date"
    
    return version_text

def format_fancy_date(date_obj):
    """Format date in a fancy, simplified way without time"""
    from datetime import datetime, timedelta
    
    now = datetime.now(date_obj.tzinfo) if date_obj.tzinfo else datetime.now()
    today = now.date()
    yesterday = today - timedelta(days=1)
    date_only = date_obj.date()
    
    if date_only == today:
        return "Today"
    elif date_only == yesterday:
        return "Yesterday"
    elif (today - date_only).days <= 7:
        # Within the last week
        return date_obj.strftime('%A')  # Day name (Monday, Tuesday, etc.)
    elif (today - date_only).days <= 30:
        # Within the last month
        return date_obj.strftime('%b %d')  # Jan 15, Feb 3, etc.
    else:
        # Older than a month
        return date_obj.strftime('%b %Y')  # Jan 2024, Feb 2024, etc.

def format_designations_text(designations):
    """Format designations as text with visual indicators"""
    if not designations:
        return ""
    
    # Map designations to emoji indicators
    emoji_map = {
        'Nightly': 'üü†',
        '360p': 'üü°',
        'Wi-Fi': 'üì∂',
        'with Rockbox ': 'üîµ',
        'USB': 'üîå',
        'Ethernet': 'üåê',
        'HDMI': 'üì∫',
        'Audio': 'üîä',
        'Video': 'üé•',
        'Camera': 'üì∑',
        'GPS': 'üìç',
        'NFC': 'üì±',
        'LTE': 'üì°',
        '5G': 'üì°',
    }
    
    formatted_designations = []
    for designation in designations:
        # Check for iPod themes variations
        if 'iPod Themes' in designation:
            formatted_designations.append(f"‚úÖ {designation}")
        else:
            # Try to find a matching emoji, fallback to generic
            emoji = '‚ö™'
            for key, value in emoji_map.items():
                if designation.startswith(key):
                    emoji = value
                    break
            formatted_designations.append(f"{emoji} {designation}")
    
    return " | ".join(formatted_designations)

# Zip file management
ZIP_STORAGE_DIR = Path("firmware_downloads")
EXTRACTED_FILES_LOG = Path("extracted_files.log")

# Installation tracking
INSTALLATION_MARKER_FILE = Path("firmware_installation_in_progress.flag")

# Caching configuration
CACHE_DIR = Path(".cache")
CACHE_DIR.mkdir(exist_ok=True)
CONFIG_CACHE_FILE = CACHE_DIR / "config_cache.json"
MANIFEST_CACHE_FILE = CACHE_DIR / "manifest_cache.json"
CACHE_DURATION = 86400  # 24 hour cache duration for offline capability

# Performance optimization
MAX_CONCURRENT_REQUESTS = 3
REQUEST_TIMEOUT = 1  # Short timeout for non-blocking behavior
TOKEN_VALIDATION_TIMEOUT = 2  # Short timeout for non-blocking token validation

def _release_looks_prerelease(release):
    """Return True if a release entry represents a pre-release/nightly build."""
    try:
        if not release:
            return False
        if isinstance(release, dict) and release.get('prerelease', False):
            return True
        tag = ''
        if isinstance(release, dict):
            tag = (release.get('tag_name') or release.get('name') or '')
        else:
            tag = str(getattr(release, 'tag_name', '') or getattr(release, 'name', ''))
        tag = tag.lower()
        if not tag:
            return False
        keywords = (
            "nightly",
            "alpha",
            "beta",
            "rc",
            "release-candidate",
            "pre-release",
            "prerelease",
            "preview"
        )
        return any(keyword in tag for keyword in keywords)
    except Exception as exc:
        silent_print(f'Failed to classify prerelease: {exc}')
        return False


def silent_print(*args, **kwargs):
    """Print function that respects silent mode - completely silent by default"""
    if SILENT_MODE:
        # Completely silent - no output to terminal
        pass
    else:
        print(*args, **kwargs)

# Easter Egg System - Seasonal Emojis
def is_us_user():
    """Check if the user is in the US based on system locale/region"""
    try:
        import locale
        # Get the system locale
        system_locale = locale.getdefaultlocale()[0]
        if system_locale:
            # Check if locale starts with 'en_US' or contains 'US'
            return system_locale.startswith('en_US') or 'US' in system_locale
    except:
        pass
    
    try:
        # Fallback: check environment variables
        import os
        lc_all = os.environ.get('LC_ALL', '')
        lang = os.environ.get('LANG', '')
        return 'en_US' in lc_all or 'en_US' in lang or 'US' in lc_all or 'US' in lang
    except:
        pass
    
    # Default to True if we can't determine (assume US for safety)
    return True

def is_thanksgiving_region():
    """Check if the user is in a region that celebrates Thanksgiving (US/Canada)"""
    try:
        import locale
        # Get the system locale
        system_locale = locale.getdefaultlocale()[0]
        if system_locale:
            # Check for US or Canadian locales
            return (system_locale.startswith('en_US') or 
                   system_locale.startswith('en_CA') or 
                   'US' in system_locale or 
                   'CA' in system_locale)
    except:
        pass
    
    try:
        # Fallback: check environment variables
        import os
        lc_all = os.environ.get('LC_ALL', '')
        lang = os.environ.get('LANG', '')
        return ('en_US' in lc_all or 'en_CA' in lc_all or 
                'en_US' in lang or 'en_CA' in lang or
                'US' in lc_all or 'CA' in lc_all or
                'US' in lang or 'CA' in lang)
    except:
        pass
    
    # Default to True if we can't determine (assume US for safety)
    return True

def get_seasonal_emoji():
    """Get seasonal emoji based on current date - Christmas and Halloween easter eggs!"""
    today = date.today()
    month = today.month
    day = today.day
    
    # Christmas Season: December 25 - January 5 (12 days of Christmas)
    if (month == 12 and day >= 25) or (month == 1 and day <= 5):
        christmas_emojis = [
            "üéÑ", "üéÖ", "ü§∂", "üéÅ", "‚ùÑÔ∏è", "‚õÑ", "ü¶å", "üîî", "üåü", "üéä", "üéâ", "‚ú®"
        ]
        # Use day to pick emoji (Dec 25 = first emoji, Jan 5 = last emoji)
        if month == 12:
            # December 25-31: days 25-31
            emoji_index = (day - 25) % len(christmas_emojis)
        else:
            # January 1-5: days 1-5 (continue from December)
            emoji_index = (day + 6) % len(christmas_emojis)  # +6 because Dec 25-31 = 7 days
        return christmas_emojis[emoji_index]
    
    # Halloween Season: October 25-31
    elif month == 10 and 25 <= day <= 31:
        halloween_emojis = [
            "üéÉ", "üëª", "ü¶á", "üï∑Ô∏è", "üï∏Ô∏è", "üíÄ", "üßô‚Äç‚ôÄÔ∏è", "üßõ‚Äç‚ôÇÔ∏è", "ü¶π‚Äç‚ôÄÔ∏è", "üé≠", "‚ö∞Ô∏è", "ü¶¥"
        ]
        # Use day of month to pick emoji (25th = first emoji, 31st = last emoji)
        emoji_index = (day - 25) % len(halloween_emojis)
        return halloween_emojis[emoji_index]
    
    # Thanksgiving Season: November 20-30 - only for US/Canada
    elif month == 11 and 20 <= day <= 30 and is_thanksgiving_region():
        thanksgiving_emojis = [
            "ü¶É", "üçó", "ü•ß", "üåΩ", "üçÇ", "üçÅ", "ü¶å", "üåæ", "üè†", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "üôè", "üçΩÔ∏è"
        ]
        emoji_index = (day - 20) % len(thanksgiving_emojis)
        return thanksgiving_emojis[emoji_index]
    
    # St. Patrick's Day: March 17
    elif month == 3 and day == 17:
        st_patricks_emojis = [
            "üçÄ", "‚òòÔ∏è", "üåà", "üç∫", "ü•É", "üáÆüá™", "üßö‚Äç‚ôÄÔ∏è", "ü™ô", "üé©", "üé≠", "üé™", "üé®"
        ]
        return random.choice(st_patricks_emojis)
    
    # Valentine's Day: February 14
    elif month == 2 and day == 14:
        valentines_emojis = [
            "üíï", "üíñ", "üíó", "üíò", "üíù", "üíû", "üíü", "‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô"
        ]
        return random.choice(valentines_emojis)
    
    # Easter Season: March 22 - April 25 (approximate range)
    elif month == 3 and day >= 22:
        easter_emojis = [
            "üê∞", "üê£", "ü•ö", "üå∑", "üå∏", "ü¶ã", "üêõ", "üå±", "üåø", "üçÉ", "üå∫", "üåº"
        ]
        emoji_index = (day - 22) % len(easter_emojis)
        return easter_emojis[emoji_index]
    elif month == 4 and day <= 25:
        easter_emojis = [
            "üê∞", "üê£", "ü•ö", "üå∑", "üå∏", "ü¶ã", "üêõ", "üå±", "üåø", "üçÉ", "üå∫", "üåº"
        ]
        emoji_index = (day + 9) % len(easter_emojis)  # +9 because March 22-31 = 10 days
        return easter_emojis[emoji_index]
    
    # New Year's Day: January 1
    elif month == 1 and day == 1:
        new_year_emojis = [
            "üéä", "üéâ", "ü•≥", "üçæ", "ü•Ç", "üéÜ", "üéá", "‚ú®", "üåü", "üí´", "üéà", "üéÅ"
        ]
        return random.choice(new_year_emojis)
    
    # Independence Day (US): July 4 - only for US users
    elif month == 7 and day == 4 and is_us_user():
        independence_emojis = [
            "üá∫üá∏", "üéÜ", "üéá", "‚≠ê", "üåü", "üí•", "üéä", "üéâ", "üèõÔ∏è", "üóΩ", "ü¶Ö", "üé™"
        ]
        return random.choice(independence_emojis)
    
    # Summer Solstice: June 20-22 (approximate)
    elif month == 6 and 20 <= day <= 22:
        summer_emojis = [
            "‚òÄÔ∏è", "üåû", "üåª", "üå∫", "üèñÔ∏è", "üèùÔ∏è", "üåä", "üèÑ‚Äç‚ôÇÔ∏è", "üèÑ‚Äç‚ôÄÔ∏è", "üå¥", "üçâ", "üçì"
        ]
        emoji_index = (day - 20) % len(summer_emojis)
        return summer_emojis[emoji_index]
    
    # Pride Month: June 1-30 (celebrated internationally, primarily in June)
    elif month == 6:
        pride_emojis = [
            "üè≥Ô∏è‚Äçüåà", "‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "üåà", "‚ú®", "üíï", "üè≥Ô∏è‚Äç‚ößÔ∏è", "ü¶Ñ"
        ]
        # Cycle through emojis based on day of month
        emoji_index = (day - 1) % len(pride_emojis)
        return pride_emojis[emoji_index]
    
    # No seasonal emoji
    return ""

def get_seasonal_emoji_random():
    """Get a random seasonal emoji if in season, otherwise return empty string"""
    today = date.today()
    month = today.month
    day = today.day
    
    # Christmas Season: December 25 - January 5
    if (month == 12 and day >= 25) or (month == 1 and day <= 5):
        christmas_emojis = [
            "üéÑ", "üéÖ", "ü§∂", "üéÅ", "‚ùÑÔ∏è", "‚õÑ", "ü¶å", "üîî", "üåü", "üéä", "üéâ", "‚ú®"
        ]
        return random.choice(christmas_emojis)
    
    # Halloween Season: October 25-31
    elif month == 10 and 25 <= day <= 31:
        halloween_emojis = [
            "üéÉ", "üëª", "ü¶á", "üï∑Ô∏è", "üï∏Ô∏è", "üíÄ", "üßô‚Äç‚ôÄÔ∏è", "üßõ‚Äç‚ôÇÔ∏è", "ü¶π‚Äç‚ôÄÔ∏è", "üé≠", "‚ö∞Ô∏è", "ü¶¥"
        ]
        return random.choice(halloween_emojis)
    
    # Thanksgiving Season: November 20-30 - only for US/Canada
    elif month == 11 and 20 <= day <= 30 and is_thanksgiving_region():
        thanksgiving_emojis = [
            "ü¶É", "üçó", "ü•ß", "üåΩ", "üçÇ", "üçÅ", "ü¶å", "üåæ", "üè†", "üë®‚Äçüë©‚Äçüëß‚Äçüë¶", "üôè", "üçΩÔ∏è"
        ]
        return random.choice(thanksgiving_emojis)
    
    # St. Patrick's Day: March 17
    elif month == 3 and day == 17:
        st_patricks_emojis = [
            "üçÄ", "‚òòÔ∏è", "üåà", "üç∫", "ü•É", "üáÆüá™", "üßö‚Äç‚ôÄÔ∏è", "ü™ô", "üé©", "üé≠", "üé™", "üé®"
        ]
        return random.choice(st_patricks_emojis)
    
    # Valentine's Day: February 14
    elif month == 2 and day == 14:
        valentines_emojis = [
            "üíï", "üíñ", "üíó", "üíò", "üíù", "üíû", "üíü", "‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô"
        ]
        return random.choice(valentines_emojis)
    
    # Easter Season: March 22 - April 25
    elif (month == 3 and day >= 22) or (month == 4 and day <= 25):
        easter_emojis = [
            "üê∞", "üê£", "ü•ö", "üå∑", "üå∏", "ü¶ã", "üêõ", "üå±", "üåø", "üçÉ", "üå∫", "üåº"
        ]
        return random.choice(easter_emojis)
    
    # New Year's Day: January 1
    elif month == 1 and day == 1:
        new_year_emojis = [
            "üéä", "üéâ", "ü•≥", "üçæ", "ü•Ç", "üéÜ", "üéá", "‚ú®", "üåü", "üí´", "üéà", "üéÅ"
        ]
        return random.choice(new_year_emojis)
    
    # Independence Day (US): July 4 - only for US users
    elif month == 7 and day == 4 and is_us_user():
        independence_emojis = [
            "üá∫üá∏", "üéÜ", "üéá", "‚≠ê", "üåü", "üí•", "üéä", "üéâ", "üèõÔ∏è", "üóΩ", "ü¶Ö", "üé™"
        ]
        return random.choice(independence_emojis)
    
    # Summer Solstice: June 20-22
    elif month == 6 and 20 <= day <= 22:
        summer_emojis = [
            "‚òÄÔ∏è", "üåû", "üåª", "üå∫", "üèñÔ∏è", "üèùÔ∏è", "üåä", "üèÑ‚Äç‚ôÇÔ∏è", "üèÑ‚Äç‚ôÄÔ∏è", "üå¥", "üçâ", "üçì"
        ]
        return random.choice(summer_emojis)
    
    # Pride Month: June 1-30 (celebrated internationally, primarily in June)
    elif month == 6:
        pride_emojis = [
            "üè≥Ô∏è‚Äçüåà", "‚ù§Ô∏è", "üß°", "üíõ", "üíö", "üíô", "üíú", "üåà", "‚ú®", "üíï", "üè≥Ô∏è‚Äç‚ößÔ∏è", "ü¶Ñ"
        ]
        return random.choice(pride_emojis)
    
    return ""

def is_christmas_season():
    """Check if it's Christmas season (12 days of Christmas: Dec 25 - Jan 5)"""
    today = date.today()
    return (today.month == 12 and today.day >= 25) or (today.month == 1 and today.day <= 5)

def is_halloween_season():
    """Check if it's Halloween season"""
    today = date.today()
    return today.month == 10 and 25 <= today.day <= 31

def is_thanksgiving_season():
    """Check if it's Thanksgiving season"""
    today = date.today()
    return today.month == 11 and 20 <= today.day <= 30

def is_st_patricks_day():
    """Check if it's St. Patrick's Day"""
    today = date.today()
    return today.month == 3 and today.day == 17

def is_valentines_day():
    """Check if it's Valentine's Day"""
    today = date.today()
    return today.month == 2 and today.day == 14

def is_easter_season():
    """Check if it's Easter season"""
    today = date.today()
    return (today.month == 3 and today.day >= 22) or (today.month == 4 and today.day <= 25)

def is_pride_month():
    """Check if it's Pride Month"""
    today = date.today()
    return today.month == 6

def is_new_years_day():
    """Check if it's New Year's Day"""
    today = date.today()
    return today.month == 1 and today.day == 1

def is_independence_day():
    """Check if it's Independence Day (US)"""
    today = date.today()
    return today.month == 7 and today.day == 4

def is_summer_solstice():
    """Check if it's Summer Solstice"""
    today = date.today()
    return today.month == 6 and 20 <= today.day <= 22

# toggle_silent_mode function removed - debug mode is now controlled by keyboard shortcut

def cleanup_extracted_files():
    """Clean up extracted files at startup"""
    # Note: This function is now disabled to prevent conflicts with installation tracking
    # Extracted files are now managed by the installation marker system
    silent_print("Extracted files cleanup disabled - using installation marker system instead")
    return

def cleanup_firmware_files():
    """Clean up extracted firmware files (lk.bin, boot.img, etc.)"""
    try:
        firmware_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
        cleaned_count = 0
        
        for file_name in firmware_files:
            file_path = Path(file_name)
            if file_path.exists():
                file_path.unlink()
                cleaned_count += 1
                silent_print(f"Cleaned up firmware file: {file_name}")
        
        if cleaned_count > 0:
            silent_print(f"Cleaned up {cleaned_count} firmware files")
        else:
            silent_print("No firmware files found to clean up")
            
    except Exception as e:
        silent_print(f"Error cleaning up firmware files: {e}")

def find_last_extracted_scatter_file():
    """Find the last scatter.txt file based on file system data (most recently modified)"""
    try:
        current_dir = Path.cwd()
        # Find all files matching *scatter.txt pattern in the current directory
        scatter_files = list(current_dir.glob("*scatter.txt"))
        
        if not scatter_files:
            silent_print("No scatter.txt files found in current directory - using default fallback")
            # Default fallback: MT6572_Android_scatter.txt (most commonly used)
            return "MT6572_Android_scatter.txt"
        
        # Sort by modification time, get the most recently modified
        scatter_files.sort(key=lambda p: p.stat().st_mtime, reverse=True)
        last_scatter_file = scatter_files[0]
        
        # Return just the filename without path
        scatter_file_name = last_scatter_file.name
        silent_print(f"Found most recently modified scatter file: {scatter_file_name}")
        return scatter_file_name
    except Exception as e:
        silent_print(f"Error finding last extracted scatter.txt file: {e} - using default fallback")
        # Default fallback: MT6572_Android_scatter.txt (most commonly used)
        return "MT6572_Android_scatter.txt"

def update_history_ini():
    """Update history.ini to reference the last extracted scatter.txt file without path"""
    try:
        current_dir = Path.cwd()
        history_ini_path = current_dir / "history.ini"
        
        # Find the last extracted scatter.txt file (uses file system data, falls back to default)
        last_scatter_file = find_last_extracted_scatter_file()
        
        # Function always returns a value (either found file or default fallback)
        silent_print(f"Using scatter file: {last_scatter_file}")
        
        # Create or update history.ini
        config = configparser.ConfigParser()
        
        # Read existing history.ini if it exists
        if history_ini_path.exists():
            config.read(history_ini_path)
        
        # Update [scatterHistory] section
        # Ensure scatterHistory section exists
        if 'scatterHistory' not in config:
            config.add_section('scatterHistory')
        
        # Check for existing option name (might be scatterfile or scatterFile)
        # Use lowercase to match existing format
        option_name = 'scatterfile'
        if config.has_option('scatterHistory', 'scatterFile'):
            option_name = 'scatterFile'
        elif config.has_option('scatterHistory', 'scatterfile'):
            option_name = 'scatterfile'
        
        # Update with just the filename (no path)
        # If there's an existing entry with a path, extract just the filename
        if config.has_option('scatterHistory', option_name):
            existing_value = config.get('scatterHistory', option_name)
            # If it contains a path separator, extract just the filename
            if os.sep in existing_value or '/' in existing_value or '\\' in existing_value:
                # Extract just the filename from the path
                existing_filename = os.path.basename(existing_value)
                silent_print(f"Removed path from existing entry: {existing_value} -> {existing_filename}")
        
        # Update with just the filename (no path) - use lowercase to match existing format
        config.set('scatterHistory', 'scatterfile', last_scatter_file)
        
        # Update [RecentOpenFile] section
        # Ensure RecentOpenFile section exists
        if 'RecentOpenFile' not in config:
            config.add_section('RecentOpenFile')
        
        # Set lastDir to empty string
        config.set('RecentOpenFile', 'lastDir', '')
        
        # Check for existing scatterHistory option in RecentOpenFile section
        # Update with just the filename (no path)
        if config.has_option('RecentOpenFile', 'scatterHistory'):
            existing_value = config.get('RecentOpenFile', 'scatterHistory')
            # If it contains a path separator, extract just the filename
            if os.sep in existing_value or '/' in existing_value or '\\' in existing_value:
                # Extract just the filename from the path
                existing_filename = os.path.basename(existing_value)
                silent_print(f"Removed path from RecentOpenFile.scatterHistory: {existing_value} -> {existing_filename}")
        
        # Update RecentOpenFile.scatterHistory with just the filename (no path)
        config.set('RecentOpenFile', 'scatterHistory', last_scatter_file)
        
        # Set authHistory to empty string (always reset to empty)
        config.set('RecentOpenFile', 'authHistory', '')
        
        # Update [LastDAFilePath] section
        # Ensure LastDAFilePath section exists
        if 'LastDAFilePath' not in config:
            config.add_section('LastDAFilePath')
        
        # Always reset lastDir to MTK_AllInOne_DA.bin (covers all device models)
        config.set('LastDAFilePath', 'lastDir', 'MTK_AllInOne_DA.bin')
        
        # Write to file
        with open(history_ini_path, 'w') as f:
            config.write(f)
        
        silent_print(f"Updated history.ini: scatterfile = {last_scatter_file}, RecentOpenFile.scatterHistory = {last_scatter_file}, RecentOpenFile.lastDir = '', LastDAFilePath.lastDir = MTK_AllInOne_DA.bin")
    except Exception as e:
        silent_print(f"Error updating history.ini: {e}")
        import traceback
        traceback.print_exc()

def load_redundant_files_list():
    """Load redundant files list from local file or remote URL"""
    try:
        # Try local file first
        local_file = Path("redundant_files.txt")
        if local_file.exists():
            silent_print("Loading redundant files list from local file")
            with open(local_file, 'r', encoding='utf-8') as f:
                content = f.read()
        else:
            # Try remote URL (non-blocking with short timeout)
            silent_print("Loading redundant files list from remote URL")
            try:
                response = requests.get("https://innioasis.app/redundant_files.txt", timeout=1)
                response.raise_for_status()
                content = response.text
            except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
                silent_print(f"Network error loading redundant files (offline?): {e}")
                return {}  # Return empty dict instead of blocking
            except Exception as e:
                silent_print(f"Error loading redundant files: {e}")
                return {}
        
        # Parse the content
        redundant_files = {}
        current_platform = None
        
        for line in content.split('\n'):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            if '=' in line:
                platform, files = line.split('=', 1)
                platform = platform.strip()
                files = files.strip()
                
                if platform == 'all':
                    redundant_files['all'] = [f.strip().strip('"') for f in files.split(',') if f.strip()]
                elif platform in ['mac', 'linux', 'win']:
                    redundant_files[platform] = [f.strip().strip('"') for f in files.split(',') if f.strip()]
        
        silent_print(f"Loaded redundant files list: {redundant_files}")
        return redundant_files
        
    except Exception as e:
        silent_print(f"Error loading redundant files list: {e}")
        return {}

def cleanup_redundant_files():
    """Clean up redundant files based on platform and redundant_files.txt"""
    try:
        current_platform = platform.system().lower()
        if current_platform == "darwin":
            platform_key = "mac"
        elif current_platform == "linux":
            platform_key = "linux"
        elif current_platform == "windows":
            platform_key = "win"
        else:
            platform_key = "unknown"
        
        silent_print(f"Cleaning up redundant files for platform: {platform_key}")
        
        # Load redundant files list
        redundant_files = load_redundant_files_list()
        if not redundant_files:
            silent_print("No redundant files list found, skipping cleanup")
            return
        
        current_dir = Path.cwd()
        removed_count = 0
        
        # Clean up files for all platforms
        if 'all' in redundant_files:
            for pattern in redundant_files['all']:
                removed_count += remove_files_by_pattern(current_dir, pattern)
        
        # Clean up platform-specific files
        if platform_key in redundant_files:
            for pattern in redundant_files[platform_key]:
                removed_count += remove_files_by_pattern(current_dir, pattern)
        
        if removed_count > 0:
            silent_print(f"Cleaned up {removed_count} redundant files")
        else:
            silent_print("No redundant files found to clean up")
        
        # Remove redundant_files.txt after cleanup is complete
        try:
            redundant_files_path = Path("redundant_files.txt")
            if redundant_files_path.exists():
                redundant_files_path.unlink()
                silent_print("Removed redundant_files.txt after cleanup")
        except Exception as e:
            silent_print(f"Error removing redundant_files.txt: {e}")
            
    except Exception as e:
        silent_print(f"Error during redundant files cleanup: {e}")

def remove_files_by_pattern(directory, pattern):
    """Remove files or directories matching a pattern in the given directory and subdirectories"""
    removed_count = 0
    try:
        # Important directories to preserve (cache, config, etc.)
        preserve_dirs = {'.cache', 'cache', 'Cache', 'CACHE'}
        
        # Important cache files to preserve (for fast startup)
        preserve_cache_files = {
            'config_cache.json',
            'manifest_cache.json',
            'releases_cache.json',
            'tokens_cache.json'
        }
        
        # Check if pattern is a directory (no file extension and exists as directory)
        pattern_path = directory / pattern
        if pattern_path.exists() and pattern_path.is_dir():
            # Don't remove preserved directories
            if pattern_path.name not in preserve_dirs:
                # Remove entire directory
                import shutil
                shutil.rmtree(pattern_path)
                silent_print(f"Removed redundant directory: {pattern}")
                removed_count += 1
        elif '*' in pattern:
            # Handle wildcard patterns - search recursively in subdirectories
            for file_path in directory.rglob(pattern):
                # Skip files in preserved directories (cache, etc.)
                if any(preserve_dir in file_path.parts for preserve_dir in preserve_dirs):
                    continue
                
                # Skip important cache files (for fast startup)
                if file_path.is_file() and file_path.name in preserve_cache_files:
                    continue
                
                if file_path.is_file():
                    file_path.unlink()
                    silent_print(f"Removed redundant file: {file_path.relative_to(directory)}")
                    removed_count += 1
                elif file_path.is_dir():
                    # Don't remove preserved directories
                    if file_path.name not in preserve_dirs:
                        import shutil
                        shutil.rmtree(file_path)
                        silent_print(f"Removed redundant directory: {file_path.relative_to(directory)}")
                        removed_count += 1
        else:
            # Handle specific file names - search recursively in subdirectories
            for file_path in directory.rglob(pattern):
                # Skip files in preserved directories (cache, etc.)
                if any(preserve_dir in file_path.parts for preserve_dir in preserve_dirs):
                    continue
                
                # Skip important cache files (for fast startup)
                if file_path.is_file() and file_path.name in preserve_cache_files:
                    continue
                
                if file_path.is_file():
                    file_path.unlink()
                    silent_print(f"Removed redundant file: {file_path.relative_to(directory)}")
                    removed_count += 1
                elif file_path.is_dir():
                    import shutil
                    shutil.rmtree(file_path)
                    silent_print(f"Removed redundant directory: {file_path.relative_to(directory)}")
                    removed_count += 1
    except Exception as e:
        silent_print(f"Error removing files/directories matching pattern '{pattern}': {e}")
    
    return removed_count

def log_extracted_files(files):
    """Log extracted files for cleanup"""
    # Note: This function is now disabled to prevent conflicts with installation tracking
    # Extracted files are now managed by the installation marker system
    silent_print("Extracted files logging disabled - using installation marker system instead")
    return

def create_installation_marker():
    """Create a marker file to indicate firmware installation is in progress"""
    try:
        INSTALLATION_MARKER_FILE.touch()
        silent_print("Created installation marker file")
    except Exception as e:
        silent_print(f"Error creating installation marker: {e}")

def remove_installation_marker():
    """Remove the installation marker file when installation completes successfully"""
    try:
        if INSTALLATION_MARKER_FILE.exists():
            INSTALLATION_MARKER_FILE.unlink()
            silent_print("Removed installation marker file - installation completed successfully")
    except Exception as e:
        silent_print(f"Error removing installation marker: {e}")

def check_for_failed_installation():
    """Check if there was a failed firmware installation"""
    if INSTALLATION_MARKER_FILE.exists():
        silent_print("Detected failed firmware installation - showing troubleshooting options")
        return True
    return False

def get_zip_path(repo_name, version):
    """Get the path for a specific zip file"""
    safe_repo_name = repo_name.replace('/', '_')
    return ZIP_STORAGE_DIR / f"{safe_repo_name}_{version}.zip"

def get_update_zip_cache_path(update_zip_url):
    """Get the cache path for an update.zip file based on URL"""
    # Create a safe filename from the URL
    # Extract filename from URL or use a hash of the URL
    from urllib.parse import urlparse
    import hashlib
    
    parsed_url = urlparse(update_zip_url)
    # Try to get filename from URL path
    url_path = parsed_url.path
    if url_path:
        # Extract the last part of the path as potential filename
        path_parts = url_path.split('/')
        if path_parts:
            last_part = path_parts[-1]
            if last_part and last_part.endswith('.zip'):
                # Use the filename from URL if it ends with .zip
                safe_name = last_part
            else:
                # Create a hash-based filename
                url_hash = hashlib.md5(update_zip_url.encode()).hexdigest()[:16]
                safe_name = f"update_{url_hash}.zip"
        else:
            # Create a hash-based filename
            url_hash = hashlib.md5(update_zip_url.encode()).hexdigest()[:16]
            safe_name = f"update_{url_hash}.zip"
    else:
        # Create a hash-based filename
        url_hash = hashlib.md5(update_zip_url.encode()).hexdigest()[:16]
        safe_name = f"update_{url_hash}.zip"
    
    # Ensure cache directory exists
    ZIP_STORAGE_DIR.mkdir(exist_ok=True)
    
    return ZIP_STORAGE_DIR / safe_name

def load_cache(cache_file):
    """Load data from cache if it exists and is not expired"""
    try:
        if cache_file.exists():
            with open(cache_file, 'r') as f:
                cached_data = json.load(f)

            # Check if cache is still valid
            if time.time() - cached_data.get('timestamp', 0) < CACHE_DURATION:
                silent_print(f"Using cached data from {cache_file}")
                return cached_data.get('data')
            else:
                silent_print(f"Cache expired for {cache_file}")
        return None
    except Exception as e:
        silent_print(f"Error loading cache {cache_file}: {e}")
        return None

def save_cache(cache_file, data):
    """Save data to cache with timestamp"""
    try:
        cache_data = {
            'timestamp': time.time(),
            'data': data
        }
        with open(cache_file, 'w') as f:
            json.dump(cache_data, f)
        silent_print(f"Cached data to {cache_file}")
    except Exception as e:
        silent_print(f"Error saving cache {cache_file}: {e}")

def safe_extractall(zip_ref, extract_path=".", zip_name="archive"):
    """Extract all files from zip, continuing on errors for locked files (e.g., running executables/DLLs)"""
    extracted_files = []
    skipped_files = []
    
    # Helper function to check if path is macOS metadata
    def is_macos_metadata(path):
        path_str = str(path).replace('\\', '/').lower()
        name = Path(path).name.lower()
        if name.startswith('._') or name == '.ds_store' or name == '__macosx':
            return True
        if '_macosx' in path_str or '__macosx' in path_str:
            return True
        if '/._' in path_str or '\\._' in path_str:
            return True
        return False
    
    for member in zip_ref.namelist():
        # Skip macOS metadata files/folders
        if is_macos_metadata(member):
            silent_print(f"Skipping macOS metadata: {member}")
            continue
        
        try:
            zip_ref.extract(member, extract_path)
            extracted_files.append(member)
        except (PermissionError, OSError, IOError) as e:
            # File is locked or can't be overwritten (e.g., running executable/DLL)
            # Continue with other files instead of failing completely
            skipped_files.append(member)
            silent_print(f"Skipping locked file {member}: {e}")
        except Exception as e:
            # Other errors - log but continue
            skipped_files.append(member)
            silent_print(f"Skipping file {member} due to error: {e}")
    
    if skipped_files:
        silent_print(f"Extracted {len(extracted_files)} files from {zip_name}, skipped {len(skipped_files)} locked/unwritable files")
    else:
        silent_print(f"Successfully extracted {len(extracted_files)} files from {zip_name}")
    
    return extracted_files

def clear_cache():
    """Clear all cached data"""
    try:
        for cache_file in [CONFIG_CACHE_FILE, MANIFEST_CACHE_FILE]:
            if cache_file.exists():
                cache_file.unlink()
                silent_print(f"Cleared cache: {cache_file}")
    except Exception as e:
        silent_print(f"Error clearing cache: {e}")



def delete_zip_file(repo_name, version):
    """Delete a specific zip file"""
    zip_path = get_zip_path(repo_name, version)
    if zip_path.exists():
        zip_path.unlink()
        return True
    return False

def delete_all_cached_zips():
    """Delete all cached zip files in the firmware_downloads directory"""
    try:
        if not ZIP_STORAGE_DIR.exists():
            return 0
        
        deleted_count = 0
        for zip_file in ZIP_STORAGE_DIR.glob("*.zip"):
            try:
                zip_file.unlink()
                deleted_count += 1
                silent_print(f"Deleted cached zip: {zip_file.name}")
            except Exception as e:
                silent_print(f"Error deleting {zip_file.name}: {e}")
        
        return deleted_count
    except Exception as e:
        silent_print(f"Error deleting cached zips: {e}")
        return 0


class ConfigDownloader:
    """Downloads and parses configuration files from GitHub with caching"""

    def __init__(self):
        self.config_url = "https://innioasis.app/config.ini"
        self.manifest_url = "https://innioasis.app/slidia_manifest.xml"
        self.session = requests.Session()
        self.session.timeout = REQUEST_TIMEOUT

    def download_config(self):
        """Download and parse the config.ini file to extract API tokens with caching"""
        # Try cache first
        cached_tokens = load_cache(CONFIG_CACHE_FILE)
        if cached_tokens:
            return cached_tokens

        # If no cache, try to download but with short timeout to avoid blocking
        # The app should work without tokens using unauthenticated requests
        try:
            silent_print("Downloading tokens from remote config...")
            silent_print(f"Config URL: {self.config_url}")
            # Use shorter timeout for non-blocking behavior in offline mode
            response = self.session.get(self.config_url, timeout=2)  # 2 second timeout
            silent_print(f"Response status: {response.status_code}")

            if response.status_code != 200:
                silent_print(f"Failed to download config: HTTP {response.status_code}")
                silent_print(f"Response text: {response.text[:200]}...")
                
                # Check if it's a rate limit issue
                if response.status_code == 403:
                    silent_print("GitHub API rate limited - this is normal for unauthenticated requests")
                    silent_print("The app will work with limited functionality until rate limit resets")
                elif response.status_code == 404:
                    silent_print("Config file not found - check if the repository structure has changed")
                elif response.status_code >= 500:
                    silent_print("GitHub server error - temporary issue, will retry later")
                
                return []

            response.raise_for_status()

            config = configparser.ConfigParser()
            config.read_string(response.text)

            silent_print(f"Config sections found: {list(config.sections())}")

            tokens = []
            if 'api_keys' in config:
                silent_print("Found api_keys section")
                for key, value in config['api_keys'].items():
                    if key.startswith('key_') and value.strip():
                        # Handle different token formats
                        token = value.strip()

                        # Remove github_pat_ prefix if present (tokens are stored without prefix for obfuscation)
                        if token.startswith('github_pat_'):
                            token = token[11:]  # Remove prefix

                        # Store token without prefix for consistency
                        if token and len(token) > 10:  # Basic validation
                            tokens.append(token)
                            silent_print(f"Added token: {key} -> {token[:10]}...")

            # Also check legacy token
            if 'github' in config and 'token' in config['github']:
                silent_print("Found legacy github token")
                token = config['github']['token'].strip()

                # Store legacy token without prefix for consistency
                if token.startswith('github_pat_'):
                    token = token[11:]  # Remove prefix

                if token and len(token) > 10 and token not in tokens:
                    tokens.append(token)
                    silent_print(f"Added legacy token: {token[:10]}...")

            silent_print(f"Successfully loaded {len(tokens)} tokens from remote config")
            if tokens:
                silent_print(f"First token preview: {tokens[0][:10]}...")
                # Cache the tokens
                save_cache(CONFIG_CACHE_FILE, tokens)
            else:
                silent_print("No valid tokens found in config - will use unauthenticated mode")
            return tokens
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
            # Network error - offline or connection failed
            silent_print(f"Network error downloading config (offline?): {e}")
            silent_print("Falling back to unauthenticated requests only - app will work offline")
            return []
        except Exception as e:
            silent_print(f"Error downloading config: {e}")
            silent_print("Falling back to unauthenticated requests only - app will work offline")
            return []

    def download_manifest(self, use_local_first=True):
        """Download and parse the XML manifest file with local-first loading for instant startup"""
        # Try cache first
        cached_packages = load_cache(MANIFEST_CACHE_FILE)
        if cached_packages:
            silent_print("Using cached manifest for instant startup")
            return cached_packages

        # Load local manifest first for instant startup
        if use_local_first:
            local_packages = self.load_local_manifest()
            if local_packages:
                silent_print(f"Loaded {len(local_packages)} packages from local manifest for instant startup")
                # Cache the local packages immediately
                save_cache(MANIFEST_CACHE_FILE, local_packages)
                # Start background refresh of remote manifest (non-blocking)
                self.refresh_remote_manifest_async()
                return local_packages

        # If no local manifest and no cache, return empty list (non-blocking for offline mode)
        # The app can still work with "Install from rom.zip" feature
        silent_print("No local manifest or cache found - app will work in offline mode")
        silent_print("Use 'Browse Files' button to install firmware from local files")
        return []

    def load_local_manifest(self):
        """Load manifest from local slidia_manifest.xml file"""
        try:
            local_manifest_path = Path("slidia_manifest.xml")
            if not local_manifest_path.exists():
                silent_print("Local manifest not found")
                return []
            
            silent_print("Loading local manifest for instant startup...")
            with open(local_manifest_path, 'r', encoding='utf-8') as f:
                content = f.read()
            
            root = ET.fromstring(content)
            packages = self.parse_manifest_xml(root)
            silent_print(f"Successfully loaded {len(packages)} packages from local manifest")
            return packages
        except Exception as e:
            silent_print(f"Error loading local manifest: {e}")
            return []

    def download_remote_manifest(self):
        """Download manifest from remote URL with timeout for offline mode"""
        try:
            silent_print("Downloading remote manifest...")
            # Use shorter timeout to avoid blocking in offline mode
            response = self.session.get(self.manifest_url, timeout=2)  # 2 second timeout
            response.raise_for_status()

            root = ET.fromstring(response.text)
            packages = self.parse_manifest_xml(root)
            silent_print(f"Successfully loaded {len(packages)} packages from remote manifest")
            # Cache the packages
            save_cache(MANIFEST_CACHE_FILE, packages)
            return packages
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
            # Network error - offline or connection failed
            silent_print(f"Network error downloading remote manifest (offline?): {e}")
            silent_print("App will continue in offline mode - use 'Install from rom.zip' for local files")
            return []
        except Exception as e:
            silent_print(f"Error downloading remote manifest: {e}")
            silent_print("App will continue in offline mode - use 'Install from rom.zip' for local files")
            return []

    def parse_manifest_xml(self, root):
        """Parse XML manifest and return packages list"""
        packages = []
        
        # Handle the actual manifest structure with <slidia> root
        if root.tag == 'slidia':
            # Find all package elements within the slidia root
            for package in root.findall('package'):
                pkg_data = package.attrib
                
                # Skip packages that have device_type attribute (legacy device type handling)
                if 'device_type' in pkg_data:
                    silent_print(f"Skipping package with device_type: {pkg_data.get('name', 'Unknown')}")
                    continue
                
                package_info = {
                    'name': pkg_data.get('name', 'Unknown'),
                    'repo': pkg_data.get('repo', ''),
                    'device': pkg_data.get('device', ''),
                    'url': pkg_data.get('url', ''),
                    'type': pkg_data.get('type', ''),
                    'handler': pkg_data.get('handler', '')
                }
                packages.append(package_info)
                silent_print(f"Parsed package: {package_info['name']} -> {package_info['repo']}")
        else:
            # Fallback to old structure for backward compatibility
            for package in root.findall('package'):
                pkg_data = package.attrib
                
                # Skip packages that have device_type attribute (legacy device type handling)
                if 'device_type' in pkg_data:
                    silent_print(f"Skipping package with device_type (fallback): {pkg_data.get('name', 'Unknown')}")
                    continue
                
                package_info = {
                    'name': pkg_data.get('name', 'Unknown'),
                    'repo': pkg_data.get('repo', ''),
                    'device': pkg_data.get('device', ''),
                    'url': pkg_data.get('url', ''),
                    'type': pkg_data.get('type', ''),
                    'handler': pkg_data.get('handler', '')
                }
                packages.append(package_info)
                silent_print(f"Parsed package (fallback): {package_info['name']} -> {package_info['repo']}")
        
        return packages

    def refresh_remote_manifest_async(self):
        """Refresh manifest from remote source in background"""
        def refresh_worker():
            try:
                silent_print("Refreshing manifest from remote source in background...")
                remote_packages = self.download_remote_manifest()
                if remote_packages:
                    # Update the packages if we got a successful remote load
                    self.packages = remote_packages
                    silent_print(f"Background refresh completed: {len(remote_packages)} packages")
                else:
                    silent_print("Background refresh failed, keeping local manifest")
            except Exception as e:
                silent_print(f"Background manifest refresh error: {e}")
        
        # Start background refresh in a separate thread
        import threading
        refresh_thread = threading.Thread(target=refresh_worker, daemon=True)
        refresh_thread.start()


import time
import random
from collections import defaultdict

class GitHubAPI:
    """GitHub API wrapper for fetching release information with rate limiting and caching"""

    def __init__(self, tokens):
        self.tokens = tokens
        self.token_usage = defaultdict(int)  # Track API calls per token
        self.last_reset = time.time()
        self.hourly_limit = 25  # Limit calls per hour per token
        self.call_timestamps = defaultdict(list)  # Track call timestamps for rate limiting
        self.working_tokens = set()  # Track which tokens are known to work
        self.session = requests.Session()
        self.session.timeout = REQUEST_TIMEOUT

        # Unauthenticated rate limiting (more lenient: 60 requests per hour)
        self.unauth_calls = []
        self.unauth_hourly_limit = 60

        # Persistent caching for releases to enable offline mode
        self.releases_cache = {}
        self.cache_duration = 86400  # 24 hour cache duration
        self.releases_cache_dir = Path(".cache/releases")
        self.releases_cache_dir.mkdir(parents=True, exist_ok=True)

    def get_next_token(self):
        """Get the next available token with load balancing and rate limiting"""
        if not self.tokens:
            return None

        current_time = time.time()

        # Clean up old timestamps (older than 1 hour)
        for token in self.call_timestamps:
            self.call_timestamps[token] = [ts for ts in self.call_timestamps[token]
                                         if current_time - ts < 3600]

        # Find tokens that haven't exceeded hourly limit
        available_tokens = []
        working_available = []
        regular_available = []

        for token in self.tokens:
            if len(self.call_timestamps[token]) < self.hourly_limit:
                available_tokens.append(token)
                if self.is_token_working(token):
                    working_available.append(token)
                else:
                    regular_available.append(token)

        if not available_tokens:
            # All tokens are rate limited, return None instead of infinite loop
            silent_print("All tokens are rate limited, returning None")
            return None

        # Prioritize working tokens, then fall back to regular tokens
        if working_available:
            selected_token = random.choice(working_available)
            silent_print(f"Using working token: {selected_token[:10]}...")
        else:
            selected_token = random.choice(regular_available)
            silent_print(f"Using regular token: {selected_token[:10]}...")

        # Record this API call
        self.call_timestamps[selected_token].append(current_time)

        # Ensure token has github_pat_ prefix for GitHub API
        if not selected_token.startswith('github_pat_'):
            selected_token = f"github_pat_{selected_token}"

        return selected_token

    def mark_token_working(self, token):
        """Mark a token as working (remove github_pat_ prefix if present)"""
        if token.startswith('github_pat_'):
            token = token[11:]  # Remove prefix
        self.working_tokens.add(token)
        silent_print(f"Marked token as working: {token[:10]}...")

    def is_token_working(self, token):
        """Check if a token is known to work"""
        if token.startswith('github_pat_'):
            token = token[11:]  # Remove prefix
        return token in self.working_tokens

    def can_make_unauth_request(self):
        """Check if we can make an unauthenticated request (rate limit: 30/hour)"""
        current_time = time.time()

        # Clean up old calls (older than 1 hour)
        self.unauth_calls = [ts for ts in self.unauth_calls if current_time - ts < 3600]

        # Check if we're under the limit
        if len(self.unauth_calls) < self.unauth_hourly_limit:
            return True

        silent_print(f"Unauthenticated rate limit reached ({len(self.unauth_calls)}/hour)")
        return False

    def record_unauth_request(self):
        """Record an unauthenticated API call"""
        self.unauth_calls.append(time.time())
        silent_print(f"Recorded unauthenticated API call ({len(self.unauth_calls)}/hour)")

    def retry_with_delay(self, func, *args, max_retries=3, delay=1):
        """
        Retry a function with exponential backoff (thread-safe)
        NOTE: This should only be called from worker threads (QThread instances)
        Uses QThread.msleep() for thread-safe delays instead of time.sleep()
        """
        from PySide6.QtCore import QThread
        
        for attempt in range(max_retries):
            try:
                result = func(*args)
                if result is not None:
                    return result
            except Exception as e:
                silent_print(f"Attempt {attempt + 1} failed: {e}")

            if attempt < max_retries - 1:
                sleep_time = int(delay * (2 ** attempt) * 1000)  # Convert to milliseconds
                # Use QThread.msleep() for thread-safe delay (works in any thread)
                try:
                    QThread.msleep(sleep_time)
                except:
                    # Fallback if msleep not available (shouldn't happen)
                    import time
                    time.sleep(sleep_time / 1000)

        return None

    def make_authenticated_request(self, url, repo):
        """Make an authenticated request with robust token fallback - OPTIMIZED"""
        # If no tokens available, return immediately
        if not self.tokens:
            return None
        
        # Prioritize working tokens first, then try others
        working_tokens = [t for t in self.tokens if self.is_token_working(t)]
        other_tokens = [t for t in self.tokens if not self.is_token_working(t)]
        
        # Try working tokens first (fast path)
        tokens_to_try = working_tokens + other_tokens
        
        # Limit attempts to first 3 tokens to avoid long waits
        max_attempts = min(3, len(tokens_to_try))
        
        for i, token in enumerate(tokens_to_try[:max_attempts]):
            # Add github_pat_ prefix if not present
            full_token = token if token.startswith('github_pat_') else f'github_pat_{token}'
            
            headers = {
                'Authorization': f'token {full_token}',
                'Accept': 'application/vnd.github.v3+json'
            }

            try:
                response = self.session.get(url, headers=headers, timeout=REQUEST_TIMEOUT)
                if response.status_code == 200:
                    # Mark this token as working
                    self.working_tokens.add(token)
                    return response
                elif response.status_code == 401:
                    silent_print(f"Token authentication failed for {repo} with token {token[:10]}... (attempt {i+1}/{max_attempts})")
                    continue  # Try next token
                elif response.status_code == 403:
                    silent_print(f"Rate limited for {repo} with token {token[:10]}... (attempt {i+1}/{max_attempts})")
                    continue  # Try next token
                else:
                    silent_print(f"Error getting release for {repo} with token {token[:10]}...: {response.status_code} (attempt {i+1}/{max_attempts})")
                    continue  # Try next token
            except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
                # Network error - offline or connection failed (non-blocking)
                silent_print(f"Network error for {repo} (offline?): {e} (attempt {i+1}/{max_attempts})")
                # Return None immediately if offline to avoid blocking
                if i == 0:  # On first attempt, check if it's a connection error
                    return None
                    continue  # Try next token
            except Exception as e:
                silent_print(f"Error getting release for {repo} with token {token[:10]}...: {e} (attempt {i+1}/{max_attempts})")
                continue  # Try next token
        
        silent_print(f"All {max_attempts} token attempts failed for {repo}")
        return None

    def get_latest_release(self, repo):
        """Get the latest release information for a repository with fallback"""
        url = f"https://api.github.com/repos/{repo}/releases/latest"

        # Try authenticated requests with all available tokens
        if self.tokens:
            response = self.make_authenticated_request(url, repo)
            if response:
                release_data = response.json()
                assets = release_data.get('assets', [])

                # Find firmware assets
                zip_asset = None
                for asset in assets:
                    if asset['name'].lower() == 'rom.zip':
                        zip_asset = asset
                        break

                result = {
                    'tag_name': release_data.get('tag_name', ''),
                    'name': release_data.get('name', ''),
                    'body': release_data.get('body', ''),
                    'download_url': zip_asset['browser_download_url'] if zip_asset else None,
                    'asset_name': zip_asset['name'] if zip_asset else None
                }
                
                # Cache this successful response
                if result['download_url']:
                    self.cache_releases(repo, [result])
                
                return result

        # Try unauthenticated as fallback (with rate limiting)
        if not self.can_make_unauth_request():
            silent_print("Unauthenticated rate limit reached, trying cached data...")
            # Try to get cached latest release if available
            cached_releases = self.get_cached_releases(repo)
            if cached_releases and len(cached_releases) > 0:
                latest_cached = cached_releases[0]  # First one should be latest
                silent_print(f"Returning cached latest release for {repo}: {latest_cached.get('tag_name', 'Unknown')}")
                return latest_cached
            return None

        try:
            self.record_unauth_request()
            response = self.session.get(url, timeout=REQUEST_TIMEOUT)
            if response.status_code == 200:
                release_data = response.json()
                assets = release_data.get('assets', [])

                # Find firmware assets
                zip_asset = None
                for asset in assets:
                    if asset['name'].lower() == 'rom.zip':
                        zip_asset = asset
                        break

                result = {
                    'tag_name': release_data.get('tag_name', ''),
                    'name': release_data.get('name', ''),
                    'body': release_data.get('body', ''),
                    'download_url': zip_asset['browser_download_url'] if zip_asset else None,
                    'asset_name': zip_asset['name'] if zip_asset else None
                }
                
                # Cache this successful response
                if result['download_url']:
                    self.cache_releases(repo, [result])
                
                return result
            elif response.status_code == 403:
                silent_print(f"Unauthenticated request rate limited for {repo}")
                # Try to get cached data if available
                cached_releases = self.get_cached_releases(repo)
                if cached_releases and len(cached_releases) > 0:
                    latest_cached = cached_releases[0]
                    silent_print(f"Returning cached latest release for {repo}: {latest_cached.get('tag_name', 'Unknown')}")
                    return latest_cached
            else:
                silent_print(f"Unauthenticated request failed for {repo}: {response.status_code}")
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
            # Network error - offline or connection failed (non-blocking)
            silent_print(f"Network error getting release for {repo} unauthenticated (offline?): {e}")
        except Exception as e:
            silent_print(f"Error getting release for {repo} unauthenticated: {e}")

        # Final fallback: try to get cached data
        cached_releases = self.get_cached_releases(repo)
        if cached_releases and len(cached_releases) > 0:
            latest_cached = cached_releases[0]
            silent_print(f"Returning cached latest release for {repo}: {latest_cached.get('tag_name', 'Unknown')}")
            return latest_cached

        return None

    def get_all_releases(self, repo):
        """
        Get all releases for a repository with improved performance - CACHE FIRST, LIMITED TO 30
        
        NOTE: This method performs blocking network operations and should only be called
        from worker threads (QThread instances) to avoid freezing the UI. Do not call
        this method from the main thread.
        """
        # Try cache first for instant loading
        cached_releases = self.get_cached_releases(repo)
        if cached_releases:
            silent_print(f"Using {len(cached_releases)} cached releases for {repo} (instant load)")
            return cached_releases[:30]  # Limit cached results to 30 most recent
        
        # Fetch more releases (30) to ensure Stable releases are included even if older than Nightly builds
        # Then we'll filter to top 10 non-pre-release for display
        url = f"https://api.github.com/repos/{repo}/releases?per_page=30"

        # Try authenticated requests with available tokens
        if self.tokens:
            response = self.make_authenticated_request(url, repo)
            if response:
                silent_print(f"Authenticated response status: {response.status_code}")
                if response.status_code == 200:
                    releases_data = response.json()
                    silent_print(f"Found {len(releases_data)} total releases for {repo}")
                    releases = []

                    for release in releases_data:
                        tag_name = release.get('tag_name', 'Unknown')
                        is_prerelease = release.get('prerelease', False)
                        assets = release.get('assets', [])
                        silent_print(f"Processing release: {tag_name} (prerelease={is_prerelease}) with {len(assets)} assets")

                        # Find firmware assets
                        zip_asset = None
                        for asset in assets:
                            if asset['name'].lower() == 'rom.zip':
                                zip_asset = asset
                                silent_print(f"Found zip asset: {asset['name']}")
                                break

                        if zip_asset:  # Include releases with any zip file
                            releases.append({
                                'tag_name': release.get('tag_name', ''),
                                'name': release.get('name', ''),
                                'body': release.get('body', ''),
                                'published_at': release.get('published_at', ''),
                                'download_url': zip_asset['browser_download_url'],
                                'asset_name': zip_asset['name'],
                                'asset_size': zip_asset.get('size', 0),
                                'assets': release.get('assets', []),  # Include full assets array for update.zip detection
                                'prerelease': is_prerelease  # GitHub's official pre-release flag
                            })
                            silent_print(f"Added release {tag_name} (prerelease={is_prerelease}) with zip asset")
                        else:
                            silent_print(f"Skipped release {tag_name} - no rom.zip found")

                    silent_print(f"Returning {len(releases)} releases with zip assets")
                    return releases

        # Try unauthenticated as fallback (with rate limiting)
        if not self.can_make_unauth_request():
            silent_print("Unauthenticated rate limit reached, trying alternative fallback...")
            # Try to get cached data if available
            cached_releases = self.get_cached_releases(repo)
            if cached_releases:
                silent_print(f"Returning {len(cached_releases)} cached releases for {repo}")
                return cached_releases
            
            # If no cached data and rate limited, try to make one more request anyway
            # This helps when the rate limit is just about to reset
            silent_print("Rate limited but trying one more request for critical data...")
            try:
                response = self.session.get(url, timeout=REQUEST_TIMEOUT)
                if response.status_code == 200:
                    silent_print("Rate limit bypass successful!")
                    releases_data = response.json()
                    releases = []
                    
                    for release in releases_data:
                        assets = release.get('assets', [])
                        zip_asset = None
                        for asset in assets:
                            if asset['name'].lower() == 'rom.zip':
                                zip_asset = asset
                                break
                        
                        if zip_asset:
                            releases.append({
                                'tag_name': release.get('tag_name', ''),
                                'name': release.get('name', ''),
                                'body': release.get('body', ''),
                                'published_at': release.get('published_at', ''),
                                'download_url': zip_asset['browser_download_url'],
                                'asset_name': zip_asset['name'],
                                'asset_size': zip_asset.get('size', 0),
                                'assets': release.get('assets', []),  # Include full assets array for update.zip detection
                                'prerelease': release.get('prerelease', False)  # GitHub's official pre-release flag
                            })
                    
                    if releases:
                        self.cache_releases(repo, releases)
                        return releases
            except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
                # Network error - offline or connection failed (non-blocking)
                silent_print(f"Network error in rate limit bypass (offline?): {e}")
            except Exception as e:
                silent_print(f"Rate limit bypass failed: {e}")
            
            return []

        try:
            self.record_unauth_request()
            silent_print(f"Attempting unauthenticated request to {url}")
            response = self.session.get(url, timeout=REQUEST_TIMEOUT)
            silent_print(f"Unauthenticated response status: {response.status_code}")

            if response.status_code == 200:
                releases_data = response.json()
                silent_print(f"Unauthenticated: Found {len(releases_data)} total releases for {repo}")
                releases = []

                for release in releases_data:
                    assets = release.get('assets', [])

                    # Find any zip asset (more flexible than just rom.zip)
                    zip_asset = None
                    for asset in assets:
                        if asset['name'].lower() == 'rom.zip':
                            zip_asset = asset
                            break

                    if zip_asset:  # Include releases with any zip file
                        releases.append({
                            'tag_name': release.get('tag_name', ''),
                            'name': release.get('name', ''),
                            'body': release.get('body', ''),
                            'published_at': release.get('published_at', ''),
                            'download_url': zip_asset['browser_download_url'],
                            'asset_name': zip_asset['name'],
                            'asset_size': zip_asset.get('size', 0),
                            'assets': release.get('assets', []),  # Include full assets array for update.zip detection
                            'prerelease': release.get('prerelease', False)  # GitHub's official pre-release flag
                        })

                silent_print(f"Unauthenticated: Returning {len(releases)} releases with zip assets")
                # Cache the successful unauthenticated response
                self.cache_releases(repo, releases)
                return releases
            elif response.status_code == 403:
                silent_print(f"Unauthenticated request rate limited for {repo}")
                # Try to get cached data if available
                cached_releases = self.get_cached_releases(repo)
                if cached_releases:
                    silent_print(f"Returning {len(cached_releases)} cached releases for {repo}")
                    return cached_releases
            else:
                silent_print(f"Unauthenticated request failed for {repo}: {response.status_code}")
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
            # Network error - offline or connection failed (non-blocking)
            silent_print(f"Network error getting releases for {repo} unauthenticated (offline?): {e}")
        except Exception as e:
            silent_print(f"Error getting releases for {repo} unauthenticated: {e}")

        # Final fallback: try to get cached data
        cached_releases = self.get_cached_releases(repo)
        if cached_releases:
            silent_print(f"Returning {len(cached_releases)} cached releases for {repo}")
            return cached_releases

        silent_print(f"No releases found for {repo} - returning empty list")
        return []

    def get_cached_releases(self, repo):
        """Get cached releases for a repository - PERSISTENT DISK CACHE for offline mode"""
        # Check in-memory cache first (fastest)
        if repo in self.releases_cache:
            cache_time, releases = self.releases_cache[repo]
            if time.time() - cache_time < self.cache_duration:
                silent_print(f"Using in-memory cached releases for {repo} (age: {time.time() - cache_time:.0f}s)")
                return releases
            else:
                # Remove expired cache entry
                del self.releases_cache[repo]
        
        # Check disk cache (enables offline mode)
        try:
            cache_file = self.releases_cache_dir / f"{repo.replace('/', '_')}.json"
            if cache_file.exists():
                with open(cache_file, 'r') as f:
                    cache_data = json.load(f)
                cache_time = cache_data.get('timestamp', 0)
                if time.time() - cache_time < self.cache_duration:
                    releases = cache_data.get('releases', [])
                    silent_print(f"Using disk cached releases for {repo} (age: {time.time() - cache_time:.0f}s, OFFLINE MODE)")
                    # Load into memory cache for faster subsequent access
                    self.releases_cache[repo] = (cache_time, releases)
                    return releases
                else:
                    silent_print(f"Disk cache expired for {repo}")
        except Exception as e:
            silent_print(f"Error loading disk cache for {repo}: {e}")
        
        return None

    def cache_releases(self, repo, releases):
        """Cache releases for a repository - PERSISTENT to disk for offline mode"""
        # Save to memory cache
        self.releases_cache[repo] = (time.time(), releases)
        
        # Save to disk cache for persistence across app restarts
        try:
            cache_file = self.releases_cache_dir / f"{repo.replace('/', '_')}.json"
            cache_data = {
                'timestamp': time.time(),
                'releases': releases
            }
            with open(cache_file, 'w') as f:
                json.dump(cache_data, f)
            silent_print(f"Cached {len(releases)} releases for {repo} to disk (persistent)")
        except Exception as e:
            silent_print(f"Error saving cache to disk for {repo}: {e}")

    def clear_expired_cache(self):
        """Clear expired cache entries"""
        current_time = time.time()
        expired_repos = []
        for repo, (cache_time, _) in self.releases_cache.items():
            if current_time - cache_time >= self.cache_duration:
                expired_repos.append(repo)
        
        for repo in expired_repos:
            del self.releases_cache[repo]
            silent_print(f"Cleared expired cache for {repo}")

    def cleanup_cache_periodically(self):
        """Clean up expired cache entries periodically"""
        self.clear_expired_cache()
        # Schedule next cleanup in 10 minutes
        QTimer.singleShot(600000, self.cleanup_cache_periodically)





class DebugOutputWindow(QWidget):
    """Debug output window for showing mtk.py output in real-time"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("MTK Debug Output - Labs Mode")
        self.setGeometry(200, 200, 800, 600)
        
        # Create layout
        layout = QVBoxLayout(self)
        
        # Title label
        title_label = QLabel("MTK.py Output (Debug Mode)")
        title_label.setStyleSheet("font-size: 14px; font-weight: bold; margin: 5px;")
        layout.addWidget(title_label)
        
        # Output text area
        self.output_text = QTextEdit()
        self.output_text.setReadOnly(True)
        self.output_text.setFont(QFont("Consolas", 10))
        layout.addWidget(self.output_text)
        
        # Clear button
        clear_btn = QPushButton("Clear Output")
        clear_btn.clicked.connect(self.clear_output)
        layout.addWidget(clear_btn)
        
        # Close button
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(self.close)
        layout.addWidget(close_btn)
    
    def append_output(self, text):
        """Append text to the output area"""
        self.output_text.append(text)
        # Auto-scroll to bottom
        cursor = self.output_text.textCursor()
        cursor.movePosition(cursor.End)
        self.output_text.setTextCursor(cursor)
    
    def clear_output(self):
        """Clear the output area"""
        self.output_text.clear()


class SPFlashToolWorker(QThread):
    """Worker thread for running SP Flash Tool command with real-time output"""

    status_updated = Signal(str)
    show_installing_image = Signal()
    show_initsteps_image = Signal()
    show_installed_image = Signal()
    show_please_wait_image = Signal()
    spflash_completed = Signal(bool, str)
    disable_update_button = Signal()  # Signal to disable update button during SP Flash Tool installation
    enable_update_button = Signal()   # Signal to enable update button when returning to ready state

    def __init__(self):
        super().__init__()
        self.should_stop = False
        # Set up the flash_tool.exe command with the XML file
        current_dir = Path.cwd()
        self.spflash_command = [
            str(current_dir / "flash_tool.exe"),
            "-i",
            str(current_dir / "install_rom_sp.xml")
        ]
        
    def stop(self):
        """Stop the SP Flash Tool worker"""
        self.should_stop = True

    def run(self):
        """Run the SP Flash Tool command and monitor output"""
        try:
            silent_print(f"Starting SP Flash Tool command: {self.spflash_command}")
            
            # Start the flash_tool.exe process
            process = subprocess.Popen(
                self.spflash_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=0,
                universal_newlines=True
            )
            
            # Ensure process doesn't hang indefinitely
            process_timeout = 1800  # 30 minutes timeout for SP Flash Tool
            process_start_time = time.time()
            
            # Phase tracking variables
            please_wait_phase = True  # Start with please wait phase
            instructions_phase = False
            installing_phase = False
            completed_phase = False
            
            # Read output line by line
            while True:
                if self.should_stop:
                    if process.poll() is None:
                        process.terminate()
                    break
                    
                # Check for timeout
                if time.time() - process_start_time > process_timeout:
                    silent_print("SP Flash Tool process timeout - terminating")
                    process.terminate()
                    break
                
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                    
                if output:
                    line = output.strip()
                    silent_print(f"{line}")
                    
                    # Phase detection based on flash_tool.exe output patterns
                    
                    # Please wait phase: Show "Please wait..." until "Search usb" is detected
                    if please_wait_phase and not line.startswith("Search usb"):
                        # Keep showing please wait image and status
                        self.show_please_wait_image.emit()
                        self.status_updated.emit("Please wait...")
                        # Don't emit the actual flash tool output yet
                        continue
                    
                    # Instructions phase: When "Search usb" is detected, show instructions
                    elif line.startswith("Search usb"):
                        please_wait_phase = False
                        instructions_phase = True
                        installing_phase = False
                        completed_phase = False
                        self.show_initsteps_image.emit()
                        self.status_updated.emit("Please turn off your Y1 (or insert paperclip in hidden button) and connect it via USB")
                        # Don't show the raw flash tool output, keep the user-friendly message
                        
                    # Continue with instructions phase until installing phase
                    elif instructions_phase and not installing_phase and not completed_phase:
                        if ("Downloading" in line or
                            "Downloading & Connecting to DA" in line or
                            "connect DA end stage" in line or
                            "COM port is open" in line or
                            "Download DA now" in line or
                            "Formatting Flash" in line or
                            "Format Succeeded" in line or
                            "executing DADownloadAll" in line or
                            "DA report" in line or
                            "% of" in line or
                            "download speed" in line or
                            "Download Succeeded" in line):
                            # Transition to installing phase
                            instructions_phase = False
                            installing_phase = True
                            self.show_installing_image.emit()
                            self.disable_update_button.emit()
                            self.status_updated.emit(f"{line}")
                        else:
                            # Continue showing instructions and flash tool output
                            self.status_updated.emit(f"{line}")
                        
                    # Installing phase: Downloading and flashing operations
                    elif installing_phase and not completed_phase:
                        if ("Downloading" in line or
                            "Downloading & Connecting to DA" in line or
                            "connect DA end stage" in line or
                            "COM port is open" in line or
                            "Download DA now" in line or
                            "Formatting Flash" in line or
                            "Format Succeeded" in line or
                            "executing DADownloadAll" in line or
                            "DA report" in line or
                            "% of" in line or
                            "download speed" in line or
                            "Download Succeeded" in line):
                            self.status_updated.emit(f"{line}")
                        elif (line.startswith("Disconnect!") or
                              "All command exec done!" in line or
                              "FlashTool_EnableWatchDogTimeout" in line):
                            # Transition to completion phase
                            completed_phase = True
                            installing_phase = False
                            if line.startswith("Disconnect!"):
                                self.show_installed_image.emit()
                                self.status_updated.emit("Install Complete, please disconnect your Y1 and hold the center button")
                            else:
                                self.show_installing_image.emit()  # Use installing image for other completion indicators
                                self.status_updated.emit(f"Flash Tool: {line}")
                        else:
                            self.status_updated.emit(f"Flash Tool: {line}")
                        
                    # Completion phase: Final cleanup and disconnection
                    elif completed_phase:
                        if line.startswith("Disconnect!"):
                            self.show_installed_image.emit()
                            self.status_updated.emit("Install Complete, please disconnect your Y1 and hold the center button")
                        else:
                            self.status_updated.emit(f"Flash Tool: {line}")
                        
                        
                    # Other output
                    else:
                        self.status_updated.emit(f"Flash Tool: {line}")
            
            # Wait for process to complete
            process.wait()
            
            # Determine success based on completion phase
            if completed_phase:
                silent_print("Flash Tool completed successfully")
                self.spflash_completed.emit(True, "Software installation completed successfully")
            else:
                silent_print("Flash Tool did not complete successfully")
                self.spflash_completed.emit(False, "Please check that drivers are installed and that you restarted your computer")
                
        except Exception as e:
            silent_print(f"Error running Flash Tool: {e}")
            self.spflash_completed.emit(False, f"Error running Flash Tool: {e}")
        finally:
            self.enable_update_button.emit()


class MTKWorker(QThread):
    """Worker thread for running MTK command with real-time output"""

    status_updated = Signal(str)
    show_installing_image = Signal()
    show_reconnect_image = Signal()
    show_presteps_image = Signal()
    show_please_wait_image = Signal()  # Signal for showing please_wait image during "Please wait..." status
    show_initsteps_image = Signal()  # New signal for showing initsteps after first empty line
    show_instructions_image = Signal()  # Signal for showing initsteps when instructions are displayed
    mtk_completed = Signal(bool, str)
    handshake_failed = Signal()  # New signal for handshake failures
    errno2_detected = Signal()   # New signal for errno2 errors
    usb_io_error_detected = Signal()  # New signal for USB IO errors
    backend_error_detected = Signal()  # New signal for backend errors
    keyboard_interrupt_detected = Signal()  # New signal for keyboard interrupts
    show_try_again_dialog = Signal()  # New signal for showing try again dialog
    disable_update_button = Signal()  # Signal to disable update button during MTK installation
    enable_update_button = Signal()   # Signal to enable update button when returning to ready state

    def __init__(self, debug_mode=False, debug_window=None):
        super().__init__()
        self.should_stop = False
        self.debug_mode = debug_mode
        self.debug_window = debug_window
        self.initsteps_timer = None  # Timer for 1.5 second delay fallback
        
        # Platform-specific progress bar characters
        if platform.system() == "Windows":
            # Windows: Use ASCII characters that display properly
            self.progress_filled = "#"
            self.progress_empty = "-"
        else:
            # Linux/macOS: Use box drawing characters
            self.progress_filled = "‚ñà"
            self.progress_empty = "‚ñë"

    def stop(self):
        """Stop the MTK worker"""
        self.should_stop = True

    def fix_progress_bar_chars(self, line):
        """Fix progress bar characters for platform compatibility"""
        if platform.system() == "Windows":
            # Replace box drawing characters with ASCII equivalents on Windows
            line = line.replace("‚ñà", self.progress_filled)
            line = line.replace("‚ñë", self.progress_empty)
            # Also handle other common box drawing characters that might appear
            line = line.replace("√¢-¬™", self.progress_filled)  # Common mojibake
            line = line.replace("√¢", self.progress_filled)    # Partial mojibake
            line = line.replace("¬™", self.progress_empty)     # Partial mojibake
        return line

    def run(self):
        cmd = [
            sys.executable, "mtk.py", "w",
            "uboot,bootimg,recovery,android,usrdata",
            "lk.bin,boot.img,recovery.img,system.img,userdata.img"
        ]

        try:
            # Don't emit status message - let MTK output be displayed clearly
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=0,
                universal_newlines=True
            )
            
            # Ensure process doesn't hang indefinitely
            process_timeout = 300  # 5 minutes timeout
            process_start_time = time.time()

            device_detected = False
            flashing_started = False
            handshake_error_detected = False
            errno2_error_detected = False
            backend_error_detected = False
            keyboard_interrupt_detected = False
            usb_connection_issue_detected = False
            usb_io_error_detected = False
            last_output_line = ""
            successful_completion = False
            first_empty_line_detected = False  # Track if we've seen the first empty line
            initsteps_start_time = None  # Track when initsteps phase started
            initsteps_timeout = 12  # 12 seconds timeout for initsteps phase
            last_status_update = time.time()  # Track when status was last updated
            status_check_interval = 2  # Check status every 2 seconds
            current_status = ""  # Track current status message

            # Interruption detection variables
            progress_detected = False
            last_progress_time = None
            interruption_timeout = 3.0  # 3 seconds timeout
            
            # Track installation state
            active_installation_started = False
            last_wrote_line_seen = False

            # Start 1.5 second timer as fallback to show initsteps if no empty line is detected
            self.initsteps_timer = QTimer()
            self.initsteps_timer.setSingleShot(True)
            # Timer callback will be checked inside the main loop where active_installation_started is available
            self.initsteps_timer.start(1500)  # 1.5 seconds

            while True:
                # Check for timeout - but don't terminate during active installation
                if time.time() - process_start_time > process_timeout:
                    if active_installation_started:
                        silent_print("MTK process timeout during active installation - continuing to wait for completion")
                        # Don't terminate during active installation, just continue waiting
                    else:
                        silent_print("MTK process timeout - terminating")
                        process.terminate()
                        break
                
                # Check if we need to update status due to lack of output
                current_time = time.time()
                if current_time - last_status_update > status_check_interval:
                    # If no output for a while, emit empty status to trigger instruction message
                    # But only if we're not in a specific status state like "Please wait..." or active install
                    if current_status not in ["Please wait...", "Please disconnect your Y1 and restart the app"] and not progress_detected and not active_installation_started:
                        self.status_updated.emit("")
                        self.show_instructions_image.emit()
                        last_status_update = current_time
                
                # Check if initsteps timer has expired and show initsteps if appropriate
                if hasattr(self, 'initsteps_timer') and not self.initsteps_timer.isActive() and not first_empty_line_detected and not active_installation_started:
                    self.show_initsteps_image.emit()
                    first_empty_line_detected = True  # Mark as detected to prevent multiple emissions
                    
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                if output:
                    # Small delay to keep GUI responsive
                    time.sleep(0.01)  # 10ms delay
                    line = output.strip()
                    last_output_line = line  # Track the last output line

                    # Check for first empty line from mtk.py and emit initsteps signal
                    if not first_empty_line_detected and line == "":
                        first_empty_line_detected = True
                        # Only show initsteps if not in active installation
                        if not active_installation_started:
                            self.show_initsteps_image.emit()

                    # Fix progress bar characters for platform compatibility
                    fixed_line = self.fix_progress_bar_chars(line)
                    
                    # CRITICAL: Set active_installation_started IMMEDIATELY when first progress or wrote line is detected
                    # This must happen before any other processing to prevent initsteps.png from showing
                    if not active_installation_started and ("progress" in line.lower() or line.lower().startswith("wrote")):
                        active_installation_started = True
                        silent_print("Active installation started - process will not be terminated until completion")
                    
                    # Show debug output in separate window if debug mode is enabled
                    if self.debug_mode and self.debug_window:
                        self.debug_window.append_output(f"MTK: {fixed_line}")
                    
                    # Check if this is empty status or dots (awaiting connection) and show installing.png
                    if device_detected and (fixed_line == "" or fixed_line.startswith(".") or fixed_line.strip() == ""):
                        # Only show installing.png if we're in active installation state
                        if active_installation_started:
                            self.show_installing_image.emit()
                        # Mark initsteps phase start time
                        if initsteps_start_time is None:
                            initsteps_start_time = time.time()
                    
                    # Handle status message replacement for blank/dots output
                    if fixed_line == "" or fixed_line.startswith(".") or fixed_line.strip() == "":
                        # Only show instruction message if not in active installation
                        if not active_installation_started:
                            # When mtk.py only displays blank output or dots/periods, show instruction message
                            self.status_updated.emit("Please follow the instructions below to install the software on your Y1")
                            current_status = "Please follow the instructions below to install the software on your Y1"
                            # Only show initsteps image if we're not in an active install (no progress detected) AND not in active installation state
                            if not progress_detected and not active_installation_started:
                                self.show_instructions_image.emit()
                            last_status_update = time.time()  # Update status time
                        
                        # Check if we've been in initsteps phase too long - but not during active installation
                        if initsteps_start_time is not None and (time.time() - initsteps_start_time) > initsteps_timeout:
                            # Only kill the process if we're not in active installation state
                            if not active_installation_started:
                                # Kill the process and restart
                                if process.poll() is None:
                                    process.terminate()
                                self.show_try_again_dialog.emit()
                                break
                            else:
                                # During active installation, just reset the timer to prevent false termination
                                initsteps_start_time = time.time()
                                silent_print("Reset initsteps timer during active installation")
                    else:
                        # Show latest output in status area (no extra whitespace)
                        self.status_updated.emit(f"MTK: {fixed_line}")
                        current_status = f"MTK: {fixed_line}"  # Track current status
                        # Reset initsteps timer when we get real output
                        initsteps_start_time = None
                        last_status_update = time.time()  # Update status time

                    # Check for errno2 error
                    if "errno2" in line.lower():
                        errno2_error_detected = True
                        self.status_updated.emit("Errno2 detected - Innioasis Updater reinstall required")
                    
                    # Check for USBError(5) - Input/Output Error (SP Flash Tool sparse images)
                    if "usberror(5" in line.lower() or "input/output error" in line.lower():
                        usb_io_error_detected = True
                        self.status_updated.emit("USBError(5) - ROM incompatible with Method 1")
                        self.usb_io_error_detected.emit()
                        # Don't break here - continue reading output

                    # Check for handshake failed error (generalized detection)
                    if any(phrase in line.lower() for phrase in [
                        "handshake failed", 
                        "handshake error", 
                        "connection failed", 
                        "device not responding",
                        "timeout",
                        "connection timeout",
                        "device timeout",
                        "no device found",
                        "device not found",
                        "connection refused",
                        "failed to connect",
                        "connection error"
                    ]):
                        handshake_error_detected = True
                        self.status_updated.emit("Connection issue detected - please unplug your Y1 and try again")
                        self.handshake_failed.emit()
                        # Don't break here - continue reading output

                    # Check for backend error
                    if "nobackenderror" in line.lower() or "no backend available" in line.lower():
                        backend_error_detected = True
                        self.status_updated.emit("Backend error detected - libusb backend issue")
                        self.backend_error_detected.emit()
                        # Don't break here - continue reading output

                    # Check for USB connection issue (AttributeError: 'NoneType' object has no attribute 'hex')
                    if "attributerror: 'nonetype' object has no attribute 'hex'" in line.lower():
                        usb_connection_issue_detected = True
                        self.status_updated.emit("Please unplug the USB cable from your Y1 and reconnect it.")
                        self.show_reconnect_image.emit()
                        # Don't break here - continue reading output

                    # Check for keyboard interrupt
                    if "keyboardinterrupt" in line.lower() or "keyboard interrupt" in line.lower() or "interrupted by user" in line.lower():
                        keyboard_interrupt_detected = True
                        self.status_updated.emit("Something stopped the install process, give it another try...")
                        self.keyboard_interrupt_detected.emit()
                        # Don't break here - continue reading output

                    # Check for Preloader status (indicates slow USB connection or freeze)
                    if "preloader" in line.lower():
                        if ".........." in line:
                            # This indicates slow USB connection, show appropriate status - here is where we'll implement the automatic restart of the firmware installation for Method 1 - this makes more sense than the app freezing - which it almost always does in scenarios where this message will be shown
                            self.status_updated.emit("USB connection timed out. Please force quit the app if not responding and restart it.")
                            # Show initsteps image for instruction message - but not during active installation
                            if not active_installation_started:
                                self.show_instructions_image.emit()
                            last_status_update = time.time()  # Update status time
                        else:
                            # Just "Preloader" without dots indicates freeze state
                            self.status_updated.emit("MTK: Preloader")
                            current_status = "MTK: Preloader"  # Track current status
                            # Show initsteps image for instruction message - but not during active installation
                            if not active_installation_started:
                                self.show_instructions_image.emit()
                            last_status_update = time.time()  # Update status time
                    
                    # Check for BROM status (indicates waiting for device)
                    if "brom" in line.lower():
                        # This indicates waiting for device, show please wait message
                        self.status_updated.emit("Please wait...")
                        current_status = "Please wait..."  # Track current status
                        # Show please_wait image for please wait status
                        self.show_please_wait_image.emit()
                        last_status_update = time.time()  # Update status time
                        # Don't treat this as an error, just continue

                    if ".Port - Device detected :)" in line:
                        device_detected = True
                        # Don't switch to installing.png yet - wait for proper timing

                    # Check if flashing has started (look for write operations)
                    if device_detected and ("Write" in line or "Progress:" in line) and not flashing_started:
                        flashing_started = True

                    # Check for progress indicator and show installing.png
                    if "progress" in line.lower():
                        self.show_installing_image.emit()
                        # Disable update button when MTK installation starts
                        self.disable_update_button.emit()
            # Track progress for interruption detection
            progress_detected = True
            last_progress_time = time.time()
            # Don't emit status message - let MTK output be displayed clearly
            
            # Check for Progress or Wrote lines to show installing.png and display output in status
            if "progress" in line.lower() or line.lower().startswith("wrote"):
                self.show_installing_image.emit()
                # Display the actual mtk.py output in status field
                self.status_updated.emit(f"MTK: {fixed_line}")
                current_status = f"MTK: {fixed_line}"
                last_status_update = time.time()
                
                # active_installation_started is now set immediately when progress/wrote is first detected above
                
                # Track if we've seen a "Wrote" line
                if line.lower().startswith("wrote"):
                    last_wrote_line_seen = True
                    silent_print("Wrote line detected - installation may be completing")

                    # Only show presteps if no device detected and no errors
                    if not device_detected and not usb_connection_issue_detected and not handshake_error_detected and not errno2_error_detected and not backend_error_detected and not keyboard_interrupt_detected:
                        self.show_presteps_image.emit()

            # If any error was detected, continue reading but mark for completion
            if handshake_error_detected or errno2_error_detected or backend_error_detected or keyboard_interrupt_detected:
                # Continue reading output to show user what's happening
                while True:
                    # Check for timeout - but don't terminate during active installation
                    if time.time() - process_start_time > process_timeout:
                        if active_installation_started:
                            silent_print("MTK process timeout during active installation error reading - continuing to wait for completion")
                            # Don't terminate during active installation, just continue waiting
                        else:
                            silent_print("MTK process timeout during error reading - terminating")
                            process.terminate()
                            break
                        
                    output = process.stdout.readline()
                    if output == '' and process.poll() is not None:
                        break
                    if output:
                        # Small delay to keep GUI responsive
                        time.sleep(0.01)  # 10ms delay
                        line = output.strip()
                        # Fix progress bar characters for platform compatibility
                        fixed_line = self.fix_progress_bar_chars(line)
                        # Show latest output in status area (no extra whitespace)
                        self.status_updated.emit(f"MTK: {fixed_line}")

            # Wait for process to complete
            process.wait()

            # Check if process completed before device detection
            if not device_detected:
                if process.returncode != 0:
                    # Process failed before device detection
                    successful_completion = False
                else:
                    successful_completion = True
            else:
                # Device was detected, check completion based on progress
                if progress_detected and last_progress_time:
                    time_since_last_progress = time.time() - last_progress_time
                    if time_since_last_progress > interruption_timeout:
                        # Process was interrupted - no progress for 3+ seconds
                        # But only if we're not in active installation state
                        if active_installation_started:
                            # During active installation, wait longer for completion
                            if time_since_last_progress > (interruption_timeout * 2):  # Double the timeout during active installation
                                successful_completion = False
                            else:
                                # Still in active installation, consider it successful if process exited normally
                                successful_completion = (process.returncode == 0)
                        else:
                            successful_completion = False
                    else:
                        # Check if the last progress was 100% or if process completed normally
                        # Also check if the last line begins with "wrote" (indicates successful completion)
                        if "100%" in last_output_line or process.returncode == 0 or last_output_line.lower().startswith("wrote"):
                            successful_completion = True
                        else:
                            # Process stopped before 100% - likely interrupted
                            successful_completion = False
                else:
                    # No progress was detected, check if process completed successfully
                    # Also check if the last line begins with "wrote" (indicates successful completion)
                    if process.returncode == 0 or last_output_line.lower().startswith("wrote"):
                        successful_completion = True
                    else:
                        successful_completion = False

        except Exception as e:
            silent_print(f"MTK Worker error: {str(e)}")
            self.status_updated.emit(f"MTK error: {str(e)}")
            successful_completion = False
            # Ensure process is terminated on error
            try:
                if 'process' in locals() and process.poll() is None:
                    process.terminate()
            except:
                pass

        # Clean up timer
        if self.initsteps_timer:
            self.initsteps_timer.stop()
            self.initsteps_timer = None

        # Enable update button when returning to ready state
        self.enable_update_button.emit()

        if self.should_stop:
            self.mtk_completed.emit(False, "MTK command cancelled")
        elif usb_connection_issue_detected:
            self.mtk_completed.emit(False, "USB connection issue - please reconnect device")
        elif handshake_error_detected:
            self.mtk_completed.emit(False, "Handshake failed - driver setup required")
        elif errno2_error_detected:
            self.mtk_completed.emit(False, "Errno2 error - Innioasis Updater reinstall required")
        elif usb_io_error_detected:
            self.mtk_completed.emit(False, "USBError(5) - ROM incompatible with Method 1")
        elif backend_error_detected:
            self.mtk_completed.emit(False, "Backend error - libusb backend issue")
        elif keyboard_interrupt_detected:
            self.mtk_completed.emit(False, "Something stopped the install process, give it another try...")
        elif successful_completion:
            self.mtk_completed.emit(True, "Install completed successfully")
        else:
            # Process ended but was interrupted (no progress for 3+ seconds)
            self.mtk_completed.emit(False, "Install process interrupted - please try again")


class UpdateZipSenderWorker(QThread):
    """Worker thread for downloading and sending update.zip to Y1"""
    
    progress_updated = Signal(int)
    status_updated = Signal(str)
    send_completed = Signal(bool, str, str)  # (success, message, transfer_method)
    
    def __init__(self, update_zip_url, target_directory):
        super().__init__()
        self.update_zip_url = update_zip_url
        self.target_directory = Path(target_directory)
    
    def run(self):
        try:
            silent_print(f"Starting update.zip download from {self.update_zip_url}")
            silent_print(f"Target directory: {self.target_directory}")
            
            # Check cache first
            cache_path = get_update_zip_cache_path(self.update_zip_url)
            temp_update_path = None
            
            if cache_path.exists():
                silent_print(f"Using cached update.zip from: {cache_path}")
                self.status_updated.emit("Using cached update.zip...")
                temp_update_path = cache_path
            else:
            # Download update.zip
                self.status_updated.emit("Downloading update.zip...")
            silent_print("Making request to download update.zip...")
            response = requests.get(self.update_zip_url, stream=True, timeout=30)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            
            silent_print(f"Download started, total size: {total_size} bytes")
            
            # Download to cache file
            cache_path.parent.mkdir(parents=True, exist_ok=True)
            temp_update_path = cache_path
            
            with open(temp_update_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            progress = int((downloaded / total_size) * 100)
                            self.progress_updated.emit(progress)
                            if progress % 20 == 0:  # Log every 20%
                                silent_print(f"Download progress: {progress}%")
            
                silent_print(f"Download complete: {downloaded} bytes, cached to {cache_path}")
            self.status_updated.emit("Finding .rockbox folder...")
            
            # Find or create .rockbox folder
            rockbox_dir = None
            
            # Check if selected directory is .rockbox itself
            if self.target_directory.name.lower() == '.rockbox':
                silent_print("Selected directory is .rockbox folder")
                rockbox_dir = self.target_directory
            else:
                # Check if .rockbox exists in selected directory
                potential_rockbox = self.target_directory / '.rockbox'
                if potential_rockbox.exists() and potential_rockbox.is_dir():
                    silent_print(f"Found existing .rockbox folder: {potential_rockbox}")
                    rockbox_dir = potential_rockbox
                else:
                    # Create .rockbox folder
                    self.status_updated.emit("Creating .rockbox folder...")
                    silent_print(f"Creating .rockbox folder at: {potential_rockbox}")
                    potential_rockbox.mkdir(parents=True, exist_ok=True)
                    rockbox_dir = potential_rockbox
                    silent_print(".rockbox folder created successfully")
            
            # Copy update.zip to .rockbox folder (keep cached copy)
            self.status_updated.emit("Copying update.zip to .rockbox...")
            target_update_path = rockbox_dir / "update.zip"
            silent_print(f"Copying update.zip to: {target_update_path}")
            
            import shutil
            # Copy instead of move to preserve cache
            shutil.copy2(str(temp_update_path), str(target_update_path))
            
            silent_print("update.zip successfully copied to .rockbox folder")
            self.send_completed.emit(True, f"update.zip successfully placed in {rockbox_dir}", "usb_storage")
            
        except Exception as e:
            silent_print(f"Error in UpdateZipSenderWorker: {e}")
            import traceback
            traceback.print_exc()
            self.send_completed.emit(False, f"Error: {str(e)}", "usb_storage")
            
            # Clean up temp file (only if it was a temporary file, not cached)
            try:
                temp_file = Path("update.zip.tmp")
                if temp_file.exists():
                    temp_file.unlink()
                    silent_print("Cleaned up temporary file")
            except:
                pass

class DownloadWorker(QThread):
    """Worker thread for downloading and processing firmware"""

    progress_updated = Signal(int)
    status_updated = Signal(str)
    download_completed = Signal(bool, str)

    def __init__(self, download_url, repo_name, version):
        super().__init__()
        self.download_url = download_url
        self.repo_name = repo_name
        self.version = version
        self.should_stop = False
    
    def stop(self):
        """Stop the download worker"""
        self.should_stop = True

    def run(self):
        try:
            self.status_updated.emit("Downloading...")

            # Download the file
            response = requests.get(self.download_url, stream=True, timeout=30)
            response.raise_for_status()

            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            start_time = time.time()

            # Create downloads directory if it doesn't exist
            ZIP_STORAGE_DIR.mkdir(exist_ok=True)

            zip_path = get_zip_path(self.repo_name, self.version)

            with open(zip_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            progress = int((downloaded / total_size) * 100)
                            self.progress_updated.emit(progress)

                            # Calculate ETA
                            elapsed_time = time.time() - start_time
                            if elapsed_time > 0:
                                download_speed = downloaded / elapsed_time
                                remaining_bytes = total_size - downloaded
                                eta_seconds = remaining_bytes / download_speed if download_speed > 0 else 0

                                # Format ETA
                                if eta_seconds < 60:
                                    eta_str = f"{eta_seconds:.0f}s"
                                elif eta_seconds < 3600:
                                    eta_str = f"{eta_seconds/60:.0f}m"
                                else:
                                    eta_str = f"{eta_seconds/3600:.1f}h"

                                # Format file size
                                downloaded_mb = downloaded / (1024 * 1024)
                                total_mb = total_size / (1024 * 1024)

                                status_msg = f"Downloading... {progress}% ({downloaded_mb:.1f}MB / {total_mb:.1f}MB) - ETA: {eta_str}"
                                self.status_updated.emit(status_msg)

            self.status_updated.emit("Download completed. Extracting...")

            # Extract the zip file
            extracted_files = []
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                extracted_files = safe_extractall(zip_ref, ".", zip_path.name)

            # Log extracted files for cleanup
            log_extracted_files(extracted_files)

            # Update history.ini with the last extracted .txt file (scatter file)
            update_history_ini()

            self.status_updated.emit("Extraction completed. Files ready for MTK processing.")

            # Check if required files exist
            required_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
            missing_files = []
            for file in required_files:
                if not Path(file).exists():
                    missing_files.append(file)

            if missing_files:
                error_msg = f"Missing required files: {', '.join(missing_files)}"
                self.download_completed.emit(False, error_msg)
                return

            # Show success message with file list and instructions
            success_msg = "Firmware files successfully extracted:\n"
            for file in required_files:
                file_size = Path(file).stat().st_size
                size_mb = file_size / (1024 * 1024)
                success_msg += f"- {file} ({size_mb:.1f} MB)\n"

            success_msg += "\nFor the best results:\n"
            success_msg += "1. Make sure your Y1 is disconnect until you're asked\n"
            success_msg += "2. Follow the on screen guidance during the process"
            success_msg += f""
            success_msg += ""

            self.download_completed.emit(True, success_msg)

        except Exception as e:
            self.download_completed.emit(False, f"Error: {str(e)}")


class ProgressiveReleaseWorker(QThread):
    """Worker thread for progressively loading releases one by one without blocking UI"""
    
    release_loaded = Signal(dict)  # Emitted when a single release is loaded
    loading_complete = Signal(list)  # Emitted when all releases are loaded
    loading_failed = Signal(str)  # Emitted on error
    
    def __init__(self, github_api, repo, selected_type, show_prereleases):
        super().__init__()
        self.github_api = github_api
        self.repo = repo
        self.selected_type = selected_type
        self.show_prereleases = show_prereleases
        self.stop_requested = False
        
    def stop(self):
        """Request to stop loading"""
        self.stop_requested = True
        
    def run(self):
        """Progressive loading of releases - ONLY fetches fresh data (cache handled separately)"""
        try:
            # Defensive check - ensure attributes exist
            try:
                if not hasattr(self, 'stop_requested'):
                    self.stop_requested = False
                if not hasattr(self, 'github_api') or not hasattr(self, 'repo'):
                    return
            except (AttributeError, RuntimeError) as e:
                silent_print(f"Error accessing worker attributes: {e}")
                return
            
            # Check stop_requested before starting
            if self.stop_requested:
                return
            
            # Fetch releases from GitHub API progressively
            url = f"https://api.github.com/repos/{self.repo}/releases?per_page=30"
            
            # Try authenticated request
            response = None
            if not self.stop_requested and self.github_api.tokens:
                response = self.github_api.make_authenticated_request(url, self.repo)
            
            # Fallback to unauthenticated
            if not self.stop_requested and not response:
                if self.github_api.can_make_unauth_request():
                    try:
                        self.github_api.record_unauth_request()
                        response = self.github_api.session.get(url, timeout=REQUEST_TIMEOUT)
                    except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
                        # Network error - offline or connection failed (non-blocking)
                        silent_print(f"Network error in ProgressiveReleaseWorker (offline?): {e}")
                        if not self.stop_requested:
                            self.loading_failed.emit(f"Network error: {e}")
                        return
                    except Exception as e:
                        silent_print(f"Error in ProgressiveReleaseWorker: {e}")
                        if not self.stop_requested:
                            self.loading_failed.emit(f"Error: {e}")
                        return
            
            if self.stop_requested:
                return
            
            if not response or response.status_code != 200:
                if not self.stop_requested:
                    self.loading_failed.emit(f"Failed to fetch releases: {response.status_code if response else 'No response'}")
                return
            
            releases_data = response.json()
            silent_print(f"Fetched {len(releases_data)} releases from GitHub API")
            
            all_releases = []
            added_count = 0
            
            # Process and emit releases one by one
            for release_data in releases_data:
                if self.stop_requested:
                    return
                
                # Check if release has rom.zip
                assets = release_data.get('assets', [])
                zip_asset = None
                for asset in assets:
                    if asset['name'].lower() == 'rom.zip':
                        zip_asset = asset
                        break
                
                if not zip_asset:
                    continue  # Skip releases without rom.zip
                
                # Build release object
                release = {
                    'tag_name': release_data.get('tag_name', ''),
                    'name': release_data.get('name', ''),
                    'body': release_data.get('body', ''),
                    'published_at': release_data.get('published_at', ''),
                    'download_url': zip_asset['browser_download_url'],
                    'asset_name': zip_asset['name'],
                    'asset_size': zip_asset.get('size', 0),
                    'assets': release_data.get('assets', []),
                    'prerelease': release_data.get('prerelease', False)
                }
                
                all_releases.append(release)
                
                # Filter and emit if should be included
                if self._should_include_release(release):
                    if not self.stop_requested:
                        self.release_loaded.emit(release)
                        added_count += 1
                        # No limit - show all releases that match the filter
                        # No delay needed - UI updates are batched on the main thread
                
                if self.stop_requested:
                    return
            
            if self.stop_requested:
                return
            
            # Cache all releases for future use
            if all_releases and not self.stop_requested:
                try:
                    self.github_api.cache_releases(self.repo, all_releases)
                except Exception as e:
                    silent_print(f"Error caching releases: {e}")
            
            if not self.stop_requested:
                try:
                    self.loading_complete.emit(all_releases)
                except RuntimeError:
                    # Receiver might be destroyed
                    pass
            
        except Exception as e:
            if not self.stop_requested:
                try:
                    silent_print(f"Error in progressive release loading: {e}")
                    import traceback
                    traceback.print_exc()
                    self.loading_failed.emit(str(e))
                except RuntimeError:
                    # Receiver might be destroyed
                    pass
    
    def _should_include_release(self, release):
        """Check if release should be included based on filters"""
        tag_name = release.get('tag_name', '')
        
        # Skip releases that should be excluded
        if 'base' in tag_name.lower():
            return False
        
        # Check type filter
        has_type_b = 'type-b' in tag_name.lower()
        if self.selected_type == 'B':
            if not has_type_b:
                return False
        else:
            if has_type_b:
                return False
        
        # Check pre-release filter
        # When unchecked: Show only stable builds (hide pre-releases and nightly)
        # When checked: Show only pre-releases (hide stable builds)
        is_prerelease = _release_looks_prerelease(release)
        is_stable = not is_prerelease

        if self.show_prereleases:
            # When checked: Show only pre-releases (hide stable builds)
            if is_stable:
                return False
            return True
        else:
            # When unchecked: Show only stable builds
            if is_prerelease:
                return False
            # Show stable builds only
            return True


class AllReleasesWorker(QThread):
    """Worker thread for loading releases from all packages without blocking UI"""
    
    releases_loaded = Signal(list)  # Emitted when releases are loaded for a package
    loading_complete = Signal(list)  # Emitted when all packages are processed
    loading_failed = Signal(str)  # Emitted on error
    
    def __init__(self, github_api, packages):
        super().__init__()
        self.github_api = github_api
        self.packages = packages
        self.stop_requested = False
    
    def stop(self):
        """Request to stop loading"""
        self.stop_requested = True
    
    def run(self):
        """Load releases from all packages in background thread"""
        try:
            # Defensive check - ensure attributes exist
            try:
                if not hasattr(self, 'stop_requested'):
                    self.stop_requested = False
                if not hasattr(self, 'github_api') or not hasattr(self, 'packages'):
                    return
            except (AttributeError, RuntimeError) as e:
                silent_print(f"Error accessing worker attributes: {e}")
                return
            
            if self.stop_requested:
                return
            
            all_releases = []
            
            for package in self.packages:
                if self.stop_requested:
                    return
                
                repo = package.get('repo')
                if not repo:
                    continue
                
                try:
                    # Call get_all_releases() in worker thread (non-blocking for main thread)
                    releases = self.github_api.get_all_releases(repo)
                    
                    if self.stop_requested:
                        return
                    
                    if releases:
                        # Add software name and repo name to each release
                        for release in releases:
                            if self.stop_requested:
                                return
                            release_with_software = release.copy()
                            release_with_software['software_name'] = package.get('name', repo)
                            release_with_software['repo_name'] = repo
                            all_releases.append(release_with_software)
                        
                        # Emit progress signal
                        if not self.stop_requested:
                            try:
                                self.releases_loaded.emit(releases)
                            except RuntimeError:
                                # Receiver might be destroyed
                                pass
                    
                    # Small delay between packages to prevent overwhelming the network
                    if not self.stop_requested:
                        self.msleep(100)  # 100ms delay between packages
                        
                except Exception as e:
                    if not self.stop_requested:
                        silent_print(f"Error getting releases for {repo}: {e}")
                    continue
            
            if self.stop_requested:
                return
            
            # Emit completion signal
            if not self.stop_requested:
                try:
                    self.loading_complete.emit(all_releases)
                except RuntimeError:
                    # Receiver might be destroyed
                    pass
            
        except Exception as e:
            if not self.stop_requested:
                try:
                    silent_print(f"Error in AllReleasesWorker: {e}")
                    import traceback
                    traceback.print_exc()
                    self.loading_failed.emit(str(e))
                except RuntimeError:
                    # Receiver might be destroyed
                    pass


class DataLoaderWorker(QThread):
    """Worker thread for loading manifest data without blocking UI"""
    
    data_loaded = Signal(list)  # Emitted when packages are loaded
    loading_failed = Signal(str)  # Emitted on error
    
    def __init__(self, config_downloader):
        super().__init__()
        self.config_downloader = config_downloader
        self.stop_requested = False
    
    def stop(self):
        """Request to stop loading"""
        self.stop_requested = True
    
    def run(self):
        """Load manifest data in background thread"""
        try:
            if self.stop_requested:
                return
            
            # Download manifest (this will be non-blocking for main thread since we're in a worker thread)
            packages = self.config_downloader.download_manifest(use_local_first=True)
            
            if self.stop_requested:
                return
            
            silent_print(f"Loaded {len(packages)} packages in background thread")
            self.data_loaded.emit(packages)
            
        except Exception as e:
            if not self.stop_requested:
                silent_print(f"Error loading data in background: {e}")
                self.loading_failed.emit(str(e))


class TokenLoaderWorker(QThread):
    """Worker thread for loading tokens without blocking UI"""
    
    tokens_loaded = Signal(list)  # Emitted when tokens are loaded
    loading_failed = Signal(str)  # Emitted on error
    
    def __init__(self, config_downloader):
        super().__init__()
        self.config_downloader = config_downloader
        self.stop_requested = False
    
    def stop(self):
        """Request to stop loading"""
        self.stop_requested = True
    
    def run(self):
        """Load tokens in background thread"""
        try:
            if self.stop_requested:
                return
            
            # Download tokens (this will be non-blocking for main thread since we're in a worker thread)
            tokens = self.config_downloader.download_config()
            
            if self.stop_requested:
                return
            
            if not tokens:
                silent_print("No API tokens available - using unauthenticated mode")
                self.tokens_loaded.emit([])
                return
            
            silent_print(f"Loaded {len(tokens)} API tokens in background thread")
            self.tokens_loaded.emit(tokens)
            
        except Exception as e:
            if not self.stop_requested:
                silent_print(f"Error loading tokens in background: {e}")
                self.loading_failed.emit(str(e))


class ReleaseInstallWorker(QThread):
    """Worker that downloads and installs a selected Innioasis Updater release."""

    progress_updated = Signal(int)
    status_updated = Signal(str)
    finished = Signal(bool, str)

    def __init__(self, version, release_data, download_token=None, parent=None):
        super().__init__(parent)
        self.version = version
        self.release_data = release_data or {}
        self.download_token = download_token
        self.is_windows = platform.system() == "Windows"
        self.stop_requested = False

    def _normalize_tag(self):
        tag = self.release_data.get('tag_name') or self.version
        if not tag:
            return None
        tag = tag.strip()
        if not tag:
            return None
        if tag.lower().startswith('v'):
            return tag
        return f"v{tag}"

    def run(self):
        temp_dir = None
        try:
            current_dir = Path.cwd()
            temp_dir = Path(tempfile.mkdtemp(prefix="innioasis-release-"))

            normalized_tag = self._normalize_tag()
            zip_url = self.release_data.get('zipball_url')
            if not zip_url and normalized_tag:
                zip_url = f"https://github.com/y1-community/Innioasis-Updater/archive/refs/tags/{normalized_tag}.zip"

            zip_path = temp_dir / "release.zip"
            extracted_dir = None

            if zip_url:
                self.status_updated.emit(f"Downloading Innioasis Updater {self.version} from GitHub‚Ä¶")
                if self._download_release_zip(zip_url, zip_path):
                    extracted_dir = self._extract_zip(zip_path, temp_dir)
                else:
                    self.status_updated.emit("Could not download release ZIP. Falling back to innioasis.app mirror‚Ä¶")
            else:
                self.status_updated.emit("No GitHub archive available. Falling back to innioasis.app mirror‚Ä¶")

            if extracted_dir:
                self.status_updated.emit("Installing files from release archive‚Ä¶")
                self._copy_release_contents(extracted_dir, current_dir)
            else:
                if not self._update_from_mirror(current_dir):
                    self.finished.emit(False, "Unable to download release from GitHub or innioasis.app mirror.")
                    return

            self.status_updated.emit("Refreshing manifest and configuration‚Ä¶")
            self._download_manifest_and_config(current_dir)

            self.progress_updated.emit(100)
            self.finished.emit(True, "Installation complete.")
        except Exception as e:
            logging.error("ReleaseInstallWorker error: %s", e)
            self.finished.emit(False, str(e))
        finally:
            if temp_dir and temp_dir.exists():
                shutil.rmtree(temp_dir, ignore_errors=True)

    def _download_release_zip(self, url, destination):
        try:
            headers = {'Accept': 'application/vnd.github+json'}
            if self.download_token:
                headers['Authorization'] = f'token {self.download_token}'
            response = requests.get(url, stream=True, timeout=20, headers=headers)
            if response.status_code == 302:
                redirect_url = response.headers.get('Location')
                if redirect_url:
                    response = requests.get(redirect_url, stream=True, timeout=20, headers=headers)
            response.raise_for_status()

            total = int(response.headers.get('content-length', 0))
            downloaded = 0
            start_progress = 5
            range_span = 30
            with open(destination, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if self.stop_requested:
                        return False
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total:
                            progress = start_progress + int((downloaded / total) * range_span)
                            self.progress_updated.emit(min(progress, start_progress + range_span))
            if total == 0:
                self.progress_updated.emit(start_progress + range_span)
            return True
        except Exception as e:
            logging.error("Failed to download release zip: %s", e)
            return False

    def _extract_zip(self, zip_path, temp_dir):
        try:
            with zipfile.ZipFile(zip_path, 'r') as z:
                members = z.infolist()
                total = len(members) or 1
                for idx, member in enumerate(members):
                    if self.stop_requested:
                        return None
                    z.extract(member, temp_dir)
                    if idx % 20 == 0 or idx == total - 1:
                        progress = 40 + int((idx / total) * 10)
                        self.progress_updated.emit(progress)
            extracted_dirs = [p for p in temp_dir.iterdir() if p.is_dir()]
            extracted_dirs.sort(key=lambda p: p.stat().st_mtime, reverse=True)
            return extracted_dirs[0] if extracted_dirs else None
        except Exception as e:
            logging.error("Failed to extract release zip: %s", e)
            return None

    def _copy_release_contents(self, extracted_root, target_dir):
        items = list(extracted_root.iterdir())
        if not items and extracted_root.is_dir():
            items = [p for p in extracted_root.rglob('*') if p.parent == extracted_root]

        total = len(items) or 1
        skip_names = {'.git', '__pycache__', '.ds_store', 'firmware_downloads', '.web_scripts'}

        for idx, item in enumerate(items):
            if self.stop_requested:
                return
            if item.name.lower() in skip_names:
                continue
            target_path = target_dir / item.name
            try:
                if item.is_file():
                    self._copy_file(item, target_path)
                elif item.is_dir():
                    self._copy_directory(item, target_path, skip_names)
            except Exception as e:
                logging.info("Skipping %s due to error: %s", item.name, e)
            progress = 55 + int((idx / total) * 25)
            self.progress_updated.emit(min(progress, 80))

    def _copy_file(self, src, dest):
        suffix = src.suffix.lower()
        if not self.is_windows and suffix in ['.exe', '.dll', '.lnk']:
            return
        dest.parent.mkdir(parents=True, exist_ok=True)
        if suffix in ['.exe', '.dll'] and dest.exists():
            try:
                if src.stat().st_mtime <= dest.stat().st_mtime:
                    return
            except Exception:
                return
        shutil.copy2(src, dest)

    def _copy_directory(self, src_dir, dest_dir, skip_names):
        if dest_dir.exists():
            for child in src_dir.iterdir():
                if child.name.lower() in skip_names:
                    continue
                target = dest_dir / child.name
                if child.is_file():
                    self._copy_file(child, target)
                elif child.is_dir():
                    self._copy_directory(child, target, skip_names)
        else:
            try:
                shutil.copytree(src_dir, dest_dir)
            except FileExistsError:
                self._copy_directory(src_dir, dest_dir, skip_names)

    def _update_from_mirror(self, target_dir):
        try:
            self.status_updated.emit("Getting the newest files from innioasis.app‚Ä¶")
            essential_files = [
                Path("firmware_downloader.py"),
                Path("updater.py"),
                Path("config.ini"),
                Path("index.html"),
                Path("mtkclient/__init__.py"),
                Path("mtkclient/mtk.py"),
                Path("mtkclient/gui/__init__.py"),
            ]
            safe_suffixes = {
                '.py', '.pyw', '.html', '.css', '.js', '.json',
                '.ini', '.txt', '.md', '.yaml', '.yml', '.xml', '.svg'
            }
            skip_dirs = {'.git', '__pycache__', 'firmware_downloads', '.web_scripts', '.build', 'UpdaterDownloads', '.idea', '.vscode'}
            base_url = "https://www.innioasis.app/"

            def download_single(relative_path):
                url = urllib.parse.urljoin(base_url, relative_path.as_posix())
                url = requests.utils.requote_uri(url)
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    dest = target_dir / relative_path
                    dest.parent.mkdir(parents=True, exist_ok=True)
                    dest.write_bytes(response.content)
                    return True
                return False

            updated_any = False
            for rel in essential_files:
                if download_single(rel):
                    updated_any = True

            if not updated_any:
                return False

            attempts = 0
            for path in target_dir.rglob("*"):
                if attempts > 400:
                    break
                if any(part in skip_dirs for part in path.relative_to(target_dir).parts):
                    continue
                if path.is_dir():
                    continue
                suffix = path.suffix.lower()
                if suffix and suffix not in safe_suffixes:
                    continue
                if download_single(path.relative_to(target_dir)):
                    updated_any = True
                attempts += 1

            self.progress_updated.emit(90)
            return updated_any
        except Exception as e:
            logging.error("Mirror update failed: %s", e)
            return False

    def _download_manifest_and_config(self, target_dir):
        endpoints = [
            ("https://innioasis.app/slidia_manifest.xml", target_dir / "slidia_manifest.xml"),
            ("https://innioasis.app/config.ini", target_dir / "config.ini"),
        ]
        for idx, (url, dest) in enumerate(endpoints):
            try:
                response = requests.get(url, timeout=10)
                response.raise_for_status()
                dest.write_bytes(response.content)
            except Exception as e:
                logging.error("Failed to refresh %s: %s", dest.name, e)
            self.progress_updated.emit(92 + idx * 3)


class ReleaseInstallDialog(QDialog):
    """Modal dialog that shows progress while installing a selected release."""

    def __init__(self, parent, version, release_data, download_token=None):
        super().__init__(parent)
        self.setWindowTitle(f"Installing Innioasis Updater {version}")
        self.setModal(True)
        self.setFixedSize(520, 220)
        self.success = False
        self.error_message = ""

        layout = QVBoxLayout(self)
        title = QLabel(f"Innioasis Updater {version}")
        title.setFont(QFont("Arial", 15, QFont.Bold))
        title.setAlignment(Qt.AlignCenter)
        layout.addWidget(title)

        self.status_label = QLabel("Preparing‚Ä¶")
        self.status_label.setAlignment(Qt.AlignCenter)
        self.status_label.setWordWrap(True)
        layout.addWidget(self.status_label)

        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(5)
        layout.addWidget(self.progress_bar)

        self.close_btn = QPushButton("Close")
        self.close_btn.setEnabled(False)
        self.close_btn.clicked.connect(self.accept)
        btn_layout = QHBoxLayout()
        btn_layout.addStretch()
        btn_layout.addWidget(self.close_btn)
        layout.addLayout(btn_layout)

        token = download_token
        self.worker = ReleaseInstallWorker(version, release_data, token)
        self.worker.progress_updated.connect(self.progress_bar.setValue)
        self.worker.status_updated.connect(self.status_label.setText)
        self.worker.finished.connect(self._on_finished)
        self.worker.start()

    def _on_finished(self, success, message):
        self.success = success
        self.error_message = message
        if success:
            self.progress_bar.setValue(100)
            self.status_label.setText(message or "Installation complete.")
        else:
            self.status_label.setText(message or "Update finished with issues.")
        self.close_btn.setEnabled(True)
        if success:
            QTimer.singleShot(1200, self.accept)


class FileTransferWorker(QThread):
    """Worker thread for transferring files/folders to device via ADB"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int, int)  # Emitted with (current, total) progress
    completed = Signal(bool, dict)  # Emitted when done (success, result_dict with transferred_count, failed_files)
    
    def __init__(self, adb_path, connected_device_id, env, file_paths, destination_folder):
        super().__init__()
        self.adb_path = adb_path
        self.connected_device_id = connected_device_id
        self.env = env
        self.file_paths = file_paths
        self.destination_folder = destination_folder
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Transfer files in background thread"""
        try:
            if self.stop_requested:
                return
            
            transferred_count = 0
            failed_files = []
            total = len(self.file_paths)
            
            for i, file_path in enumerate(self.file_paths):
                if self.stop_requested:
                    break
                
                self.progress_update.emit(i, total)
                
                try:
                    path = Path(file_path)
                    if not path.exists():
                        failed_files.append(f"{path.name} (not found)")
                        continue
                    
                    # Skip macOS metadata files/folders
                    # Check if it's a macOS metadata file/folder
                    is_macos_metadata = False
                    if path.name.startswith('._') or path.name == '.DS_Store' or '__MACOSX' in str(path):
                        is_macos_metadata = True
                    
                    if is_macos_metadata:
                        silent_print(f"Skipping macOS metadata: {path}")
                        continue
                    
                    # Determine destination path on device using selected folder
                    destination = f"{self.destination_folder}/{path.name}"
                    
                    # Show current file being transferred
                    self.status_update.emit(f"Transferring: {path.name}...")
                    
                    # Build ADB command
                    adb_cmd = [str(self.adb_path)]
                    if self.connected_device_id:
                        adb_cmd.extend(['-s', self.connected_device_id])
                    
                    if path.is_file():
                        # Transfer file
                        adb_cmd.extend(['push', str(path), destination])
                    elif path.is_dir():
                        # Transfer folder - use adb push with directory
                        adb_cmd.extend(['push', str(path), destination])
                    
                    # Execute transfer with real-time output
                    transfer_process = subprocess.Popen(
                        adb_cmd,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        text=True,
                        bufsize=1,
                        universal_newlines=True,
                        env=self.env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                    
                    # Read output line by line and emit status updates
                    transfer_output_lines = []
                    while True:
                        if self.stop_requested:
                            transfer_process.terminate()
                            break
                        
                        output = transfer_process.stdout.readline()
                        if output == '' and transfer_process.poll() is not None:
                            break
                        
                        if output:
                            line = output.strip()
                            if line:
                                transfer_output_lines.append(line)
                                silent_print(f"ADB Transfer: {line}")
                                # Display in status area
                                self.status_update.emit(f"ADB: {line}")
                    
                    # Wait for process to complete
                    return_code = transfer_process.wait()
                    
                    if return_code == 0:
                        transferred_count += 1
                        silent_print(f"Successfully transferred: {path.name}")
                    else:
                        error_msg = '\n'.join(transfer_output_lines) if transfer_output_lines else "Unknown error"
                        # Check for read-only file system error - indicates USB Storage mode is active
                        if "read-only file system" in error_msg.lower() or "Read-only file system" in error_msg:
                            silent_print("Read-only file system detected - USB Storage mode likely active, falling back to USB storage mode")
                            # Emit signal to trigger USB storage mode fallback
                            self.status_update.emit("ADB transfer failed (read-only), switching to USB storage mode...")
                            # Store failed file for USB transfer
                            failed_files.append(f"{path.name} (read-only, will retry via USB)")
                            # Continue to next file - USB fallback will be handled by main thread
                            continue

                        failed_files.append(f"{path.name} ({error_msg})")
                        silent_print(f"Failed to transfer: {path.name} - {error_msg}")
                    
                except Exception as e:
                    failed_files.append(f"{path.name} ({str(e)})")
                    silent_print(f"Error transferring {path.name}: {e}")
            
            self.progress_update.emit(total, total)
            
            # Emit completion with result dictionary
            result = {
                'transferred_count': transferred_count,
                'failed_files': failed_files,
                'total': total
            }
            
            if transferred_count == total:
                self.completed.emit(True, result)
            elif transferred_count > 0:
                self.completed.emit(True, result)  # Partial success
            else:
                self.completed.emit(False, result)
                
        except Exception as e:
            silent_print(f"Error in FileTransferWorker: {e}")
            import traceback
            traceback.print_exc()
            result = {
                'transferred_count': 0,
                'failed_files': [f"Error: {str(e)}"],
                'total': len(self.file_paths)
            }
            self.completed.emit(False, result)


class USBFileTransferWorker(QThread):
    """Worker thread for transferring files/folders to device via USB storage mode"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int, int)  # Emitted with (current, total) progress
    completed = Signal(bool, dict)  # Emitted when done (success, result_dict with transferred_count, failed_files)
    
    def __init__(self, file_paths, usb_drive_path):
        super().__init__()
        self.file_paths = file_paths
        self.usb_drive_path = usb_drive_path
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Transfer files in background thread"""
        try:
            if self.stop_requested:
                return
            
            transferred_count = 0
            failed_files = []
            total = len(self.file_paths)
            dest_base = Path(self.usb_drive_path)
            
            for i, file_path in enumerate(self.file_paths):
                if self.stop_requested:
                    break
                
                self.progress_update.emit(i, total)
                
                try:
                    source_path = Path(file_path)
                    if not source_path.exists():
                        failed_files.append(f"{source_path.name} (not found)")
                        continue
                    
                    # Show current file being transferred
                    self.status_update.emit(f"Copying {source_path.name}...")
                    
                    # Skip macOS metadata files/folders
                    if self._is_macos_metadata(source_path):
                        silent_print(f"Skipping macOS metadata file: {source_path.name}")
                        continue
                    
                    if source_path.is_file():
                        # Copy file to destination, sanitizing name for FAT/exFAT compatibility
                        dest_name = self._sanitize_usb_filename(source_path.name)
                        dest_path = dest_base / dest_name
                        import shutil
                        shutil.copy2(source_path, dest_path)
                        transferred_count += 1
                        silent_print(f"Successfully copied: {source_path.name}")
                    elif source_path.is_dir():
                        # Copy directory to destination, cleaning macOS metadata
                        dest_folder_name = self._sanitize_usb_filename(source_path.name)
                        dest_path = dest_base / dest_folder_name
                        import shutil
                        if dest_path.exists():
                            # Merge directories
                            self._copy_tree_clean_metadata(source_path, dest_path)
                        else:
                            shutil.copytree(source_path, dest_path)
                            # Clean macOS metadata after copy
                            self._cleanup_macos_metadata(dest_path)
                        transferred_count += 1
                        silent_print(f"Successfully copied directory: {source_path.name}")
                except Exception as e:
                    failed_files.append(f"{Path(file_path).name} ({str(e)})")
                    silent_print(f"Error transferring {file_path}: {e}")
            
            self.progress_update.emit(total, total)
            
            # Emit completion with result dictionary
            result = {
                'transferred_count': transferred_count,
                'failed_files': failed_files,
                'total': total,
                'usb_drive_path': str(self.usb_drive_path)
            }
            
            if transferred_count == total:
                self.completed.emit(True, result)
            elif transferred_count > 0:
                self.completed.emit(True, result)  # Partial success
            else:
                self.completed.emit(False, result)
                
        except Exception as e:
            silent_print(f"Error in USBFileTransferWorker: {e}")
            import traceback
            traceback.print_exc()
            result = {
                'transferred_count': 0,
                'failed_files': [f"Error: {str(e)}"],
                'total': len(self.file_paths),
                'usb_drive_path': str(self.usb_drive_path)
            }
            self.completed.emit(False, result)
    
    def _is_macos_metadata(self, path):
        """Check if path is a macOS metadata file/folder"""
        path_str = str(path)
        name = path.name
        return (name.startswith('._') or 
                name == '.DS_Store' or 
                '__MACOSX' in path_str or
                name == '.Trashes' or
                name.startswith('.') and name.endswith('~'))
    
    def _cleanup_macos_metadata(self, directory):
        """Remove macOS metadata files from a directory"""
        try:
            dir_path = Path(directory)
            if not dir_path.exists() or not dir_path.is_dir():
                return
            
            for item in dir_path.rglob('*'):
                if self._is_macos_metadata(item):
                    try:
                        if item.is_file():
                            item.unlink()
                        elif item.is_dir():
                            import shutil
                            shutil.rmtree(item)
                        silent_print(f"Removed macOS metadata: {item}")
                    except Exception as e:
                        silent_print(f"Error removing macOS metadata {item}: {e}")
        except Exception as e:
            silent_print(f"Error cleaning macOS metadata from {directory}: {e}")
    
    def _copy_tree_clean_metadata(self, src, dst):
        """Copy directory tree while cleaning macOS metadata files"""
        import shutil
        for item in src.iterdir():
            if self._is_macos_metadata(item):
                silent_print(f"Skipping macOS metadata: {item.name}")
                continue
            src_path = src / item.name
            dst_path = dst / item.name
            if src_path.is_dir():
                if dst_path.exists():
                    self._copy_tree_clean_metadata(src_path, dst_path)
                else:
                    shutil.copytree(src_path, dst_path)
                    self._cleanup_macos_metadata(dst_path)
            else:
                shutil.copy2(src_path, dst_path)


class FastUpdateWorker(QThread):
    """Worker thread for Fast Update operations via ADB"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int)  # Emitted with progress percentage (0-100)
    completed = Signal(bool, str, str)  # Emitted when done (success, message, transfer_method)
    
    def __init__(self, adb_path, update_zip_url, env, device_id=None):
        super().__init__()
        self.adb_path = adb_path
        self.update_zip_url = update_zip_url
        self.env = env
        self.device_id = device_id  # Optional device ID (prefers USB when both are available)
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Execute Fast Update in background thread"""
        try:
            if self.stop_requested:
                return
            
            # Step 1: Download or use cached update.zip
            self.status_update.emit("ADB: Downloading update.zip...")
            self.progress_update.emit(0)
            
            cache_path = get_update_zip_cache_path(self.update_zip_url)
            temp_update_path = None
            
            if cache_path.exists():
                silent_print(f"Using cached update.zip from: {cache_path}")
                self.status_update.emit("ADB: Using cached update.zip...")
                self.progress_update.emit(20)
                temp_update_path = cache_path
            else:
                # Download update.zip
                silent_print("Downloading update.zip...")
                self.status_update.emit("ADB: Downloading update.zip...")
                response = requests.get(self.update_zip_url, stream=True, timeout=30)
                response.raise_for_status()
                
                total_size = int(response.headers.get('content-length', 0))
                downloaded = 0
                
                # Download to cache file
                cache_path.parent.mkdir(parents=True, exist_ok=True)
                temp_update_path = cache_path
                
                with open(temp_update_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if self.stop_requested:
                            return
                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)
                            if total_size > 0:
                                progress = int((downloaded / total_size) * 40)  # 0-40% for download
                                self.progress_update.emit(progress)
                
                silent_print(f"Download complete: {downloaded} bytes, cached to {cache_path}")
            
            if self.stop_requested:
                return
            
            # Step 2: Create .rockbox directory
            self.status_update.emit("ADB: Creating .rockbox directory...")
            self.progress_update.emit(40)
            
            # Build ADB command with device ID if provided
            mkdir_cmd = [str(self.adb_path)]
            if self.device_id:
                mkdir_cmd.extend(['-s', self.device_id])
            mkdir_cmd.extend(['shell', 'mkdir', '-p', '/sdcard/.rockbox'])
            
            mkdir_result = subprocess.run(
                mkdir_cmd,
                capture_output=True,
                text=True,
                timeout=10,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if mkdir_result.stdout.strip():
                self.status_update.emit(f"ADB: {mkdir_result.stdout.strip()}")
            
            if self.stop_requested:
                return
            
            # Step 3: Push update.zip to device
            self.status_update.emit("ADB: Pushing update.zip to device...")
            self.progress_update.emit(50)
            
            # Build ADB command with device ID if provided
            push_cmd = [str(self.adb_path)]
            if self.device_id:
                push_cmd.extend(['-s', self.device_id])
            push_cmd.extend(['push', str(temp_update_path), '/sdcard/.rockbox/update.zip'])
            
            push_process = subprocess.Popen(
                push_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line and emit status updates
            push_output_lines = []
            while True:
                if self.stop_requested:
                    push_process.terminate()
                    return
                
                output = push_process.stdout.readline()
                if output == '' and push_process.poll() is not None:
                    break
                
                if output:
                    line = output.strip()
                    if line:
                        push_output_lines.append(line)
                        silent_print(f"ADB Push: {line}")
                        self.status_update.emit(f"ADB: {line}")
            
            # Wait for process to complete
            return_code = push_process.wait()
            
            if return_code != 0:
                error_msg = '\n'.join(push_output_lines) if push_output_lines else "Unknown error"
                self.completed.emit(False, f"Failed to push update.zip: {error_msg}", "adb")
                return
            
            if self.stop_requested:
                return
            
            silent_print("update.zip pushed successfully")
            if push_output_lines:
                final_line = push_output_lines[-1]
                self.status_update.emit(f"ADB: {final_line}")
            else:
                self.status_update.emit("ADB: update.zip pushed successfully")
            self.progress_update.emit(70)
            
            # Step 4: Run update script
            self.status_update.emit("ADB: Running update script as root...")
            self.progress_update.emit(80)
            
            # Clean up macOS metadata files on device before running update script
            self.status_update.emit("ADB: Cleaning macOS metadata files...")
            try:
                if self.device_id:
                    # Clean up macOS metadata directly via ADB commands
                    self._cleanup_device_macos_metadata_direct(self.adb_path, self.device_id, self.env)
            except Exception as e:
                silent_print(f"Error cleaning macOS metadata during Fast Update: {e}")
            
            update_script_path = '/data/data/update/update.sh'
            
            # Make the script executable
            silent_print(f"Making {update_script_path} executable...")
            # Build ADB command with device ID if provided
            chmod_cmd = [str(self.adb_path)]
            if self.device_id:
                chmod_cmd.extend(['-s', self.device_id])
            chmod_cmd.extend(['shell', 'su', '-c', f'chmod +x {update_script_path} || sh -c "chmod 755 {update_script_path}"'])
            
            chmod_result = subprocess.run(
                chmod_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            if chmod_result.returncode == 0:
                silent_print(f"Successfully made {update_script_path} executable")
            else:
                silent_print(f"Warning: Could not make script executable: {chmod_result.stderr}")
            
            if self.stop_requested:
                return
            
            # Run the script with real-time output capture
            silent_print(f"Executing {update_script_path} as root...")
            # Build ADB command with device ID if provided
            script_cmd = [str(self.adb_path)]
            if self.device_id:
                script_cmd.extend(['-s', self.device_id])
            script_cmd.extend(['shell', 'su', '-c', f'sh {update_script_path}'])
            
            process = subprocess.Popen(
                script_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line and emit status updates
            script_output_lines = []
            progress = 80  # Start from 80%
            progress_increment = 25  # Each "++" line = 25% progress
            
            while True:
                if self.stop_requested:
                    process.terminate()
                    return
                
                output = process.stdout.readline()
                if output == '' and process.poll() is not None:
                    break
                
                if output:
                    line = output.strip()
                    if line:
                        script_output_lines.append(line)
                        silent_print(line)
                        
                        # Check if line contains "++" (progress indicator)
                        if '++' in line:
                            # Remove "++" and any leading/trailing whitespace for display
                            display_text = line.replace('++', '').strip()
                            if display_text:
                                self.status_update.emit(display_text)
                            else:
                                self.status_update.emit(line)
                            
                            # Increment progress by 25% for each "++" line
                            progress = min(progress + progress_increment, 100)
                            self.progress_update.emit(progress)
                        else:
                            # Regular line without "++" - just show it
                            self.status_update.emit(line)
            
            # Wait for process to complete
            return_code = process.wait()
            script_success = (return_code == 0)
            
            self.progress_update.emit(100)
            
            if script_success:
                # Show final output
                if script_output_lines:
                    final_line = script_output_lines[-1]
                    if '++' in final_line:
                        final_output = final_line.replace('++', '').strip()
                        if not final_output:
                            final_output = final_line
                    else:
                        final_output = final_line
                    self.completed.emit(True, final_output, "adb")
                else:
                    self.completed.emit(True, "Update completed", "adb")
            else:
                error_msg = '\n'.join(script_output_lines) if script_output_lines else "Update script failed"
                self.completed.emit(False, error_msg, "adb")
                
        except Exception as e:
            silent_print(f"Error in FastUpdateWorker: {e}")
            import traceback
            traceback.print_exc()
            self.completed.emit(False, f"Error: {str(e)}", "adb")


class ThemeInstallWorker(QThread):
    """Worker thread for installing themes via ADB"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int, int)  # Emitted with (current, total) progress
    completed = Signal(bool, str)  # Emitted when done (success, message)
    read_only_error = Signal(list)  # Emitted when read-only error detected (theme_folders list)
    
    def __init__(self, adb_path, connected_device_id, env, theme_folders):
        super().__init__()
        self.adb_path = adb_path
        self.connected_device_id = connected_device_id
        self.env = env
        self.theme_folders = theme_folders
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Install themes in background thread"""
        try:
            if self.stop_requested:
                return
            
            mountpoint = "/storage/sdcard0"
            themes_path = f"{mountpoint}/Themes"
            
            # Ensure Themes directory exists
            try:
                subprocess.run(
                    [str(self.adb_path), '-s', self.connected_device_id, 'shell', f'mkdir -p {shlex.quote(themes_path)}'],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env=self.env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
            except Exception as mkdir_error:
                silent_print(f"Warning: unable to ensure Themes directory: {mkdir_error}")
            
            success_count = 0
            total = len(self.theme_folders)
            read_only_failed_themes = []
            
            for i, theme_folder_path in enumerate(self.theme_folders):
                if self.stop_requested:
                    break
                
                self.progress_update.emit(i, total)
                
                try:
                    theme_path = Path(theme_folder_path)
                    theme_name = theme_path.name
                    
                    self.status_update.emit(f"Installing theme '{theme_name}'...")
                    
                    # Remove any previous copy to avoid stale assets
                    dest_path = f"{themes_path}/{theme_name}"
                    try:
                        subprocess.run(
                            [str(self.adb_path), '-s', self.connected_device_id, 'shell', f'rm -rf {shlex.quote(dest_path)}'],
                            capture_output=True,
                            text=True,
                            timeout=10,
                            env=self.env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                    except Exception as rm_error:
                        silent_print(f"Warning: unable to remove existing theme {theme_name}: {rm_error}")
                    
                    # Push theme folder to device
                    adb_cmd = [str(self.adb_path), '-s', self.connected_device_id, 'push', str(theme_path), themes_path]
                    
                    push_process = subprocess.Popen(
                        adb_cmd,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        text=True,
                        bufsize=1,
                        universal_newlines=True,
                        env=self.env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                    
                    # Read output line by line and emit status updates
                    push_output_lines = []
                    while True:
                        if self.stop_requested:
                            push_process.terminate()
                            break
                        
                        output = push_process.stdout.readline()
                        if output == '' and push_process.poll() is not None:
                            break
                        if output:
                            line = output.strip()
                            if line:
                                push_output_lines.append(line)
                                # Parse ADB push progress (e.g., "1234/5678 21%")
                                if '/' in line and '%' in line:
                                    self.status_update.emit(f"Transferring '{theme_name}': {line}")
                                else:
                                    self.status_update.emit(f"ADB: {line}")
                    
                    return_code = push_process.wait()
                    
                    if return_code == 0:
                        success_count += 1
                        self.status_update.emit(f"‚úì Theme '{theme_name}' installed successfully")
                    else:
                        error_msg = '\n'.join(push_output_lines) if push_output_lines else "Unknown error"
                        # Check for read-only file system error - indicates USB Storage mode is active
                        if "read-only file system" in error_msg.lower() or "Read-only file system" in error_msg:
                            silent_print(f"Read-only file system detected for theme '{theme_name}' - USB Storage mode likely active")
                            read_only_failed_themes.append(theme_folder_path)
                            self.status_update.emit(f"‚úó Theme '{theme_name}' failed (read-only), will retry via USB storage mode")
                        else:
                            self.status_update.emit(f"‚úó Failed to install theme '{theme_name}'")
                        
                except Exception as e:
                    self.status_update.emit(f"‚úó Error installing theme: {str(e)[:100]}")
                    silent_print(f"Error installing theme folder {theme_folder_path}: {e}")
            
            self.progress_update.emit(total, total)
            
            # If we have read-only errors, signal for USB fallback
            if read_only_failed_themes:
                silent_print(f"Read-only errors detected for {len(read_only_failed_themes)} theme(s), triggering USB fallback")
                self.read_only_error.emit(read_only_failed_themes)
                return
            
            if success_count == total:
                self.completed.emit(True, f"Successfully installed {success_count} theme(s)")
            elif success_count > 0:
                self.completed.emit(True, f"Installed {success_count} of {total} theme(s)")
            else:
                self.completed.emit(False, "Failed to install themes")
                
        except Exception as e:
            silent_print(f"Error in ThemeInstallWorker: {e}")
            import traceback
            traceback.print_exc()
            self.completed.emit(False, f"Error: {str(e)[:100]}")


class CleanupWorker(QThread):
    """Worker thread for cleaning up redundant files in the background"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int, int)  # Emitted with (current, total) progress
    completed = Signal(int)  # Emitted when done (removed_count)
    
    def __init__(self):
        super().__init__()
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Clean up redundant files in background thread"""
        try:
            import concurrent.futures
            import threading
            
            current_platform = platform.system().lower()
            if current_platform == "darwin":
                platform_key = "mac"
            elif current_platform == "linux":
                platform_key = "linux"
            elif current_platform == "windows":
                platform_key = "win"
            else:
                platform_key = "unknown"
            
            self.status_update.emit(f"Cleaning up redundant files for {platform_key}...")
            
            # Load redundant files list
            redundant_files = load_redundant_files_list()
            if not redundant_files:
                self.status_update.emit("No redundant files list found")
                self.completed.emit(0)
                return
            
            current_dir = Path.cwd()
            removed_count = 0
            
            # Collect all patterns to process
            all_patterns = []
            if 'all' in redundant_files:
                all_patterns.extend([('all', p) for p in redundant_files['all']])
            if platform_key in redundant_files:
                all_patterns.extend([(platform_key, p) for p in redundant_files[platform_key]])
            
            if not all_patterns:
                self.status_update.emit("No files to clean up")
                self.completed.emit(0)
                return
            
            total_patterns = len(all_patterns)
            self.progress_update.emit(0, total_patterns)
            
            # Process patterns in parallel using ThreadPoolExecutor
            # Limit to 4 concurrent operations to avoid overwhelming the filesystem
            with concurrent.futures.ThreadPoolExecutor(max_workers=4) as executor:
                future_to_pattern = {}
                
                for idx, (platform_type, pattern) in enumerate(all_patterns):
                    if self.stop_requested:
                        break
                    
                    future = executor.submit(self._remove_files_by_pattern, current_dir, pattern)
                    future_to_pattern[future] = (idx, pattern)
                
                # Process results as they complete
                for future in concurrent.futures.as_completed(future_to_pattern):
                    if self.stop_requested:
                        break
                    
                    idx, pattern = future_to_pattern[future]
                    try:
                        count = future.result()
                        removed_count += count
                        self.status_update.emit(f"Processed pattern: {pattern} ({count} files)")
                        self.progress_update.emit(idx + 1, total_patterns)
                    except Exception as e:
                        silent_print(f"Error processing pattern {pattern}: {e}")
                        self.progress_update.emit(idx + 1, total_patterns)
            
            if removed_count > 0:
                self.status_update.emit(f"Cleaned up {removed_count} redundant files")
            else:
                self.status_update.emit("No redundant files found to clean up")
            
            # Remove redundant_files.txt after cleanup is complete
            try:
                redundant_files_path = Path("redundant_files.txt")
                if redundant_files_path.exists():
                    redundant_files_path.unlink()
                    silent_print("Removed redundant_files.txt after cleanup")
            except Exception as e:
                silent_print(f"Error removing redundant_files.txt: {e}")
            
            self.completed.emit(removed_count)
            
        except Exception as e:
            silent_print(f"Error during redundant files cleanup: {e}")
            import traceback
            traceback.print_exc()
            self.completed.emit(0)
    
    def _remove_files_by_pattern(self, directory, pattern):
        """Remove files or directories matching a pattern (thread-safe version)"""
        removed_count = 0
        try:
            # Important directories to preserve (cache, config, etc.)
            preserve_dirs = {'.cache', 'cache', 'Cache', 'CACHE'}
            
            # Important cache files to preserve (for fast startup)
            preserve_cache_files = {
                'config_cache.json',
                'manifest_cache.json',
                'releases_cache.json',
                'tokens_cache.json'
            }
            
            # Check if pattern is a directory (no file extension and exists as directory)
            pattern_path = directory / pattern
            if pattern_path.exists() and pattern_path.is_dir():
                # Don't remove preserved directories
                if pattern_path.name not in preserve_dirs:
                    # Remove entire directory
                    import shutil
                    shutil.rmtree(pattern_path)
                    silent_print(f"Removed redundant directory: {pattern}")
                    removed_count += 1
            elif '*' in pattern:
                # Handle wildcard patterns - search recursively in subdirectories
                # Use list() to materialize the generator before iteration
                matching_files = list(directory.rglob(pattern))
                
                for file_path in matching_files:
                    if self.stop_requested:
                        break
                    
                    # Skip files in preserved directories (cache, etc.)
                    if any(preserve_dir in file_path.parts for preserve_dir in preserve_dirs):
                        continue
                    
                    # Skip important cache files (for fast startup)
                    if file_path.is_file() and file_path.name in preserve_cache_files:
                        continue
                    
                    try:
                        if file_path.is_file():
                            file_path.unlink()
                            removed_count += 1
                        elif file_path.is_dir():
                            # Don't remove preserved directories
                            if file_path.name not in preserve_dirs:
                                import shutil
                                shutil.rmtree(file_path)
                                removed_count += 1
                    except (OSError, PermissionError) as e:
                        # File might be in use or locked - skip it
                        silent_print(f"Could not remove {file_path}: {e}")
                        continue
            else:
                # Handle specific file names - search recursively in subdirectories
                matching_files = list(directory.rglob(pattern))
                
                for file_path in matching_files:
                    if self.stop_requested:
                        break
                    
                    # Skip files in preserved directories
                    if any(preserve_dir in file_path.parts for preserve_dir in preserve_dirs):
                        continue
                    
                    # Skip important cache files
                    if file_path.is_file() and file_path.name in preserve_cache_files:
                        continue
                    
                    try:
                        if file_path.is_file():
                            file_path.unlink()
                            removed_count += 1
                        elif file_path.is_dir():
                            if file_path.name not in preserve_dirs:
                                import shutil
                                shutil.rmtree(file_path)
                                removed_count += 1
                    except (OSError, PermissionError) as e:
                        # File might be in use or locked - skip it
                        silent_print(f"Could not remove {file_path}: {e}")
                        continue
            
            return removed_count
            
        except Exception as e:
            silent_print(f"Error in _remove_files_by_pattern for {pattern}: {e}")
            return removed_count


class URLDownloadWorker(QThread):
    """Worker thread for downloading files from URLs"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int)  # Emitted with download progress percentage
    completed = Signal(str, str)  # Emitted when done (file_path, file_type)
    
    def __init__(self, url, download_dir=None):
        super().__init__()
        self.url = url
        self.download_dir = download_dir or Path.cwd()
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Download file from URL in background thread"""
        try:
            import requests
            from urllib.parse import urlparse, unquote
            
            # Parse URL to get filename
            parsed_url = urlparse(self.url)
            url_path = unquote(parsed_url.path)
            
            # Try to get filename from URL or Content-Disposition header
            filename = None
            if url_path and '/' in url_path:
                filename = url_path.split('/')[-1]
            
            # If no filename in URL, try to get from Content-Disposition or use default
            if not filename or '.' not in filename:
                # Make HEAD request to get headers
                try:
                    head_response = requests.head(self.url, timeout=5, allow_redirects=True)
                    content_disposition = head_response.headers.get('Content-Disposition', '')
                    if 'filename=' in content_disposition:
                        filename = content_disposition.split('filename=')[1].strip('"\'')
                    elif not filename:
                        # Default based on URL
                        if 'themeid' in self.url or 'themes.rockbox.org' in self.url:
                            filename = 'theme.zip'
                        elif 'rom.zip' in self.url.lower() or 'update.zip' in self.url.lower():
                            filename = self.url.split('/')[-1].split('?')[0]
                        else:
                            filename = 'downloaded_file'
                except:
                    # If HEAD fails, use default
                    if not filename:
                        if 'themeid' in self.url or 'themes.rockbox.org' in self.url:
                            filename = 'theme.zip'
                        elif 'rom.zip' in self.url.lower() or 'update.zip' in self.url.lower():
                            filename = self.url.split('/')[-1].split('?')[0]
                        else:
                            filename = 'downloaded_file'
            
            # Ensure filename has extension if it's a known type
            if '.' not in filename:
                if 'themeid' in self.url or 'themes.rockbox.org' in self.url:
                    filename += '.zip'
            
            download_path = Path(self.download_dir) / filename
            
            self.status_update.emit(f"Downloading {filename}...")
            
            # Download file with progress
            response = requests.get(self.url, stream=True, timeout=30, allow_redirects=True)
            response.raise_for_status()
            
            total_size = int(response.headers.get('content-length', 0))
            downloaded = 0
            
            with open(download_path, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if self.stop_requested:
                        download_path.unlink(missing_ok=True)
                        self.completed.emit("", "cancelled")
                        return
                    
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            progress = int((downloaded / total_size) * 100)
                            self.progress_update.emit(progress)
                            if progress % 20 == 0:  # Update every 20%
                                self.status_update.emit(f"Downloading {filename}... {progress}%")
            
            self.status_update.emit(f"Downloaded {filename}")
            
            # Determine file type
            file_type = self._determine_file_type(download_path, self.url)
            
            self.completed.emit(str(download_path), file_type)
            
        except Exception as e:
            silent_print(f"Error downloading URL: {e}")
            import traceback
            traceback.print_exc()
            self.completed.emit("", "error")
    
    def _determine_file_type(self, file_path, url):
        """Determine file type from path and URL"""
        path_obj = Path(file_path)
        ext = path_obj.suffix.lower()
        url_lower = url.lower()
        
        # Check URL for hints
        if 'themeid' in url_lower or 'themes.rockbox.org' in url_lower:
            return 'theme_zip'
        elif 'rom.zip' in url_lower or 'rom' in url_lower and ext == '.zip':
            return 'rom_zip'
        elif 'update.zip' in url_lower or 'update' in url_lower and ext == '.zip':
            return 'update_zip'
        elif ext == '.zip':
            # Check if it's a theme zip by examining contents
            try:
                import zipfile
                with zipfile.ZipFile(file_path, 'r') as zf:
                    names = zf.namelist()
                    # Check for theme indicators
                    if any('config.json' in name.lower() and 'cover.png' in names for name in names):
                        return 'theme_zip'
                    elif any('.rockbox' in name.lower() for name in names):
                        return 'rockbox_zip'
            except:
                pass
            return 'zip'
        elif ext == '.apk':
            return 'apk'
        elif ext in ['.mp3', '.flac', '.wav', '.ogg', '.m4a', '.aac']:
            return 'audio'
        elif ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp']:
            return 'image'
        else:
            return 'file'


class APKInstallWorker(QThread):
    """Worker thread for installing APK files via ADB"""
    
    status_update = Signal(str)  # Emitted with status messages
    progress_update = Signal(int, int)  # Emitted with (current, total) progress
    completed = Signal(bool, str)  # Emitted when done (success, error_message)
    
    def __init__(self, adb_path, connected_device_id, env, apk_path, is_rooted=False):
        super().__init__()
        self.adb_path = adb_path
        self.connected_device_id = connected_device_id
        self.env = env
        self.apk_path = apk_path
        self.is_rooted = is_rooted
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Install APK in background thread"""
        try:
            apk_name = Path(self.apk_path).name
            self.status_update.emit(f"Installing {apk_name}...")
            
            # First, try regular install with replace flag
            adb_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                adb_cmd.extend(['-s', self.connected_device_id])
            adb_cmd.extend(['install', '-r', str(self.apk_path)])  # -r for replace existing
            
            # Execute install command
            install_process = subprocess.Popen(
                adb_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line
            output_lines = []
            while True:
                if self.stop_requested:
                    install_process.terminate()
                    self.completed.emit(False, "Installation cancelled by user")
                    return
                
                output = install_process.stdout.readline()
                if output == '' and install_process.poll() is not None:
                    break
                
                if output:
                    line = output.strip()
                    if line:
                        output_lines.append(line)
                        # Parse progress if available
                        if 'Performing' in line or 'Installing' in line or '%' in line:
                            self.status_update.emit(f"ADB: {line}")
            
            # Wait for process to complete
            return_code = install_process.wait()
            
            # Parse output to determine success/failure and reason
            full_output = '\n'.join(output_lines)
            
            if return_code == 0:
                # Check for success indicators
                if 'Success' in full_output or 'success' in full_output.lower():
                    self.completed.emit(True, f"Successfully installed {apk_name}")
                    return
                else:
                    # Sometimes ADB returns 0 but with error messages
                    if 'Failure' in full_output or 'Error' in full_output or 'INSTALL_FAILED' in full_output:
                        # Check if it's a signing mismatch or system APK issue
                        if 'INSTALL_FAILED_UPDATE_INCOMPATIBLE' in full_output or 'INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES' in full_output:
                            # Signing mismatch - try uninstall and reinstall if rooted
                            if self.is_rooted:
                                error_msg = self._handle_signing_mismatch(full_output, apk_name)
                                if error_msg:
                                    self.completed.emit(False, error_msg)
                                    return
                            else:
                                error_msg = self._parse_install_error(full_output)
                                self.completed.emit(False, error_msg)
                                return
                        else:
                            error_msg = self._parse_install_error(full_output)
                            self.completed.emit(False, error_msg)
                            return
                    else:
                        # Assume success if return code is 0
                        self.completed.emit(True, f"Successfully installed {apk_name}")
                        return
            else:
                # Installation failed - check if it's a system APK or signing issue
                if 'INSTALL_FAILED_UPDATE_INCOMPATIBLE' in full_output or 'INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES' in full_output:
                    # Signing mismatch - try uninstall and reinstall if rooted
                    if self.is_rooted:
                        error_msg = self._handle_signing_mismatch(full_output, apk_name)
                        if error_msg:
                            self.completed.emit(False, error_msg)
                            return
                    else:
                        error_msg = self._parse_install_error(full_output)
                        self.completed.emit(False, error_msg)
                        return
                elif 'INSTALL_FAILED_INVALID_APK' in full_output and self.is_rooted:
                    # Might be a system APK - try with system flag
                    error_msg = self._handle_system_apk(full_output, apk_name)
                    if error_msg:
                        self.completed.emit(False, error_msg)
                        return
                else:
                    # Regular error - parse it
                    error_msg = self._parse_install_error(full_output)
                    self.completed.emit(False, error_msg)
                    return
                
        except Exception as e:
            silent_print(f"Error installing APK: {e}")
            import traceback
            traceback.print_exc()
            self.completed.emit(False, f"Error installing APK: {str(e)}")
    
    def _handle_signing_mismatch(self, output, apk_name):
        """Handle signing mismatch by uninstalling and reinstalling (rooted devices only)"""
        try:
            # Extract package name from APK
            self.status_update.emit("Signing mismatch detected - attempting to resolve...")
            
            # Get package name from APK using aapt or adb
            package_name = self._get_package_name()
            if not package_name:
                return self._parse_install_error(output)
            
            # Uninstall the existing app
            self.status_update.emit(f"Uninstalling existing app ({package_name})...")
            uninstall_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                uninstall_cmd.extend(['-s', self.connected_device_id])
            uninstall_cmd.extend(['uninstall', package_name])
            
            uninstall_result = subprocess.run(
                uninstall_cmd,
                capture_output=True,
                text=True,
                timeout=10,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Try install again
            self.status_update.emit("Reinstalling with new signature...")
            install_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                install_cmd.extend(['-s', self.connected_device_id])
            install_cmd.extend(['install', '-r', str(self.apk_path)])
            
            install_result = subprocess.run(
                install_cmd,
                capture_output=True,
                text=True,
                timeout=30,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if install_result.returncode == 0 and ('Success' in install_result.stdout or 'success' in install_result.stdout.lower()):
                self.completed.emit(True, f"Successfully installed {apk_name} (replaced existing app)")
                return None
            else:
                return f"Failed to reinstall {apk_name} after uninstall:\n\n{install_result.stdout}\n{install_result.stderr}"
                
        except Exception as e:
            return f"Error handling signing mismatch: {str(e)}"
    
    def _handle_system_apk(self, output, apk_name):
        """Handle system APK installation on rooted devices"""
        try:
            self.status_update.emit("System APK detected - attempting installation with root...")
            
            # Get package name
            package_name = self._get_package_name()
            if not package_name:
                return self._parse_install_error(output)
            
            # Try to uninstall system app first (requires root)
            self.status_update.emit(f"Removing system app ({package_name})...")
            uninstall_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                uninstall_cmd.extend(['-s', self.connected_device_id])
            uninstall_cmd.extend(['shell', 'su', '-c', f'pm uninstall {package_name}'])
            
            uninstall_result = subprocess.run(
                uninstall_cmd,
                capture_output=True,
                text=True,
                timeout=10,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Install as regular app
            self.status_update.emit("Installing as regular app...")
            install_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                install_cmd.extend(['-s', self.connected_device_id])
            install_cmd.extend(['install', '-r', str(self.apk_path)])
            
            install_result = subprocess.run(
                install_cmd,
                capture_output=True,
                text=True,
                timeout=30,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if install_result.returncode == 0 and ('Success' in install_result.stdout or 'success' in install_result.stdout.lower()):
                self.completed.emit(True, f"Successfully installed {apk_name} (replaced system app)")
                return None
            else:
                return f"Failed to install system APK {apk_name}:\n\n{install_result.stdout}\n{install_result.stderr}"
                
        except Exception as e:
            return f"Error handling system APK: {str(e)}"
    
    def _get_package_name(self):
        """Extract package name from APK using aapt or adb"""
        try:
            # Try using aapt first (if available)
            import shutil
            aapt_path = shutil.which('aapt')
            if aapt_path:
                aapt_cmd = [aapt_path, 'dump', 'badging', str(self.apk_path)]
                result = subprocess.run(
                    aapt_cmd,
                    capture_output=True,
                    text=True,
                    timeout=5,
                    env=self.env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                if result.returncode == 0:
                    for line in result.stdout.split('\n'):
                        if line.startswith('package: name='):
                            package_name = line.split("'")[1]
                            return package_name
            
            # Fallback: try to install and extract package name from error
            # This is a workaround if aapt is not available
            return None
            
        except Exception as e:
            silent_print(f"Error getting package name: {e}")
            return None
    
    def _parse_install_error(self, output):
        """Parse ADB install output to extract meaningful error messages"""
        apk_name = Path(self.apk_path).name
        
        # Common ADB install error patterns
        error_patterns = {
            'INSTALL_FAILED_ALREADY_EXISTS': 'This app is already installed. Use "adb install -r" to replace it.',
            'INSTALL_FAILED_INVALID_APK': 'The APK file is invalid or corrupted.',
            'INSTALL_FAILED_INSUFFICIENT_STORAGE': 'Not enough storage space on the device.',
            'INSTALL_FAILED_DUPLICATE_PACKAGE': 'An app with the same package name is already installed.',
            'INSTALL_FAILED_NO_MATCHING_ABIS': 'The APK is not compatible with your device\'s architecture.',
            'INSTALL_FAILED_OLDER_SDK': 'The APK requires a newer Android version than your device has.',
            'INSTALL_FAILED_VERSION_DOWNGRADE': 'You\'re trying to install an older version than what\'s currently installed.',
            'INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE': 'Cannot downgrade app due to permission model changes.',
            'INSTALL_FAILED_UPDATE_INCOMPATIBLE': 'The new version is incompatible with the existing installation. On rooted devices, the app will be uninstalled and reinstalled.',
            'INSTALL_FAILED_SHARED_USER_INCOMPATIBLE': 'Shared user ID conflict with existing app.',
            'INSTALL_FAILED_MISSING_SHARED_LIBRARY': 'Required shared library is missing on the device.',
            'INSTALL_FAILED_REPLACE_COULDNT_DELETE': 'Could not delete existing app to replace it.',
            'INSTALL_FAILED_DEXOPT': 'DEX optimization failed.',
            'INSTALL_FAILED_UID_CHANGED': 'App UID changed, cannot update.',
            'INSTALL_FAILED_TEST_ONLY': 'This is a test-only APK and cannot be installed on production devices.',
            'INSTALL_FAILED_CPU_ABI_INCOMPATIBLE': 'APK is not compatible with device CPU architecture.',
            'INSTALL_PARSE_FAILED_NOT_APK': 'File is not a valid APK.',
            'INSTALL_PARSE_FAILED_BAD_MANIFEST': 'APK manifest is malformed.',
            'INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION': 'Unexpected error parsing APK.',
            'INSTALL_PARSE_FAILED_NO_CERTIFICATES': 'APK is not signed.',
            'INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES': 'APK signature is inconsistent with existing app. On rooted devices, the app will be uninstalled and reinstalled.',
            'INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING': 'Certificate encoding error.',
            'INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME': 'Invalid package name in APK.',
            'INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID': 'Invalid shared user ID.',
            'INSTALL_PARSE_FAILED_MANIFEST_MALFORMED': 'Manifest file is malformed.',
            'INSTALL_PARSE_FAILED_MANIFEST_EMPTY': 'Manifest file is empty.',
            'INSTALL_FAILED_INTERNAL_ERROR': 'Internal error during installation.',
            'INSTALL_FAILED_USER_RESTRICTED': 'Installation restricted by user settings.',
            'INSTALL_FAILED_MISSING_FEATURE': 'Device is missing a required feature.',
            'INSTALL_FAILED_CONTAINER_ERROR': 'Secure container error.',
            'INSTALL_FAILED_INVALID_INSTALL_LOCATION': 'Invalid installation location.',
            'INSTALL_FAILED_MEDIA_UNAVAILABLE': 'Storage media is unavailable.',
            'INSTALL_FAILED_VERIFICATION_TIMEOUT': 'Verification timed out.',
            'INSTALL_FAILED_VERIFICATION_FAILURE': 'Verification failed.',
            'INSTALL_FAILED_PACKAGE_CHANGED': 'Package changed during installation.',
            'INSTALL_FAILED_UID_CHANGED': 'UID changed during installation.',
            'INSTALL_FAILED_VERSION_DOWNGRADE': 'Version downgrade not allowed.',
            'INSTALL_FAILED_PERMISSION_DENIED': 'Permission denied.',
        }
        
        lowered_output = output.lower()
        if 'install_failed_update_incompatible' in lowered_output and not self.is_rooted:
            return (
                f"Failed to install {apk_name}: This replacement requires root access to remove the existing app.\n\n"
                "Prepare your device for Fast Updates so the helper files can enable root-driven replacements."
            )
        if 'install_failed_replace_couldnt_delete' in lowered_output and not self.is_rooted:
            return (
                f"Failed to install {apk_name}: The existing app could not be removed without root access.\n\n"
                "Prepare your device for Fast Updates or connect over USB and rerun the preparation."
            )
        
        # Check for specific error codes
        for error_code, message in error_patterns.items():
            if error_code in output:
                return f"Failed to install {apk_name}:\n\n{message}"
        
        # Check for generic error patterns
        if 'Failure' in output or 'Error' in output:
            # Try to extract the error message
            lines = output.split('\n')
            error_lines = [line for line in lines if 'Failure' in line or 'Error' in line or 'INSTALL' in line]
            if error_lines:
                error_msg = '\n'.join(error_lines[:3])  # Show first 3 error lines
                return f"Failed to install {apk_name}:\n\n{error_msg}"
        
        # Fallback to generic error
        return f"Failed to install {apk_name}.\n\nADB output:\n{output[:500]}"


class ADBCheckWorker(QThread):
    """Worker thread for periodic ADB connection checks"""
    
    status_update = Signal(str)  # Emitted with status messages (for debugging)
    check_complete = Signal(str, object, object, dict)  # Emitted when check is complete (status, device_id, hostname, details)
    
    def __init__(self, adb_path, env, status_broker):
        super().__init__()
        self.adb_path = adb_path
        self.env = env
        self.status_broker = status_broker
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Perform ADB check in background thread"""
        try:
            if self.stop_requested:
                return
            
            if hasattr(self.status_broker, 'compute_snapshot'):
                status, device_id, hostname, details = self.status_broker.compute_snapshot(self.adb_path, self.env)
                self.check_complete.emit(status, device_id, hostname, details or {})
            else:
                self.check_complete.emit('no_adb', None, None, {})
        except Exception as e:
            silent_print(f"Error in ADBCheckWorker: {e}")
            self.check_complete.emit('no_adb', None, None, {})


class ADBFastUpdateCheckWorker(QThread):
    """Worker thread for checking ADB fast update availability (prevents GUI hangs)"""
    
    check_complete = Signal(bool, object, dict, bool)  # success, selected_device, env, usb_storage_available
    
    def __init__(self, adb_path, env, update_zip_url):
        super().__init__()
        self.adb_path = adb_path
        self.env = env
        self.update_zip_url = update_zip_url
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Check ADB fast update availability in background thread"""
        try:
            if self.stop_requested:
                self.check_complete.emit(False, None, {}, False)
                return
            
            # Check if device is connected via ADB
            result = subprocess.run(
                [str(self.adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Parse device list and prefer USB device (0123456789ABCDEF) when both USB and Wi-Fi are available
            target_device_id = "0123456789ABCDEF"
            devices = []
            usb_device = None
            wireless_device = None
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
                    # Prefer USB device when both are available
                    if device_id == target_device_id:
                        usb_device = device_id
                    elif ':' in device_id and wireless_device is None:
                        wireless_device = device_id
            
            if not devices:
                silent_print("No ADB devices connected - fast update check failed")
                self.check_complete.emit(False, None, {}, False)
                return
            
            # Select device: prefer USB when both are available, otherwise use any available device
            selected_device = usb_device if usb_device else (wireless_device if wireless_device else devices[0])
            silent_print(f"Found {len(devices)} ADB device(s): {devices}, using: {selected_device}")
            
            # Check USB storage mode status (doesn't block ADB, but indicates USB storage is also available)
            usb_storage_available = False
            try:
                usb_config_result = subprocess.run(
                    [str(self.adb_path), '-s', selected_device, 'shell', 'getprop', 'sys.usb.config'],
                    capture_output=True,
                    text=True,
                    timeout=5,
                    env=self.env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                if usb_config_result.returncode == 0:
                    usb_config = usb_config_result.stdout.strip().lower()
                    if 'mass_storage' in usb_config:
                        usb_storage_available = True
                        silent_print(f"USB Storage Mode also available (sys.usb.config={usb_config}) - ADB still works")
            except Exception as e:
                silent_print(f"Could not check USB config: {e}")
            
            if self.stop_requested:
                self.check_complete.emit(False, None, {}, False)
                return
            
            # Check if device is rooted (using selected device)
            silent_print(f"Checking if device is rooted (device: {selected_device})...")
            root_check_result = subprocess.run(
                [str(self.adb_path), '-s', selected_device, 'shell', 'su', '-c', 'id'],
                capture_output=True,
                text=True,
                timeout=5,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            device_is_rooted = (root_check_result.returncode == 0 and 'uid=0' in root_check_result.stdout)
            
            if not device_is_rooted:
                silent_print("Device is not rooted - fast update requires a firmware with Fast Update enabled")
                self.check_complete.emit(False, None, {}, False)
                return
            
            if self.stop_requested:
                self.check_complete.emit(False, None, {}, False)
                return
            
            # Check if /data/data/update/update.sh exists on device (using selected device)
            update_script_path = '/data/data/update/update.sh'
            silent_print(f"Checking for {update_script_path} on device (device: {selected_device})...")
            check_result = subprocess.run(
                [str(self.adb_path), '-s', selected_device, 'shell', f'test -f {update_script_path} && echo exists'],
                capture_output=True,
                text=True,
                timeout=5,
                env=self.env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            silent_print(f"ADB check result stdout: '{check_result.stdout}'")
            silent_print(f"ADB check result stderr: '{check_result.stderr}'")
            
            update_script_exists = 'exists' in check_result.stdout
            
            # Also check for .fastupdate marker in /storage/sdcard0/ via ADB (regardless of USB storage mode)
            # This allows checking the marker date even when USB storage mode is enabled
            fastupdate_marker_exists = False
            if not update_script_exists:
                silent_print(f"update.sh not found - checking for {FASTUPDATE_MARKER_PATH} marker...")
                marker_check = subprocess.run(
                    [str(self.adb_path), '-s', selected_device, 'shell', f'test -f {FASTUPDATE_MARKER_PATH} && echo exists'],
                    capture_output=True,
                    text=True,
                    timeout=5,
                    env=self.env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                if 'exists' in marker_check.stdout:
                    silent_print(f"Found {FASTUPDATE_MARKER_PATH} - fast update available")
                    fastupdate_marker_exists = True
                    update_script_exists = True
                else:
                    # Place .fastupdate marker in /storage/sdcard0/ for future checks
                    silent_print(f"Placing {FASTUPDATE_MARKER_PATH} marker for fast update detection...")
                    marker_place = subprocess.run(
                        [str(self.adb_path), '-s', selected_device, 'shell', f'touch {FASTUPDATE_MARKER_PATH}'],
                        capture_output=True,
                        text=True,
                        timeout=5,
                        env=self.env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
            
            if not update_script_exists:
                silent_print(f"{update_script_path} not found on device - fast update check failed")
                self.check_complete.emit(False, None, {}, False)
                return
            
            silent_print(f"Found fast update capability on device - ADB fast update available")
            # Pass usb_storage_available (not blocking) - ADB works regardless
            self.check_complete.emit(True, selected_device, self.env, usb_storage_available)
            
        except subprocess.TimeoutExpired:
            silent_print("ADB command timed out - fast update check failed")
            self.check_complete.emit(False, None, {}, False)
        except Exception as e:
            silent_print(f"ADB fast update check failed: {e}")
            self.check_complete.emit(False, None, {}, False)


class ADBStatusBroker(QObject):
    """Central broker coordinating ADB status detection, caching, and signaling."""
    
    snapshot_changed = Signal(dict)         # Emitted whenever a new snapshot is applied
    refresh_started = Signal(str)           # Emitted when a refresh begins (reason string)
    refresh_finished = Signal(dict)         # Emitted when a refresh completes with latest snapshot
    refresh_failed = Signal(str)            # Emitted when a refresh fails (error message)
    
    def __init__(self, gui):
        super().__init__(gui)
        self.gui = gui
        self._state_lock = threading.Lock()
        self._state = {
            'status': 'no_adb',
            'device_id': None,
            'hostname': None,
            'is_wireless': False,
            'rooted': False,
            'update_script_exists': False,
            'fastupdate_marker_exists': False,
            'fastupdate_marker_present': False,
            'fastupdate_marker_is_today': False,
            'fastupdate_marker_needs_refresh': False,
            'fastupdate_marker_date': None,
            'fast_update_ready': False,
            'all_devices': [],
            'usb_device_id': None,
            'wireless_device_id': None,
            'active_device_id': None,
            'last_checked': None,
        }
        self._pending_callbacks = deque()
        self._refresh_in_progress = False
        self._pending_refresh = False
        self._pending_reason = ""
        self._worker = None
        self._last_wireless_connect_attempt = 0.0
        self._auto_reconnect_until = 0.0
    
    # ------------------------------------------------------------------
    # Snapshot helpers
    # ------------------------------------------------------------------
    def _clone_state(self):
        with self._state_lock:
            return dict(self._state)
    
    def get_snapshot(self):
        """Return the latest cached snapshot."""
        return self._clone_state()
    
    def update_snapshot(self, **kwargs):
        """External helper to merge values into the cached snapshot."""
        return self._update_snapshot(**kwargs)
    
    def _update_snapshot(self, **kwargs):
        """Merge new values into the cached snapshot and emit change notifications."""
        with self._state_lock:
            self._state.update(kwargs)
            snapshot = dict(self._state)
        self.snapshot_changed.emit(dict(snapshot))
        return snapshot
    
    def requirement_met(self, requirement, snapshot=None):
        """
        Evaluate whether the specified requirement is met by the snapshot.
        requirement in {'connected','root','fast_update_ready'}
        """
        snapshot = snapshot or self.get_snapshot()
        status = snapshot.get('status', 'no_adb')
        if requirement == 'connected':
            return status in ('adb_only', 'adb_root')
        if requirement == 'root':
            return status == 'adb_root' and snapshot.get('rooted', False)
        if requirement == 'fast_update_ready':
            return snapshot.get('fast_update_ready', False)
        return False
    
    # ------------------------------------------------------------------
    # Refresh coordination
    # ------------------------------------------------------------------
    def request_refresh(self, force=False, reason=None, callback=None):
        """
        Request a background refresh. Optional callback receives latest snapshot.
        """
        if callback:
            with self._state_lock:
                self._pending_callbacks.append(callback)
        
        if reason:
            silent_print(f"ADBStatusBroker: refresh requested (reason={reason}, force={force})")
        
        # Skip refresh if an ADB operation is running unless forced
        if getattr(self.gui, 'adb_operation_in_progress', False) and not force:
            silent_print("ADBStatusBroker: Skipping refresh - operation in progress")
            return self.get_snapshot()
        
        with self._state_lock:
            if self._refresh_in_progress:
                if force:
                    self._pending_refresh = True
                if reason:
                    self._pending_reason = reason
                return dict(self._state)
            self._refresh_in_progress = True
        
        refresh_reason = reason or ""
        self.refresh_started.emit(refresh_reason)
        
        adb_path = self.gui.find_adb_executable()
        if not adb_path:
            snapshot = self._update_snapshot(
                status='no_adb',
                device_id=None,
                hostname=None,
                is_wireless=False,
                rooted=False,
                update_script_exists=False,
                fastupdate_marker_exists=False,
                fastupdate_marker_present=False,
                fastupdate_marker_is_today=False,
                fastupdate_marker_needs_refresh=False,
                fastupdate_marker_date=None,
                fast_update_ready=False,
                last_checked=datetime.now(),
            )
            self.refresh_finished.emit(dict(snapshot))
            self._flush_callbacks(snapshot)
            with self._state_lock:
                self._refresh_in_progress = False
            return snapshot
        
        env = self.gui._build_adb_environment()
        self._worker = ADBCheckWorker(adb_path, env, self)
        self._worker.check_complete.connect(self._handle_worker_complete)
        self._worker.finished.connect(self._handle_worker_finished)
        self._worker.start()
        return self.get_snapshot()
    
    def _handle_worker_complete(self, status, device_id, hostname, details):
        """Apply worker results to the snapshot and notify listeners."""
        details = details or {}
        snapshot_payload = {
            'status': status,
            'device_id': device_id,
            'hostname': hostname,
            'last_checked': datetime.now(),
        }
        snapshot_payload.update(details)
        snapshot = self._update_snapshot(**snapshot_payload)
        self.refresh_finished.emit(dict(snapshot))
        self._flush_callbacks(snapshot)
    
    def _handle_worker_finished(self):
        """Reset state after worker completion and process pending refresh if needed."""
        with self._state_lock:
            self._refresh_in_progress = False
            pending = self._pending_refresh
            pending_reason = self._pending_reason
            self._pending_refresh = False
            self._pending_reason = ""
            self._worker = None
        if pending:
            QTimer.singleShot(150, lambda: self.request_refresh(force=True, reason=pending_reason or "queued"))
    
    def _flush_callbacks(self, snapshot=None):
        """Invoke pending callbacks with the latest snapshot."""
        snapshot = snapshot or self.get_snapshot()
        callbacks = []
        with self._state_lock:
            while self._pending_callbacks:
                callbacks.append(self._pending_callbacks.popleft())
        for callback in callbacks:
            try:
                QTimer.singleShot(0, lambda cb=callback, snap=dict(snapshot): cb(snap))
            except Exception as callback_error:
                silent_print(f"ADBStatusBroker callback error: {callback_error}")
    
    def flush_callbacks(self, snapshot=None):
        """Public wrapper to flush pending callbacks."""
        self._flush_callbacks(snapshot)
    
    def suppress_auto_reconnect(self, seconds=5.0):
        """Temporarily disable automatic Wi-Fi reconnect attempts."""
        horizon = time.time() + max(0.0, seconds)
        with self._state_lock:
            self._auto_reconnect_until = max(self._auto_reconnect_until, horizon)
        silent_print(f"ADBStatusBroker: auto-reconnect suppressed until {datetime.fromtimestamp(self._auto_reconnect_until).isoformat()}")
    
    # ------------------------------------------------------------------
    # Status computation
    # ------------------------------------------------------------------
    def compute_snapshot(self, adb_path=None, env=None):
        """
        Compute the current ADB status synchronously. Intended for worker threads.
        Returns (status, device_id, hostname, details_dict).
        """
        details = {}
        try:
            if not adb_path:
                adb_path = self.gui.find_adb_executable()
                if not adb_path:
                    details.update({
                        'status': 'no_adb',
                        'device_id': None,
                        'hostname': None,
                        'is_wireless': False,
                        'rooted': False,
                        'update_script_exists': False,
                        'fastupdate_marker_exists': False,
                        'fastupdate_marker_present': False,
                        'fastupdate_marker_is_today': False,
                        'fastupdate_marker_needs_refresh': False,
                        'fastupdate_marker_date': None,
                        'fast_update_ready': False,
                        'all_devices': [],
                        'usb_device_id': None,
                        'wireless_device_id': None,
                        'active_device_id': None,
                    })
                    return ('no_adb', None, None, details)
            
            if env is None:
                env = self.gui._build_adb_environment()
            
            def _list_devices():
                try:
                    result = subprocess.run(
                        [str(adb_path), 'devices'],
                        capture_output=True,
                        text=True,
                        timeout=5,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                except Exception as device_error:
                    silent_print(f"ADBStatusBroker: failed to list devices: {device_error}")
                    return [], None, None
                
                usb_id = None
                wifi_id = None
                target_device_id = "0123456789ABCDEF"
                devices = []
                
                for line in result.stdout.split('\n'):
                    if '\tdevice' not in line:
                        continue
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
                    if device_id == target_device_id:
                        usb_id = device_id
                    elif ':' in device_id:
                        if self._is_y1_device_id(adb_path, device_id, env):
                            wifi_id = device_id
                return devices, usb_id, wifi_id
            
            all_devices, usb_device_id, wireless_device_id = _list_devices()
            details.update({
                'all_devices': list(all_devices),
                'usb_device_id': usb_device_id,
                'wireless_device_id': wireless_device_id,
            })
            
            connection_target = (
                self.gui.load_wireless_adb_hostname() or self.gui.load_wireless_adb_ip()
            )
            details['wireless_saved_target'] = connection_target
            now = time.time()
            should_attempt_wifi = connection_target and not wireless_device_id
            if should_attempt_wifi:
                allow_reconnect = False
                with self._state_lock:
                    allow_reconnect = now >= self._auto_reconnect_until
                    last_attempt = self._last_wireless_connect_attempt
                if allow_reconnect and (now - last_attempt) > 5:
                    with self._state_lock:
                        self._last_wireless_connect_attempt = now
                    connect_target = (
                        connection_target if ':' in connection_target else f"{connection_target}:5555"
                    )
                    try:
                        silent_print(f"ADBStatusBroker: attempting wireless reconnect to {connect_target}")
                        subprocess.run(
                            [str(adb_path), 'connect', connect_target],
                            capture_output=True,
                            text=True,
                            timeout=4,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                        all_devices, usb_device_id, wireless_device_id = _list_devices()
                        details['all_devices'] = list(all_devices)
                        details['usb_device_id'] = usb_device_id
                        details['wireless_device_id'] = wireless_device_id
                    except Exception as reconnect_error:
                        silent_print(f"ADBStatusBroker: wireless reconnect failed: {reconnect_error}")
            
            connected_device_id = None
            is_wireless = False
            
            def _check_root(target_id):
                if not target_id:
                    return False
                try:
                    root_check = subprocess.run(
                        [str(adb_path), '-s', target_id, 'shell', 'su', '-c', 'id'],
                        capture_output=True,
                        text=True,
                        timeout=3,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                    return root_check.returncode == 0 and 'uid=0' in root_check.stdout
                except Exception as error:
                    silent_print(f"ADBStatusBroker: root check failed for {target_id}: {error}")
                    return False
            
            usb_is_rooted = _check_root(usb_device_id) if usb_device_id else False
            wifi_is_rooted = _check_root(wireless_device_id) if wireless_device_id else False
            
            if usb_device_id:
                    connected_device_id = usb_device_id
                    is_wireless = False
                    self.gui.prefer_usb_for_transfers = True
            elif wireless_device_id:
                connected_device_id = wireless_device_id
                is_wireless = True
            
            details['dual_connected'] = bool(usb_device_id and wireless_device_id)
            details['secondary_device_id'] = wireless_device_id if usb_device_id else None
            details['usb_rooted'] = usb_is_rooted
            details['wireless_rooted'] = wifi_is_rooted
            
            if not connected_device_id:
                details.update({
                    'status': 'no_adb',
                    'device_id': None,
                    'hostname': None,
                    'is_wireless': False,
                    'rooted': False,
                    'update_script_exists': False,
                    'fastupdate_marker_exists': False,
                    'fastupdate_marker_present': False,
                    'fastupdate_marker_is_today': False,
                    'fastupdate_marker_needs_refresh': False,
                    'fastupdate_marker_date': None,
                    'fast_update_ready': False,
                    'active_device_id': None,
                })
                return ('no_adb', None, None, details)
            
            if connected_device_id == usb_device_id:
                device_is_rooted = usb_is_rooted
            elif connected_device_id == wireless_device_id:
                device_is_rooted = wifi_is_rooted
            else:
                device_is_rooted = _check_root(connected_device_id)
            
            device_hostname = self.gui.get_device_hostname(adb_path, connected_device_id, env)
            details.update({
                'active_device_id': connected_device_id,
                'is_wireless': is_wireless,
                'rooted': device_is_rooted,
                'device_hostname': device_hostname,
            })
            details['paired_wireless'] = bool(wireless_device_id or connection_target)
            
            if not device_is_rooted:
                details.update({
                    'status': 'adb_only',
                    'device_id': connected_device_id,
                    'hostname': device_hostname,
                    'update_script_exists': False,
                    'fastupdate_marker_exists': False,
                    'fastupdate_marker_present': False,
                    'fastupdate_marker_is_today': False,
                    'fastupdate_marker_needs_refresh': False,
                    'fastupdate_marker_date': None,
                    'fast_update_ready': False,
                })
                return ('adb_only', connected_device_id, device_hostname, details)
            
            update_script_exists = self.gui._check_update_script_exists(adb_path, connected_device_id, env)
            marker_present, marker_value = self.gui._read_fastupdate_marker(adb_path, connected_device_id, env)
            marker_date = None
            marker_is_today = False
            if marker_present:
                raw_value = (marker_value or "").strip()
                if raw_value:
                    try:
                        marker_dt = datetime.strptime(raw_value, "%Y-%m-%d")
                        marker_date = marker_dt.strftime("%Y-%m-%d")
                        marker_is_today = (marker_dt.date() == datetime.now().date())
                    except ValueError:
                        silent_print(f"ADBStatusBroker: fastupdate marker has invalid value '{raw_value}'")
                else:
                    marker_present = False
            marker_needs_refresh = bool(not marker_is_today)
            fast_update_ready = bool(update_script_exists and marker_is_today)
            
            details.update({
                'status': 'adb_root',
                'device_id': connected_device_id,
                'hostname': device_hostname,
                'update_script_exists': update_script_exists,
                'fastupdate_marker_exists': marker_present,
                'fastupdate_marker_present': marker_present,
                'fastupdate_marker_is_today': marker_is_today,
                'fastupdate_marker_needs_refresh': marker_needs_refresh,
                'fastupdate_marker_date': marker_date,
                'fast_update_ready': fast_update_ready,
            })
            
            return ('adb_root', connected_device_id, device_hostname, details)
        
        except Exception as e:
            silent_print(f"ADBStatusBroker: error computing snapshot: {e}")
            details.update({
                'status': 'no_adb',
                'device_id': None,
                'hostname': None,
                'is_wireless': False,
                'rooted': False,
                'update_script_exists': False,
                'fastupdate_marker_exists': False,
                'fastupdate_marker_present': False,
                'fastupdate_marker_is_today': False,
                'fastupdate_marker_needs_refresh': False,
                'fastupdate_marker_date': None,
                'fast_update_ready': False,
            })
            return ('no_adb', None, None, details)
    
    # ------------------------------------------------------------------
    # Utilities
    # ------------------------------------------------------------------
    def _is_y1_device_id(self, adb_path, device_id, env):
        """Heuristic to confirm a wireless ADB entry belongs to a Y1 device."""
        try:
            host_part = device_id.split(':')[0]
            if host_part.startswith('android-'):
                return True
            if '.' in host_part:
                parts = host_part.split('.')
                if len(parts) == 4 and all(part.isdigit() for part in parts):
                    return True
            # Quick check using getprop to ensure device responds
            result = subprocess.run(
                [str(adb_path), '-s', device_id, 'shell', 'getprop', 'ro.product.vendor.name'],
                capture_output=True,
                text=True,
                timeout=2,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            return result.returncode == 0 and 'innioasis' in result.stdout.lower()
        except Exception:
            return False

class ADBUpdateScriptWorker(QThread):
    """Worker thread for downloading and pushing update.sh script via ADB"""
    
    download_progress = Signal(int)  # Emitted with download progress percentage
    status_update = Signal(str)  # Emitted with status messages
    completed = Signal(bool, str)  # Emitted when done (success, message)
    
    def __init__(self, adb_path, update_script_url, local_cache_path, connected_device_id=None):
        super().__init__()
        self.adb_path = adb_path
        self.update_script_url = update_script_url
        self.local_cache_path = local_cache_path
        self.connected_device_id = connected_device_id
        self.stop_requested = False
    
    def stop(self):
        """Request to stop operation"""
        self.stop_requested = True
    
    def run(self):
        """Download and push update.sh script"""
        try:
            if self.stop_requested:
                return
            
            # Step 1: Download update.sh script
            self.status_update.emit("Downloading update script...")
            
            # Try to download from GitHub
            try:
                import requests
                response = requests.get(self.update_script_url, timeout=10, stream=True)
                response.raise_for_status()
                
                total_size = int(response.headers.get('content-length', 0))
                downloaded = 0
                
                with open(self.local_cache_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if self.stop_requested:
                            return
                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)
                            if total_size > 0:
                                progress = int((downloaded / total_size) * 100)
                                self.download_progress.emit(progress)
                
                self.status_update.emit("Downloaded update script")
                
            except Exception as e:
                # If download fails, try to use local cached copy
                silent_print(f"Failed to download update script: {e}, trying local cache...")
                self.status_update.emit("Using cached update script...")
                
                if not self.local_cache_path.exists():
                    self.completed.emit(False, f"Failed to download and no local cache found: {e}")
                    return
            
            if self.stop_requested:
                return
            
            # Step 2: Push script to device
            self.status_update.emit("Pushing update script to device...")
            self.download_progress.emit(50)  # Show 50% progress during push
            
            # Prepare environment with proper PATH for macOS
            import os
            import platform
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Create /data/data/update directory if needed
            mkdir_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                mkdir_cmd.extend(['-s', self.connected_device_id])
            mkdir_cmd.extend(['shell', 'mkdir', '-p', '/data/data/update'])
            
            subprocess.run(
                mkdir_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Push the script
            push_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                push_cmd.extend(['-s', self.connected_device_id])
            push_cmd.extend(['push', str(self.local_cache_path), '/data/data/update/update.sh'])
            
            push_result = subprocess.run(
                push_cmd,
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if push_result.returncode != 0:
                self.completed.emit(False, f"Failed to push update script: {push_result.stderr}")
                return
            
            # Set permissions
            self.status_update.emit("Making script executable...")
            self.download_progress.emit(75)  # Show 75% progress during chmod
            
            chmod_cmd = [str(self.adb_path)]
            if self.connected_device_id:
                chmod_cmd.extend(['-s', self.connected_device_id])
            chmod_cmd.extend(['shell', 'chmod', '755', '/data/data/update/update.sh'])
            
            chmod_result = subprocess.run(
                chmod_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if self.stop_requested:
                return
            
            self.download_progress.emit(100)  # Show 100% progress when complete
            self.status_update.emit("Update script installed successfully")
            self.completed.emit(True, "Update script installed successfully")
            
        except Exception as e:
            if not self.stop_requested:
                silent_print(f"Error in ADB update script worker: {e}")
                self.completed.emit(False, f"Error: {str(e)}")


class ThemeMonitor(QObject):
    """Monitors system theme changes and emits signals for UI updates"""
    theme_changed = Signal()
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.running = False
        self.thread = None
        self.last_theme = None
        
    def start_monitoring(self):
        """Start the theme monitoring thread"""
        if self.running:
            return
            
        self.running = True
        self.thread = threading.Thread(target=self._monitor_theme, daemon=True)
        self.thread.start()
        
    def stop_monitoring(self):
        """Stop the theme monitoring thread"""
        self.running = False
        if self.thread:
            self.thread.join(timeout=1.0)
            
    def _monitor_theme(self):
        """Background thread that monitors system theme changes"""
        while self.running:
            try:
                current_theme = self._get_current_theme()
                if current_theme != self.last_theme:
                    self.last_theme = current_theme
                    self.theme_changed.emit()
                time.sleep(1.0)  # Check every second
            except Exception as e:
                # Silently handle errors to prevent thread crashes
                time.sleep(2.0)
                
    def _get_current_theme(self):
        """Get the current system theme (light/dark)"""
        try:
            if platform.system() == "Darwin":  # macOS
                return self._get_macos_theme()
            elif platform.system() == "Windows":  # Windows
                return self._get_windows_theme()
            else:  # Linux and others
                return self._get_linux_theme()
        except:
            return "unknown"
            
    def _get_macos_theme(self):
        """Get macOS theme using system preferences"""
        try:
            import subprocess
            result = subprocess.run(['defaults', 'read', '-g', 'AppleInterfaceStyle'], 
                                  capture_output=True, text=True, timeout=2)
            return "dark" if result.returncode == 0 and result.stdout.strip() else "light"
        except:
            return "light"
            
    def _get_windows_theme(self):
        """Get Windows theme using registry"""
        try:
            import winreg
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                              r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize") as key:
                value, _ = winreg.QueryValueEx(key, "AppsUseLightTheme")
                return "light" if value else "dark"
        except:
            return "light"
            
    def _get_linux_theme(self):
        """Get Linux theme using environment variables"""
        try:
            # Check common environment variables
            gtk_theme = os.environ.get('GTK_THEME', '').lower()
            if 'dark' in gtk_theme:
                return "dark"
            elif 'light' in gtk_theme:
                return "light"
                
            # Check for dark mode indicators
            color_scheme = os.environ.get('COLORSCHEME', '').lower()
            if 'dark' in color_scheme:
                return "dark"
            elif 'light' in color_scheme:
                return "light"
                
            return "light"  # Default to light
        except:
            return "light"


class DragDropStackedWidget(QStackedWidget):
    """Custom QStackedWidget that accepts drag-and-drop of files/folders"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.parent_gui = parent
        self.drag_overlay = None
        self._adb_ready = False
        self._smart_drop_prime_deadline = time.time() + 30.0
        self._priming_timer = QTimer(self)
        self._priming_timer.setInterval(1500)
        self._priming_timer.timeout.connect(self._prime_adb_status)
        self._priming_timer.start()
        if hasattr(self.parent_gui, 'adb_status_broker'):
            try:
                self.parent_gui.adb_status_broker.snapshot_changed.connect(self._on_adb_snapshot)
            except Exception as snapshot_err:
                silent_print(f"DragDropStackedWidget: failed to hook snapshot_changed: {snapshot_err}")
        self._check_adb_status()
        self._operation_overlay_active = False
        self._operation_mode = None
        self._operation_overlay_timer = QTimer(self)
        self._operation_overlay_timer.setSingleShot(True)
        self._operation_overlay_timer.timeout.connect(self._verify_operation_overlay_state)
    
    def _check_adb_status(self):
        """Check ADB status and return (is_connected, is_fast_update_enabled) using unified method"""
        try:
            if hasattr(self.parent_gui, 'get_cached_adb_status'):
                snapshot = self.parent_gui.get_cached_adb_status()
                status = snapshot.get('status', 'no_adb')
                is_connected = status in ('adb_only', 'adb_root')
                self._adb_ready = is_connected
                is_fast_update = bool(snapshot.get('fast_update_ready', False))
                if not is_connected and hasattr(self.parent_gui, 'request_adb_status_update'):
                    # Schedule a refresh without blocking the UI thread
                    self.parent_gui.request_adb_status_update()
                return (is_connected, is_fast_update)
            return (False, False)
        except:
            return (False, False)

    def _on_adb_snapshot(self, snapshot):
        """Receive live ADB updates and refresh Smart Drop readiness."""
        try:
            status = snapshot.get('status', 'no_adb')
            self._adb_ready = status in ('adb_only', 'adb_root')
            if self._adb_ready and self._priming_timer.isActive():
                self._priming_timer.stop()
        except Exception as snapshot_error:
            silent_print(f"DragDropStackedWidget snapshot error: {snapshot_error}")
        finally:
            if not self._adb_ready and time.time() > self._smart_drop_prime_deadline:
                if self._priming_timer.isActive():
                    self._priming_timer.stop()

    def _prime_adb_status(self):
        """Kick the ADB broker during the launch window so Smart Drop becomes ready quickly."""
        if self._adb_ready or not self.parent_gui:
            self._priming_timer.stop()
            return
        if time.time() > self._smart_drop_prime_deadline:
            self._priming_timer.stop()
            return
        if hasattr(self.parent_gui, 'request_adb_status_update'):
            self.parent_gui.request_adb_status_update(force_refresh=True)
    
    def _get_drag_message(self, files):
        """Get appropriate drag message based on file types and ADB status"""
        if not files:
            return None
        
        is_connected, is_fast_update = self._check_adb_status()
        
        if not is_connected:
            return None  # Don't show message if ADB not connected
        
        # Check for APK files
        apk_files = [f for f in files if Path(f).suffix.lower() == '.apk']
        if apk_files:
            # 2025-11-09 12:24:00 - original: Overlay prompt read 'Drop to install app' without beta qualifier.
            # This helper builds Smart Drop overlay text; previously it lacked a beta badge.
            # The new string prefixes Smart Drop (Beta) so users understand the capability is experimental.
            return "Smart Drop (Beta): Drop to install app"
        
        # Check for rom*.zip or update*.zip files
        rom_zip_files = [f for f in files if fnmatch.fnmatch(Path(f).name.lower(), 'rom*.zip')]
        update_zip_files = [f for f in files if fnmatch.fnmatch(Path(f).name.lower(), 'update*.zip')]
        
        if update_zip_files:
            if is_fast_update:
                return "Smart Drop (Beta): Drop to Fast Update"
            else:
                # Don't show message for update.zip if Fast Update not available - will be blocked on drop
                return None
        elif rom_zip_files:
            return "Smart Drop (Beta): Drop to install update"
        else:
            return "Smart Drop (Beta): Drop to transfer"
    
    def _show_drag_overlay(self, message, style='dashed'):
        """Show drag overlay with message"""
        try:
            if not message:
                self._hide_drag_overlay()
                return
            
            # Remove existing overlay if any
            self._hide_drag_overlay()
            
            # Create overlay label
            self.drag_overlay = QLabel(message, self)
            self.drag_overlay.setAlignment(Qt.AlignCenter)
            border_style = "3px dashed white"
            background_style = "rgba(0, 0, 0, 200)"
            if style == 'solid':
                border_style = "3px solid #7ab7ff"
                background_style = "rgba(12, 27, 51, 220)"
            self.drag_overlay.setStyleSheet(f"""
                QLabel {{
                    background-color: {background_style};
                    color: white;
                    font-size: 22px;
                    font-weight: 600;
                    letter-spacing: 0.02em;
                    border: {border_style};
                    border-radius: 12px;
                    padding: 24px;
                }}
            """)
            self.drag_overlay.setGeometry(self.rect())
            self.drag_overlay.setVisible(True)
            self.drag_overlay.raise_()
        except Exception as e:
            silent_print(f"Error showing drag overlay: {e}")
    
    def _hide_drag_overlay(self, force=False):
        """Hide drag overlay"""
        try:
            if self._operation_overlay_active and not force:
                return
            if self.drag_overlay:
                self.drag_overlay.setVisible(False)
                self.drag_overlay.deleteLater()
                self.drag_overlay = None
        except:
            pass
    
    def show_operation_overlay(self, mode='smart_drop'):
        """Show persistent overlay indicating an in-progress Smart Drop or Fast Update."""
        messages = {
            'fast_update': "‚ö° Fast Update in progress‚Ä¶",
            'fast_drop': "‚ö° Fast Drop in progress‚Ä¶",
            'smart_drop': "Smart Drop in progress‚Ä¶"
        }
        self._operation_overlay_active = True
        self._operation_mode = mode
        self._operation_overlay_timer.start(1200)
        self._show_drag_overlay(messages.get(mode, "Processing‚Ä¶"), style='solid')
    
    def hide_operation_overlay(self):
        """Hide persistent operation overlay forcefully."""
        self._operation_overlay_active = False
        self._operation_mode = None
        self._operation_overlay_timer.stop()
        self._hide_drag_overlay(force=True)
    
    def _verify_operation_overlay_state(self):
        """Ensure overlay stays only while an operation is active."""
        if not self._operation_overlay_active:
            return
        parent_active = False
        if self.parent_gui:
            parent_active = getattr(self.parent_gui, '_dropzone_operation_active', False)
        if not parent_active:
            self.hide_operation_overlay()
    
    def dragEnterEvent(self, event: QDragEnterEvent):
        """Handle drag enter event"""
        if event.mimeData().hasUrls():
            # Check if installation is in progress
            if hasattr(self.parent_gui, 'adb_operation_in_progress') and self.parent_gui.adb_operation_in_progress:
                event.ignore()
                self._hide_drag_overlay()
                return
            if hasattr(self.parent_gui, 'download_worker') and self.parent_gui.download_worker:
                event.ignore()
                self._hide_drag_overlay()
                return
            
            # Check ADB status
            is_connected, _ = self._check_adb_status()
            if not is_connected:
                event.ignore()
                self._hide_drag_overlay()
                return
            
            # Get files and show appropriate message
            urls = event.mimeData().urls()
            files = [url.toLocalFile() for url in urls if url.isLocalFile()]
            message = self._get_drag_message(files)
            self._show_drag_overlay(message)
            
            event.acceptProposedAction()
        else:
            event.ignore()
            self._hide_drag_overlay()
    
    def dragMoveEvent(self, event):
        """Handle drag move event"""
        if event.mimeData().hasUrls():
            # Check if installation is in progress
            if hasattr(self.parent_gui, 'adb_operation_in_progress') and self.parent_gui.adb_operation_in_progress:
                event.ignore()
                self._hide_drag_overlay()
                return
            if hasattr(self.parent_gui, 'download_worker') and self.parent_gui.download_worker:
                event.ignore()
                self._hide_drag_overlay()
                return
            
            # Check ADB status
            is_connected, _ = self._check_adb_status()
            if not is_connected:
                event.ignore()
                self._hide_drag_overlay()
                return
            
            # Update overlay position
            if self.drag_overlay:
                self.drag_overlay.setGeometry(self.rect())
            
            event.acceptProposedAction()
        else:
            event.ignore()
            self._hide_drag_overlay()
    
    def dragLeaveEvent(self, event):
        """Handle drag leave event"""
        self._hide_drag_overlay()
        super().dragLeaveEvent(event)
    
    def dropEvent(self, event: QDropEvent):
        """Handle drop event"""
        # Hide overlay on drop
        self._hide_drag_overlay()
        
        if event.mimeData().hasUrls():
            # Check if installation is in progress
            if hasattr(self.parent_gui, 'adb_operation_in_progress') and self.parent_gui.adb_operation_in_progress:
                event.ignore()
                return
            if hasattr(self.parent_gui, 'download_worker') and self.parent_gui.download_worker:
                event.ignore()
                return
            
            # Check ADB status
            is_connected, is_fast_update = self._check_adb_status()
            if not is_connected:
                QMessageBox.warning(
                    self.parent_gui,
                    "ADB Not Connected",
                    "No ADB device is connected. Please connect your device via USB or wireless ADB."
                )
                event.ignore()
                return
            
            # Get dropped files/folders
            urls = event.mimeData().urls()
            files = [url.toLocalFile() for url in urls if url.isLocalFile()]
            
            if files:
                # Check for rom*.zip or update*.zip files - process them specially (wildcard support)
                zip_files = [
                    f for f in files 
                    if fnmatch.fnmatch(Path(f).name.lower(), 'rom*.zip') or 
                       fnmatch.fnmatch(Path(f).name.lower(), 'update*.zip')
                ]
                if zip_files:
                    # Check if fast update is available for update.zip files
                    update_zips = [f for f in zip_files if fnmatch.fnmatch(Path(f).name.lower(), 'update*.zip')]
                    if update_zips and not is_fast_update:
                        QMessageBox.warning(
                            self.parent_gui,
                            "Fast Update Not Available",
                            "Fast Update is not available for this device.\n\n"
                            "To update your device, please use a full Install/Restore with a rom.zip file instead."
                        )
                        event.ignore()
                        return
                    
                    # Process zip files as if they were selected via Install from zip
                    for zip_file in zip_files:
                        if hasattr(self.parent_gui, 'process_existing_zip'):
                            # Get repo_name and version from the zip file if possible, or use defaults
                            zip_path = Path(zip_file)
                            repo_name = "rockbox-y1"  # Default
                            version = zip_path.stem  # Use filename without extension as version
                            self.parent_gui.process_existing_zip(str(zip_path), repo_name, version)
                else:
                    if hasattr(self.parent_gui, 'handle_smart_drop_payload'):
                        self.parent_gui.handle_smart_drop_payload(files)
            
            event.acceptProposedAction()
        else:
            event.ignore()
    
    def resizeEvent(self, event):
        """Handle resize event to update overlay position"""
        super().resizeEvent(event)
        if self.drag_overlay:
            self.drag_overlay.setGeometry(self.rect())


class FirmwareDownloaderGUI(QMainWindow):
    """Main GUI window for the firmware downloader"""

    def __init__(self):
        super().__init__()
        self.config_downloader = ConfigDownloader()
        self.github_api = None
        self.packages = []
        self.download_worker = None
        self.mtk_worker = None
        self.update_worker = None
        self.current_update_zip_url = None  # Track update.zip URL for Send to Y1 feature
        self.images_loaded = False  # Track if images are loaded
        self._displaying_release_notes = False  # Flag to prevent concurrent UI updates while displaying release notes
        self._pending_releases = []  # Queue for batching UI updates
        self._release_update_timer = None  # Timer for batched UI updates
        # Set default installation method based on platform
        if platform.system() == "Windows":
            self.installation_method = "spflash"  # Default to Method 1 (Guided) on Windows
        else:
            self.installation_method = "guided"  # Default to Method 1 (Guided) on other platforms
        # Always use method functionality removed - app now always defaults to Method 1
        self.debug_mode = False  # Default debug mode disabled
        self.last_attempted_method = None  # Track the last attempted installation method
        self.app_update_available = False  # Track whether an Innioasis Updater release is available
        self._latest_app_version = None
        self.saved_usb_drive_path = None  # Saved USB drive path for Smart Drop
        self.available_versions = []
        self.version_combo = None
        self.version_download_btn = None
        self.version_run_once_btn = None
        self.version_controls_container = None
        self.version_controls_layout = None
        self._version_tab_layout = None
        self._version_browser = None
        self._run_once_progress_dialog = None
        self.suppress_update_notifications = False  # Global preference
        self.app_version = self._load_app_version()
        self._update_prompt_triggered = False
        self.badge_icon = self._create_badge_icon()
        self.settings_badge = None
        self._active_settings_dialog = None
        self._pending_auto_download_latest = False
        self._last_dual_connection_state = False
        self._update_check_attempts = 0
        self._max_update_check_attempts = 4
        self._update_check_in_progress = False
        self._gui_closing = False  # Flag to prevent worker threads from accessing GUI during shutdown
        try:
            self.is_windows_arm64 = (
                platform.system() == "Windows"
                and platform.machine().lower() in ("arm64", "aarch64")
            )
        except Exception:
            self.is_windows_arm64 = False
        
        # Initialize shortcut settings with defaults (Windows only)
        if platform.system() == "Windows":
            # Legacy settings (kept for compatibility)
            self.desktop_shortcuts_enabled = True  # Default to enabled
            self.startmenu_shortcuts_enabled = True  # Default to enabled
            self.auto_cleanup_enabled = True  # Default to enabled
            
            # New individual shortcut settings with proper defaults
            self.desktop_updater_enabled = True  # Desktop: Innioasis Updater.lnk
            self.desktop_toolkit_enabled = False  # Desktop: No Toolkit
            self.startmenu_updater_enabled = True  # Start Menu: Innioasis Updater.lnk
            self.startmenu_toolkit_enabled = True  # Start Menu: Innioasis Toolkit.lnk
        
        # Automatic updates are now manual by default - no setting needed
        
        # Initialize flag to prevent duplicate wireless ADB connection dialogs
        self._disconnect_usb_dialog_shown = False
        # Load persistent flag for dual connection dialog (shown once per user)
        self._dual_connection_dialog_shown = self.load_dual_connection_dialog_shown()
        # Ensure legacy updater.py launches the modern GUI if invoked directly
        self._ensure_legacy_updater_redirect()
        # Track if auto-connect has been attempted for current USB device
        self._auto_connect_attempted_for_device = None
        
        # Load saved USB drive path on startup
        self.saved_usb_drive_path = self.load_usb_drive_path()
        
        # Initialize file transfer queue for non-firmware files
        self.file_transfer_queue = []  # Queue of (file_paths, destination_folder) tuples
        self.file_transfer_worker = None  # Current transfer worker
        self._smart_drop_followup_transfers = []
        self._smart_drop_cleanup_paths = []
        self._wifi_scan_executor = ThreadPoolExecutor(max_workers=2)
        self._active_wifi_scan_futures = set()

        # Initialize theme monitor for dynamic theme switching
        self.theme_monitor = ThemeMonitor(self)
        self.theme_monitor.theme_changed.connect(self.refresh_button_styles)
        self.theme_monitor.theme_changed.connect(self.refresh_release_notes_on_theme_change)
        self.theme_monitor.theme_changed.connect(self.update_creator_label)
        self.theme_monitor.theme_changed.connect(self._refresh_update_notice_label)
        self.theme_monitor.start_monitoring()

        # Initialize UI first for immediate responsiveness
        self.init_ui()
        QTimer.singleShot(0, self.update_update_badges)
        
        # Show offline message immediately (default state before content loads)
        # Hide left panel by default - will show when releases are available
        QTimer.singleShot(0, self._show_initial_offline_state)

        # Handle version check file and macOS app update message (non-blocking)
        # REMOVED: Legacy .version file handling - app handles updates internally
        # QTimer.singleShot(50, self.handle_version_check)

        # Clean up any previously extracted files at startup (non-blocking, delayed)
        QTimer.singleShot(1000, cleanup_extracted_files)

        # Clean up orphaned processes at startup (Windows only, non-blocking, delayed)
        if platform.system() == "Windows":
            QTimer.singleShot(1500, self.stop_flash_tool_processes)

        # Check for SP Flash Tool on Windows before loading data
        if platform.system() == "Windows":
            # Delay the flash tool check to avoid blocking startup
            QTimer.singleShot(100, self.check_sp_flash_tool)
            # Download troubleshooting shortcuts if missing
            QTimer.singleShot(200, self.ensure_troubleshooting_shortcuts)
        # Check for old shortcuts and offer cleanup (moved to worker thread to avoid blocking)
        QTimer.singleShot(2000, self.check_and_cleanup_old_shortcuts)  # Delayed to not block startup

        # Check for failed installation and show troubleshooting options
        QTimer.singleShot(300, self.check_failed_installation_on_startup)
        
        # Clean up RockboxUtility.zip at startup (delayed to not block startup)
        QTimer.singleShot(2000, self.cleanup_rockbox_utility_zip)
        
        # Check for UsbDk cleanup on Windows - DISABLED
        # UsbDk cleanup prompt removed as it doesn't actually remove anything
        # if platform.system() == "Windows":
        #     QTimer.singleShot(600, self.check_usbdk_cleanup)

        # Ensure troubleshooting shortcuts are available
        QTimer.singleShot(500, self.ensure_troubleshooting_shortcuts_available)

        # Download latest updater.py during launch
        # REMOVED: Legacy updater.py method no longer used - app handles updates internally
        # QTimer.singleShot(600, self.download_latest_updater)

        # Preload critical images with web fallback
        QTimer.singleShot(700, self.preload_critical_images)

        # Load data asynchronously to avoid blocking UI (reduced delay for instant startup)
        # Use worker thread to avoid blocking file I/O and XML parsing
        QTimer.singleShot(10, self.start_data_loader_worker)
        
        # Load saved installation preferences
        QTimer.singleShot(200, self.load_installation_preferences)
        
        # Apply shortcut settings on startup (Windows only)
        if platform.system() == "Windows":
            QTimer.singleShot(300, self.apply_shortcut_settings_on_startup)
        
        # Restore original installation method when session ends
        QTimer.singleShot(300, self.restore_original_installation_method)

        # Theme change detection removed - let native buttons handle styling
        self.last_theme_state = self.is_dark_mode
        
        # Check USB storage mode and ADB device status at startup (non-blocking via worker thread)
        QTimer.singleShot(2000, self._check_usb_and_adb_status)
        # Schedule update check early so users see update prompts immediately (independent of settings dialog)
        QTimer.singleShot(300, self._run_independent_update_check)
        # Also schedule periodic update checks every 5 minutes to catch updates that might be missed
        self._update_check_timer = QTimer()
        self._update_check_timer.timeout.connect(self._run_independent_update_check)
        self._update_check_timer.start(300000)  # 5 minutes
        
        # Initialize status clear timer for auto-clearing orphaned messages
        self.status_clear_timer = None
        # Set initial creator label styling
        QTimer.singleShot(0, self.update_creator_label)

    def update_creator_label(self):
        """Update the creator label text and styling based on theme."""
        if not hasattr(self, 'creator_label') or not self.creator_label:
            return
        message = self._creator_messages[self._creator_message_index % len(self._creator_messages)]
        is_dark = self.is_dark_mode()
        if hasattr(self, 'theme_monitor') and getattr(self.theme_monitor, 'last_theme', None):
            last_theme = self.theme_monitor.last_theme
            if last_theme == "dark":
                is_dark = True
            elif last_theme == "light":
                is_dark = False
        text_color = "#FFFFFF" if is_dark else "#000000"
        link_color = "#4FA8FF" if is_dark else "#0C4BCC"
        emphasis_color = text_color

        formatted_message = message
        if "by Y1 users, for Y1 users" in formatted_message:
            formatted_message = formatted_message.replace(
                "by Y1 users, for Y1 users",
                f'by <span style="font-weight: 700; font-size: 13px; color: {emphasis_color};">Y1 users</span>, '
                f'for <span style="font-weight: 700; font-size: 13px; color: {emphasis_color};">Y1 users</span>'
            )
        if "Ryan Specter" in formatted_message:
            formatted_message = formatted_message.replace(
                "Ryan Specter",
                f'<span style="font-weight: 700; font-size: 13px; color: {link_color};">Ryan Specter</span>'
            )
        if formatted_message.startswith("Developer:"):
            formatted_message = formatted_message.replace(
                "Developer:",
                f'<span style="font-weight: 700; font-size: 12px; color: {emphasis_color};">Developer:</span>',
                1
            )

        html = (
            f'<a href="https://ko-fi.com/team-slide" '
            f'style="color: {text_color}; text-decoration: none;">{formatted_message}</a>'
        )
        self.creator_label.setText(html)
        self.creator_label.setStyleSheet(f"""
            QLabel {{
                color: {text_color};
                font-size: 12px;
                font-weight: 600;
            }}
            QLabel:hover {{
                color: {text_color};
            }}
            a {{
                color: {text_color};
                text-decoration: none;
            }}
        """)

    def cycle_creator_message(self):
        """Rotate through creator messages."""
        self._creator_message_index = (self._creator_message_index + 1) % len(self._creator_messages)
        self.update_creator_label()

    def _load_app_version(self):
        """Load and persist the application version (uses constant APP_VERSION)."""
        version = APP_VERSION
        try:
            version_file = Path(".version")
            current_text = version_file.read_text().strip() if version_file.exists() else ""
            if current_text != version:
                version_file.write_text(version)
        except Exception as e:
            silent_print(f"Warning: could not sync .version file: {e}")
        return version

    def handle_version_check(self):
        """Handle version check file and show macOS app update message for new users"""
        # REMOVED: Legacy .version file handling - app handles updates internally
        pass

    def check_sp_flash_tool(self):
        """Check if any flash tool is running on Windows and show warning"""
        try:
            # Use tasklist to get all running processes
            result = subprocess.run(['tasklist', '/FO', 'CSV'], 
                                  capture_output=True, text=True, timeout=5)
            
            if result.returncode == 0:
                # Check for any executable containing "flash" in the name
                flash_processes = []
                for line in result.stdout.split('\n'):
                    if 'flash' in line.lower() and '.exe' in line.lower():
                        # Extract the process name from CSV format
                        parts = line.split(',')
                        if len(parts) >= 2:
                            process_name = parts[0].strip('"')
                            if 'flash' in process_name.lower():
                                flash_processes.append(process_name)
                
                if flash_processes:
                    # Flash tool(s) detected, show warning dialog
                    process_list = '\n'.join(f"‚Ä¢ {process}" for process in flash_processes)
                    msg_box = QMessageBox(self)
                    msg_box.setWindowTitle("Flash Tool Detected")
                    msg_box.setIcon(QMessageBox.Warning)
                    msg_box.setText("Flash tool(s) are currently running on your system.")
                    msg_box.setInformativeText(
                        f"The following flash tool(s) must be closed before running Innioasis Updater "
                        f"to prevent conflicts with USB device access and flashing operations:\n\n"
                        f"{process_list}\n\n"
                        f"Please close all flash tools completely and then restart Innioasis Updater."
                    )
                    msg_box.setStandardButtons(QMessageBox.Ok)
                    msg_box.setDefaultButton(QMessageBox.Ok)
                    
                    # Show the dialog
                    msg_box.exec()
                    
                    # Optionally, you could close the application here
                    # self.close()
                
        except (subprocess.TimeoutExpired, FileNotFoundError, OSError):
            # If tasklist times out or is not available, assume no conflict and continue
            silent_print("Flash tool check skipped - tasklist not available")
        except Exception as e:
            # If there's any error checking for the process, continue silently
            silent_print(f"Error checking for flash tools: {e}")

    def ensure_troubleshooting_shortcuts(self):
        """Download troubleshooting shortcuts if they're missing (Windows only)"""
        if platform.system() != "Windows":
            return
            
        # Check if shortcuts exist
        current_dir = Path.cwd()
        recovery_lnk = current_dir / "Recover Firmware Install.lnk"
        sp_flash_tool_lnk = current_dir / "Recover Firmware Install - SP Flash Tool.lnk"
        
        # If both shortcuts exist, no need to download
        if recovery_lnk.exists() and sp_flash_tool_lnk.exists():
            silent_print("Troubleshooting shortcuts already exist")
            return

    def check_and_cleanup_old_shortcuts(self):
        """Check for old shortcuts and offer to remove them (Windows only) - non-blocking"""
        if platform.system() != "Windows":
            return
        
        # Run cleanup in a separate thread to avoid blocking UI
        import threading
        def cleanup_thread():
            try:
                silent_print("Starting shortcut cleanup check (background thread)...")
                
                # Remove any shortcuts pointing to updater.py (outdated middleman script)
                self.remove_updater_py_shortcuts()
                
                # Comprehensive cleanup of all Y1 Helper and related shortcuts
                self.comprehensive_shortcut_cleanup()
                
                # Ensure Innioasis Updater shortcuts are properly set up
                self.ensure_innioasis_updater_shortcuts()
                self.ensure_innioasis_toolkit_shortcuts()
                    
            except Exception as e:
                silent_print(f"Error during shortcut cleanup: {e}")
                import traceback
                silent_print(f"Full error traceback: {traceback.format_exc()}")
        
        # Start cleanup in background thread
        cleanup_thread_obj = threading.Thread(target=cleanup_thread, daemon=True)
        cleanup_thread_obj.start()
    
    def remove_updater_py_shortcuts(self):
        """Remove any shortcuts pointing to updater.py (outdated - should point to firmware_downloader.py)"""
        if platform.system() != "Windows":
            return
        
        try:
            import win32com.client
            
            removed_count = 0
            
            # Check desktop
            desktop_path = Path.home() / "Desktop"
            if desktop_path.exists():
                for shortcut_file in desktop_path.glob("*.lnk"):
                    try:
                        shell = win32com.client.Dispatch("WScript.Shell")
                        shortcut = shell.CreateShortcut(str(shortcut_file))
                        target = shortcut.TargetPath.lower()
                        
                        # Check if shortcut points to updater.py
                        if 'updater.py' in target or shortcut_file.name.lower() == 'updater.py.lnk':
                            shortcut_file.unlink()
                            removed_count += 1
                            silent_print(f"Removed shortcut pointing to updater.py: {shortcut_file.name}")
                    except Exception as e:
                        # Skip shortcuts that can't be read
                        continue
            
            # Check start menu
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    for shortcut_file in start_menu_path.rglob("*.lnk"):
                        try:
                            shell = win32com.client.Dispatch("WScript.Shell")
                            shortcut = shell.CreateShortcut(str(shortcut_file))
                            target = shortcut.TargetPath.lower()
                            
                            # Check if shortcut points to updater.py
                            if 'updater.py' in target or shortcut_file.name.lower() == 'updater.py.lnk':
                                shortcut_file.unlink()
                                removed_count += 1
                                silent_print(f"Removed shortcut pointing to updater.py: {shortcut_file.name}")
                        except Exception as e:
                            # Skip shortcuts that can't be read
                            continue
            
            # Also check shortcuts in current directory
            current_dir = Path.cwd()
            for shortcut_file in current_dir.glob("*.lnk"):
                try:
                    shell = win32com.client.Dispatch("WScript.Shell")
                    shortcut = shell.CreateShortcut(str(shortcut_file))
                    target = shortcut.TargetPath.lower()
                    
                    # Check if shortcut points to updater.py
                    if 'updater.py' in target or shortcut_file.name.lower() == 'updater.py.lnk':
                        shortcut_file.unlink()
                        removed_count += 1
                        silent_print(f"Removed shortcut pointing to updater.py: {shortcut_file.name}")
                except Exception as e:
                    # Skip shortcuts that can't be read
                    continue
            
            if removed_count > 0:
                silent_print(f"Removed {removed_count} shortcut(s) pointing to updater.py")
            
        except ImportError:
            # win32com not available (might be on non-Windows or missing pywin32)
            silent_print("Cannot check shortcut targets: win32com not available")
        except Exception as e:
            silent_print(f"Error removing updater.py shortcuts: {e}")

    def cleanup_rockbox_utility_zip(self):
        """Clean up RockboxUtility.zip - extract to assets on Windows, delete on other platforms"""
        try:
            current_dir = Path.cwd()
            rockbox_zip = current_dir / "RockboxUtility.zip"
            
            if not rockbox_zip.exists():
                return  # No zip file to process
            
            silent_print("Found RockboxUtility.zip, processing...")
            
            if platform.system() == "Windows":
                # On Windows: Extract to assets directory
                assets_dir = current_dir / "assets"
                assets_dir.mkdir(exist_ok=True)  # Create assets directory if it doesn't exist
                
                try:
                    with zipfile.ZipFile(rockbox_zip, 'r') as zip_ref:
                        zip_ref.extractall(assets_dir)
                        silent_print(f"Extracted RockboxUtility.zip to {assets_dir}")
                    
                    # Delete the zip file after successful extraction
                    rockbox_zip.unlink()
                    silent_print("Deleted RockboxUtility.zip after extraction")
                    
                except Exception as e:
                    silent_print(f"Error extracting RockboxUtility.zip: {e}")
                    # Still try to delete the zip file even if extraction failed
                    try:
                        rockbox_zip.unlink()
                        silent_print("Deleted RockboxUtility.zip despite extraction error")
                    except Exception as delete_error:
                        silent_print(f"Error deleting RockboxUtility.zip: {delete_error}")
            else:
                # On other platforms: Just delete the zip file
                try:
                    rockbox_zip.unlink()
                    silent_print("Deleted RockboxUtility.zip (not needed on this platform)")
                except Exception as e:
                    silent_print(f"Error deleting RockboxUtility.zip: {e}")
                    
        except Exception as e:
            silent_print(f"Error processing RockboxUtility.zip: {e}")

    def check_usbdk_cleanup(self):
        """Check if UsbDk driver should be cleaned up and offer removal - DISABLED"""
        # This function is no longer called as UsbDk cleanup doesn't actually remove anything
        return

    def show_usbdk_cleanup_dialog(self):
        """Show dialog offering to remove UsbDk driver"""
        try:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("USB Development Kit Cleanup")
            msg_box.setText("USB Development Kit Driver Detected")
            msg_box.setInformativeText(
                "The USB Development Kit (UsbDk) driver is no longer needed for Innioasis Updater.\n\n"
                "Would you like to remove it to clean up your system?\n\n"
                "This will:\n"
                "‚Ä¢ Uninstall the UsbDk driver\n"
                "‚Ä¢ Remove the UsbDk Runtime Library directory\n"
                "‚Ä¢ Reboot your PC to complete the cleanup"
            )
            msg_box.setIcon(QMessageBox.Information)
            
            # Create buttons
            uninstall_btn = msg_box.addButton("Remove UsbDk Driver", QMessageBox.ActionRole)
            keep_btn = msg_box.addButton("Keep Driver", QMessageBox.RejectRole)
            
            # Set default button
            msg_box.setDefaultButton(uninstall_btn)
            
            # Show dialog
            reply = msg_box.exec()
            clicked_button = msg_box.clickedButton()
            
            if clicked_button == uninstall_btn:
                self.perform_usbdk_cleanup()
            else:
                silent_print("User chose to keep UsbDk driver")
                
        except Exception as e:
            silent_print(f"Error showing UsbDk cleanup dialog: {e}")

    def perform_usbdk_cleanup(self):
        """Perform the actual UsbDk driver cleanup"""
        try:
            silent_print("Starting UsbDk driver cleanup...")
            
            # Step 1: Run UsbDkController.exe -u to uninstall
            usbdk_controller = Path("C:/Program Files/UsbDk Runtime Library/UsbDkController.exe")
            if usbdk_controller.exists():
                silent_print("Running UsbDk uninstaller...")
                try:
                    result = subprocess.run(
                        [str(usbdk_controller), "-u"],
                        capture_output=True,
                        text=True,
                        timeout=60,
                        creationflags=subprocess.CREATE_NO_WINDOW
                    )
                    silent_print(f"UsbDk uninstaller result: {result.returncode}")
                    if result.stdout:
                        silent_print(f"UsbDk uninstaller output: {result.stdout}")
                    if result.stderr:
                        silent_print(f"UsbDk uninstaller error: {result.stderr}")
                except subprocess.TimeoutExpired:
                    silent_print("UsbDk uninstaller timed out")
                except Exception as e:
                    silent_print(f"Error running UsbDk uninstaller: {e}")
            else:
                silent_print("UsbDk controller not found, proceeding with directory cleanup")
            
            # Step 2: Delete the UsbDk Runtime Library directory
            usbdk_dir = Path("C:/Program Files/UsbDk Runtime Library")
            if usbdk_dir.exists():
                silent_print("Removing UsbDk Runtime Library directory...")
                try:
                    import shutil
                    shutil.rmtree(usbdk_dir, ignore_errors=True)
                    silent_print("UsbDk Runtime Library directory removed")
                except Exception as e:
                    silent_print(f"Error removing UsbDk directory: {e}")
            else:
                silent_print("UsbDk Runtime Library directory not found")
            
            # Step 3: Show reboot dialog
            self.show_reboot_dialog()
            
        except Exception as e:
            silent_print(f"Error during UsbDk cleanup: {e}")

    def show_reboot_dialog(self):
        """Show dialog asking user to reboot"""
        try:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Restart Required")
            msg_box.setText("UsbDk Driver Cleanup Complete")
            msg_box.setInformativeText(
                "The UsbDk driver has been removed from your system.\n\n"
                "Please restart your PC to complete the cleanup process.\n\n"
                "When you return to Innioasis Updater, you'll have a fully working setup! üéâ"
            )
            msg_box.setIcon(QMessageBox.Information)
            
            # Create buttons
            reboot_now_btn = msg_box.addButton("Restart Now", QMessageBox.ActionRole)
            reboot_later_btn = msg_box.addButton("Restart Later", QMessageBox.RejectRole)
            
            # Set default button
            msg_box.setDefaultButton(reboot_now_btn)
            
            # Show dialog
            reply = msg_box.exec()
            clicked_button = msg_box.clickedButton()
            
            if clicked_button == reboot_now_btn:
                self.initiate_system_reboot()
            else:
                silent_print("User chose to restart later")
                
        except Exception as e:
            silent_print(f"Error showing reboot dialog: {e}")

    def initiate_system_reboot(self):
        """Initiate a system reboot"""
        try:
            silent_print("Initiating system reboot...")
            
            # Use Windows shutdown command to reboot
            subprocess.run(
                ["shutdown", "/r", "/t", "10", "/c", "Innioasis Updater: Restarting to complete UsbDk cleanup"],
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            # Show countdown dialog
            self.show_reboot_countdown()
            
        except Exception as e:
            silent_print(f"Error initiating reboot: {e}")

    def show_reboot_countdown(self):
        """Show countdown dialog before reboot"""
        try:
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("System Restarting")
            msg_box.setText("Your PC will restart in 10 seconds...")
            msg_box.setInformativeText(
                "The system is restarting to complete the UsbDk driver cleanup.\n\n"
                "Innioasis Updater will close now.\n\n"
                "Thank you for using Innioasis Updater! üöÄ"
            )
            msg_box.setIcon(QMessageBox.Information)
            
            # Add only OK button
            msg_box.addButton("OK", QMessageBox.AcceptRole)
            
            # Show dialog
            msg_box.exec()
            
            # Close the application
            QApplication.quit()
            
        except Exception as e:
            silent_print(f"Error showing reboot countdown: {e}")

    def comprehensive_shortcut_cleanup(self):
        """Silent comprehensive cleanup of all Y1 Helper and related shortcuts - no user interaction"""
        if platform.system() != "Windows":
            return
            
        try:
            cleaned_count = 0
            
            # Clean up desktop shortcuts using wildcards
            desktop_path = Path.home() / "Desktop"
            if desktop_path.exists():
                # Remove shortcuts matching patterns
                patterns = ["*Y1*", "*SP Flash*", "*Innioasis*"]
                for pattern in patterns:
                    for item in desktop_path.glob(pattern):
                        if item.is_file() and item.suffix.lower() == '.lnk':
                            try:
                                item.unlink()
                                cleaned_count += 1
                                silent_print(f"Removed desktop shortcut: {item.name}")
                            except Exception as e:
                                silent_print(f"Error removing {item.name}: {e}")
            
            # Clean up start menu shortcuts using wildcards
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    # Remove shortcuts matching patterns
                    patterns = ["*Y1*", "*SP Flash*", "*Innioasis*"]
                    for pattern in patterns:
                        for item in start_menu_path.glob(pattern):
                            if item.is_file() and item.suffix.lower() == '.lnk':
                                try:
                                    item.unlink()
                                    cleaned_count += 1
                                    silent_print(f"Removed start menu shortcut: {item.name}")
                                except Exception as e:
                                    silent_print(f"Error removing {item.name}: {e}")
                    
                    # Remove Y1 Helper folder if it exists
                    y1_helper_folder = start_menu_path / "Y1 Helper"
                    if y1_helper_folder.exists() and y1_helper_folder.is_dir():
                        try:
                            shutil.rmtree(y1_helper_folder)
                            cleaned_count += 1
                            silent_print(f"Removed Y1 Helper folder: {y1_helper_folder}")
                        except Exception as e:
                            silent_print(f"Error removing Y1 Helper folder: {e}")
            
            silent_print(f"Silent comprehensive shortcut cleanup completed: {cleaned_count} items removed")
            
            # Create current shortcuts if enabled in settings
            if getattr(self, 'desktop_shortcuts_enabled', True):
                self.ensure_desktop_shortcuts()
            if getattr(self, 'startmenu_shortcuts_enabled', True):
                self.ensure_startmenu_shortcuts()
                
        except Exception as e:
            silent_print(f"Error during comprehensive shortcut cleanup: {e}")

    def get_all_start_menu_paths(self):
        """Get comprehensive list of all possible start menu paths"""
        paths = []
        
        # User-specific paths
        user_paths = [
            Path.home() / "AppData" / "Roaming" / "Microsoft" / "Windows" / "Start Menu" / "Programs",
            Path.home() / "AppData" / "Local" / "Microsoft" / "Windows" / "Start Menu" / "Programs"
        ]
        
        # System-wide paths
        system_paths = [
            Path("C:/ProgramData/Microsoft/Windows/Start Menu/Programs"),
            Path("C:/ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp"),
            Path("C:/Users/Public/Start Menu/Programs"),
            Path("C:/Users/Public/Desktop")
        ]
        
        # Environment variable paths
        env_paths = []
        if "PROGRAMDATA" in os.environ:
            env_paths.append(Path(os.environ["PROGRAMDATA"]) / "Microsoft" / "Windows" / "Start Menu" / "Programs")
            env_paths.append(Path(os.environ["PROGRAMDATA"]) / "Microsoft" / "Windows/Start Menu/Programs" / "StartUp")
        
        if "PUBLIC" in os.environ:
            env_paths.append(Path(os.environ["PUBLIC"]) / "Start Menu" / "Programs")
            env_paths.append(Path(os.environ["PUBLIC"]) / "Desktop")
        
        # Combine all paths and filter existing ones
        all_paths = user_paths + system_paths + env_paths
        
        silent_print(f"Checking {len(all_paths)} potential start menu paths...")
        
        for path in all_paths:
            silent_print(f"Checking path: {path} (exists: {path.exists()})")
            if path.exists():
                paths.append(path)
                silent_print(f"Found start menu path: {path}")
                
                # Specifically check for the Y1 Helper.lnk file in this path
                y1_helper_lnk = path / "Y1 Helper.lnk"
                if y1_helper_lnk.exists():
                    silent_print(f"*** FOUND Y1 Helper.lnk at: {y1_helper_lnk} ***")
        
        silent_print(f"Total valid start menu paths found: {len(paths)}")
        return paths

    def ensure_innioasis_updater_shortcuts(self):
        """Ensure Innioasis Updater shortcuts are properly set up using appropriate source - respects user preferences"""
        try:
            # Use the new method to get appropriate shortcut source
            source_shortcut = self.get_appropriate_shortcut_source()
            
            if not source_shortcut:
                silent_print("Appropriate Innioasis Updater shortcut source not found")
                return
            
            # Check desktop preference
            desktop_updater_enabled = getattr(self, 'desktop_updater_enabled', True)
            if desktop_updater_enabled:
                desktop_path = Path.home() / "Desktop"
                desktop_shortcut = desktop_path / "Innioasis Updater.lnk"
                
                # Force replacement with Skip Update shortcut (manual updates by default)
                if desktop_shortcut.exists():
                    try:
                        desktop_shortcut.unlink()  # Remove existing shortcut
                        silent_print(f"Removed existing desktop shortcut: Innioasis Updater.lnk")
                    except Exception as e:
                        silent_print(f"Warning: Could not remove existing desktop shortcut: {e}")
                
                try:
                    shutil.copy2(source_shortcut, desktop_shortcut)
                    silent_print(f"Added Innioasis Updater shortcut to desktop (skip-update type)")
                except Exception as e:
                    silent_print(f"Error adding desktop shortcut: {e}")
            else:
                # Remove desktop shortcut if preference is disabled
                desktop_path = Path.home() / "Desktop"
                desktop_shortcut = desktop_path / "Innioasis Updater.lnk"
                if desktop_shortcut.exists():
                    try:
                        desktop_shortcut.unlink()
                        silent_print(f"Removed desktop Updater shortcut (preference disabled)")
                    except Exception as e:
                        silent_print(f"Warning: Could not remove desktop Updater shortcut: {e}")
            
            # Check start menu preference
            startmenu_updater_enabled = getattr(self, 'startmenu_updater_enabled', True)
            if startmenu_updater_enabled:
                start_menu_paths = self.get_all_start_menu_paths()
                
                for start_menu_path in start_menu_paths:
                    if start_menu_path.exists():
                        start_menu_shortcut = start_menu_path / "Innioasis Updater.lnk"
                        # Force replacement with Skip Update shortcut (manual updates by default)
                        if start_menu_shortcut.exists():
                            try:
                                start_menu_shortcut.unlink()  # Remove existing shortcut
                                silent_print(f"Removed existing start menu shortcut: Innioasis Updater.lnk")
                            except Exception as e:
                                silent_print(f"Warning: Could not remove existing start menu shortcut: {e}")
                        
                        try:
                            shutil.copy2(source_shortcut, start_menu_shortcut)
                            silent_print(f"Added Innioasis Updater shortcut to start menu: {start_menu_path} (skip-update type)")
                        except Exception as e:
                            silent_print(f"Error adding start menu shortcut: {e}")
            else:
                # Remove start menu shortcuts if preference is disabled
                start_menu_paths = self.get_all_start_menu_paths()
                for start_menu_path in start_menu_paths:
                    if start_menu_path.exists():
                        start_menu_shortcut = start_menu_path / "Innioasis Updater.lnk"
                        if start_menu_shortcut.exists():
                            try:
                                start_menu_shortcut.unlink()
                                silent_print(f"Removed start menu Updater shortcut (preference disabled): {start_menu_path}")
                            except Exception as e:
                                silent_print(f"Warning: Could not remove start menu Updater shortcut: {e}")
                            
        except Exception as e:
            silent_print(f"Error ensuring Innioasis Updater shortcuts: {e}")

    def ensure_innioasis_toolkit_shortcuts(self):
        """Ensure Innioasis Toolkit shortcuts are properly set up - respects user preferences"""
        try:
            current_dir = Path.cwd()
            innioasis_toolkit_shortcut = current_dir / "Innioasis Toolkit.lnk"
            
            if not innioasis_toolkit_shortcut.exists():
                silent_print("Innioasis Toolkit.lnk not found in current directory")
                return
            
            # Check desktop preference
            desktop_toolkit_enabled = getattr(self, 'desktop_toolkit_enabled', False)
            if desktop_toolkit_enabled:
                desktop_path = Path.home() / "Desktop"
                desktop_shortcut = desktop_path / "Innioasis Toolkit.lnk"
                
                if not desktop_shortcut.exists():
                    try:
                        shutil.copy2(innioasis_toolkit_shortcut, desktop_shortcut)
                        silent_print(f"Added Innioasis Toolkit shortcut to desktop")
                    except Exception as e:
                        silent_print(f"Error adding desktop shortcut: {e}")
                else:
                    silent_print("Desktop Toolkit shortcut already exists (preference enabled)")
            else:
                # Remove desktop shortcut if preference is disabled
                desktop_path = Path.home() / "Desktop"
                desktop_shortcut = desktop_path / "Innioasis Toolkit.lnk"
                if desktop_shortcut.exists():
                    try:
                        desktop_shortcut.unlink()
                        silent_print(f"Removed desktop Toolkit shortcut (preference disabled)")
                    except Exception as e:
                        silent_print(f"Warning: Could not remove desktop Toolkit shortcut: {e}")
            
            # Check start menu preference
            startmenu_toolkit_enabled = getattr(self, 'startmenu_toolkit_enabled', True)
            if startmenu_toolkit_enabled:
                start_menu_paths = self.get_all_start_menu_paths()
                
                for start_menu_path in start_menu_paths:
                    if start_menu_path.exists():
                        start_menu_shortcut = start_menu_path / "Innioasis Toolkit.lnk"
                        if not start_menu_shortcut.exists():
                            try:
                                shutil.copy2(innioasis_toolkit_shortcut, start_menu_shortcut)
                                silent_print(f"Added Innioasis Toolkit shortcut to start menu: {start_menu_path}")
                            except Exception as e:
                                silent_print(f"Error adding start menu shortcut: {e}")
                        else:
                            silent_print(f"Start menu Toolkit shortcut already exists: {start_menu_path}")
            else:
                # Remove start menu shortcuts if preference is disabled
                start_menu_paths = self.get_all_start_menu_paths()
                for start_menu_path in start_menu_paths:
                    if start_menu_path.exists():
                        start_menu_shortcut = start_menu_path / "Innioasis Toolkit.lnk"
                        if start_menu_shortcut.exists():
                            try:
                                start_menu_shortcut.unlink()
                                silent_print(f"Removed start menu Toolkit shortcut (preference disabled): {start_menu_path}")
                            except Exception as e:
                                silent_print(f"Warning: Could not remove start menu Toolkit shortcut: {e}")
            
            # Always ensure Innioasis Updater shortcut exists in Toolkit directory (manual updates by default)
            toolkit_dir = current_dir / "Toolkit"
            if toolkit_dir.exists():
                toolkit_updater_shortcut = toolkit_dir / "Innioasis Updater.lnk"
                if not toolkit_updater_shortcut.exists():
                    # Get the Skip Update shortcut source (manual updates by default)
                    source_shortcut = self.get_appropriate_shortcut_source()
                    if source_shortcut and source_shortcut.exists():
                        try:
                            shutil.copy2(source_shortcut, toolkit_updater_shortcut)
                            silent_print(f"Added Innioasis Updater shortcut to Toolkit directory (skip-update type)")
                        except Exception as e:
                            silent_print(f"Error adding Toolkit Innioasis Updater shortcut: {e}")
                    else:
                        silent_print("Cannot create Toolkit Innioasis Updater shortcut: source not found")
                else:
                    # Force replacement with Skip Update shortcut if it exists
                    source_shortcut = self.get_appropriate_shortcut_source()
                    if source_shortcut and source_shortcut.exists():
                        try:
                            toolkit_updater_shortcut.unlink()  # Remove existing
                            shutil.copy2(source_shortcut, toolkit_updater_shortcut)
                            silent_print(f"Replaced Toolkit Innioasis Updater shortcut with skip-update type")
                        except Exception as e:
                            silent_print(f"Error replacing Toolkit Innioasis Updater shortcut: {e}")
                            
        except Exception as e:
            silent_print(f"Error ensuring Innioasis Toolkit shortcuts: {e}")

    def show_shortcut_cleanup_dialog(self, old_shortcuts):
        """Silently remove old shortcuts without user interaction"""
        try:
            if not old_shortcuts:
                return
                
            silent_print(f"Found {len(old_shortcuts)} old shortcuts, removing silently...")
            self.remove_old_shortcuts(old_shortcuts)
                
        except Exception as e:
            silent_print(f"Error during silent shortcut cleanup: {e}")

    def remove_old_shortcuts(self, old_shortcuts):
        """Remove old shortcuts and folders"""
        try:
            removed_count = 0
            failed_items = []
            
            for location, item_path in old_shortcuts:
                try:
                    item_path = Path(item_path)
                    if item_path.exists():
                        if item_path.is_file():
                            item_path.unlink()
                        elif item_path.is_dir():
                            shutil.rmtree(item_path)
                        removed_count += 1
                        silent_print(f"Removed: {item_path}")
                except PermissionError:
                    # Some items may need admin privileges
                    failed_items.append(f"{item_path} (needs admin)")
                except Exception as e:
                    failed_items.append(f"{item_path} ({e})")
            
            # Show results
            if failed_items:
                silent_print(f"Successfully removed {removed_count} items.")
                silent_print(f"Some items could not be removed (may need admin privileges): {', '.join(failed_items)}")
            else:
                silent_print(f"Successfully removed {removed_count} old shortcuts and folders.")
                
        except Exception as e:
            silent_print(f"Error during cleanup: {e}")

    def check_and_replace_y1_helper_shortcuts(self):
        """Check for Y1 Helper and Y1 Remote Control shortcuts and clean up to desired state"""
        if platform.system() != "Windows":
            return
            
        try:
            shortcuts_to_cleanup = []
            y1_helper_desktop_shortcut = None
            
            # Check desktop for shortcuts
            desktop_path = Path.home() / "Desktop"
            if desktop_path.exists():
                # Check for Y1 Helper.lnk specifically (will be replaced with Innioasis Updater)
                y1_helper_exact = desktop_path / "Y1 Helper.lnk"
                if y1_helper_exact.exists():
                    y1_helper_desktop_shortcut = str(y1_helper_exact)
                
                # Check for other Y1 Helper variants
                for item in desktop_path.glob("*Y1 Helper*.lnk"):
                    if item.name != "Y1 Helper.lnk":  # Skip the exact match we already found
                        shortcuts_to_cleanup.append(("Desktop", str(item), "Y1 Helper variant"))
                
                # Check for Y1 Remote Control variants
                for item in desktop_path.glob("*Y1 Remote Control*.lnk"):
                    shortcuts_to_cleanup.append(("Desktop", str(item), "Y1 Remote Control variant"))
            
            # Check Start Menu for shortcuts
            start_menu_paths = [
                Path.home() / "AppData" / "Roaming" / "Microsoft" / "Windows" / "Start Menu" / "Programs",
                Path.home() / "AppData" / "Local" / "Microsoft" / "Windows" / "Start Menu" / "Programs"
            ]
            
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    # Check for Y1 Helper folder (will be deleted entirely)
                    y1_helper_folder = start_menu_path / "Y1 Helper"
                    if y1_helper_folder.exists():
                        shortcuts_to_cleanup.append(("Start Menu Folder", str(y1_helper_folder), "Y1 Helper folder"))
                    
                    # Check for individual Y1 Helper shortcuts
                    for item in start_menu_path.glob("*Y1 Helper*.lnk"):
                        shortcuts_to_cleanup.append(("Start Menu", str(item), "Y1 Helper shortcut"))
                    
                    # Check for Y1 Remote Control variants
                    for item in start_menu_path.glob("*Y1 Remote Control*.lnk"):
                        shortcuts_to_cleanup.append(("Start Menu", str(item), "Y1 Remote Control variant"))
            
            # Always ensure proper desktop shortcut exists
            self.ensure_proper_desktop_shortcut()
            
            # If exact Y1 Helper.lnk found on desktop, offer Innioasis Updater replacement
            if y1_helper_desktop_shortcut:
                self.show_innioasis_updater_replacement_dialog(y1_helper_desktop_shortcut)
            
            # If other shortcuts found, offer cleanup
            if shortcuts_to_cleanup:
                self.show_comprehensive_cleanup_dialog(shortcuts_to_cleanup)
                
        except Exception as e:
            silent_print(f"Error checking for shortcuts: {e}")

    def show_innioasis_updater_replacement_dialog(self, y1_helper_desktop_shortcut):
        """Show dialog offering to replace Y1 Helper.lnk with Innioasis Updater.lnk"""
        try:
            # Check if Innioasis Updater.lnk exists in the same directory
            current_dir = Path.cwd()
            innioasis_updater_shortcut = current_dir / "Innioasis Updater.lnk"
            
            if not innioasis_updater_shortcut.exists():
                silent_print("Innioasis Updater.lnk not found in current directory")
                return
            
            message = "Found Y1 Helper.lnk on your desktop that can be replaced with Innioasis Updater:\n\n"
            message += "Desktop:\n"
            silent_print(f"Found Y1 Helper shortcut: {Path(y1_helper_desktop_shortcut).name}")
            silent_print("Replacing with Innioasis Updater shortcut...")
            self.replace_y1_helper_with_innioasis_updater(y1_helper_desktop_shortcut, str(innioasis_updater_shortcut))
                
        except Exception as e:
            silent_print(f"Error showing Innioasis Updater replacement dialog: {e}")

    def replace_y1_helper_with_innioasis_updater(self, old_shortcut_path, new_shortcut_path):
        """Replace Y1 Helper.lnk with Innioasis Updater.lnk on desktop"""
        try:
            old_shortcut = Path(old_shortcut_path)
            new_shortcut = Path(new_shortcut_path)
            
            if not old_shortcut.exists():
                silent_print("Y1 Helper.lnk no longer exists on desktop")
                return
            
            if not new_shortcut.exists():
                silent_print("Innioasis Updater.lnk not found in current directory")
                return
            
            # Copy Innioasis Updater.lnk to desktop
            desktop_path = Path.home() / "Desktop"
            desktop_innioasis_shortcut = desktop_path / "Innioasis Updater.lnk"
            
            shutil.copy2(new_shortcut, desktop_innioasis_shortcut)
            
            # Remove the old Y1 Helper.lnk
            old_shortcut.unlink()
            
            silent_print("Successfully replaced Y1 Helper.lnk with Innioasis Updater.lnk on your desktop.")
            silent_print(f"Replaced: {old_shortcut} -> {desktop_innioasis_shortcut}")
            
        except PermissionError:
            silent_print("Could not replace the shortcut. You may need to run as administrator.")
        except Exception as e:
            silent_print(f"Error during replacement: {e}")

    def ensure_proper_desktop_shortcut(self):
        """Ensure Innioasis Updater.lnk exists on desktop"""
        try:
            desktop_path = Path.home() / "Desktop"
            if not desktop_path.exists():
                return
            
            # Check if Innioasis Updater.lnk already exists on desktop
            desktop_innioasis_shortcut = desktop_path / "Innioasis Updater.lnk"
            if desktop_innioasis_shortcut.exists():
                silent_print("Innioasis Updater.lnk already exists on desktop")
                return
            
            # Check if the shortcut exists in current directory
            current_dir = Path.cwd()
            source_shortcut = current_dir / "Innioasis Updater.lnk"
            if not source_shortcut.exists():
                silent_print("Innioasis Updater.lnk not found in current directory")
                return
            
            # Copy the shortcut to desktop
            shutil.copy2(source_shortcut, desktop_innioasis_shortcut)
            silent_print(f"Added Innioasis Updater.lnk to desktop")
            
        except Exception as e:
            silent_print(f"Error ensuring proper desktop shortcut: {e}")

    def show_comprehensive_cleanup_dialog(self, old_shortcuts):
        """Show dialog offering to clean up all old shortcuts"""
        try:
            # Group shortcuts by location for better display
            desktop_items = [item for location, item in old_shortcuts if location == "Desktop"]
            desktop_subfolder_items = [item for location, item in old_shortcuts if location == "Desktop Subfolder"]
            start_menu_items = [item for location, item in old_shortcuts if location == "Start Menu"]
            start_menu_subfolder_items = [item for location, item in old_shortcuts if location == "Start Menu Subfolder"]
            start_menu_folders = [item for location, item in old_shortcuts if location == "Start Menu Folder"]
            
            message = "Found old shortcuts and folders that should be cleaned up:\n\n"
            
            if desktop_items:
                message += "Desktop:\n"
                for item in desktop_items:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += "\n"
            
            if desktop_subfolder_items:
                message += "Desktop Subfolders:\n"
                for item in desktop_subfolder_items:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += "\n"
            
            if start_menu_items:
                message += "Start Menu:\n"
                for item in start_menu_items:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += "\n"
            
            if start_menu_subfolder_items:
                message += "Start Menu Subfolders:\n"
                for item in start_menu_subfolder_items:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += "\n"
            
            if start_menu_folders:
                message += "Start Menu Folders (will be deleted):\n"
                for item in start_menu_folders:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += "\n"
            
            message += "This will clean up all old Y1 Helper and related shortcuts and ensure you have:\n"
            message += "‚Ä¢ Innioasis Updater.lnk on desktop\n"
            message += "‚Ä¢ Innioasis Toolkit.lnk on desktop\n"
            silent_print(f"Found {len(old_shortcuts)} old shortcuts and folders, proceeding with cleanup...")
            self.perform_comprehensive_cleanup(old_shortcuts)
                
        except Exception as e:
            silent_print(f"Error showing comprehensive cleanup dialog: {e}")

    def perform_comprehensive_cleanup(self, old_shortcuts):
        """Perform comprehensive cleanup of old shortcuts and ensure proper ones exist"""
        try:
            removed_count = 0
            failed_items = []
            
            # First, remove all old shortcuts and folders
            for location, item_path in old_shortcuts:
                try:
                    item_path = Path(item_path)
                    if item_path.exists():
                        if location == "Start Menu Folder":
                            # Delete the entire folder
                            shutil.rmtree(item_path)
                            removed_count += 1
                            silent_print(f"Deleted folder: {item_path}")
                        else:
                            # Remove the shortcut
                            item_path.unlink()
                            removed_count += 1
                            silent_print(f"Removed shortcut: {item_path}")
                except PermissionError:
                    # Some items may need admin privileges
                    failed_items.append(f"{item_path} (needs admin)")
                except Exception as e:
                    failed_items.append(f"{item_path} ({e})")
            
            # Now ensure proper shortcuts exist
            self.ensure_innioasis_updater_shortcuts()
            self.ensure_innioasis_toolkit_shortcuts()
            
            # Show results silently
            if failed_items:
                silent_print(f"Successfully cleaned up {removed_count} items.")
                silent_print(f"Some items could not be removed (may need admin privileges): {', '.join(failed_items)}")
            else:
                silent_print(f"Successfully cleaned up {removed_count} old shortcuts and folders.")
                silent_print("Your system now has:")
                silent_print("‚Ä¢ Innioasis Updater.lnk on desktop")
                silent_print("‚Ä¢ Innioasis Toolkit.lnk on desktop")
                silent_print("‚Ä¢ Innioasis Updater.lnk in Start Menu")
                silent_print("‚Ä¢ Innioasis Toolkit.lnk in Start Menu")
                
        except Exception as e:
            silent_print(f"Error during cleanup: {e}")

    def ensure_proper_start_menu_shortcuts(self):
        """Ensure proper shortcuts exist in Start Menu"""
        try:
            current_dir = Path.cwd()
            start_menu_paths = [
                Path.home() / "AppData" / "Roaming" / "Microsoft" / "Windows" / "Start Menu" / "Programs",
                Path.home() / "AppData" / "Local" / "Microsoft" / "Windows" / "Start Menu" / "Programs"
            ]
            
            # Check if proper shortcuts already exist
            innioasis_updater_exists = False
            innioasis_y1_remote_exists = False
            innioasis_toolkit_exists = False
            
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    if (start_menu_path / "Innioasis Updater.lnk").exists():
                        innioasis_updater_exists = True
                    if (start_menu_path / "Innioasis Y1 Remote Control.lnk").exists():
                        innioasis_y1_remote_exists = True
                    if (start_menu_path / "Innioasis Toolkit.lnk").exists():
                        innioasis_toolkit_exists = True
            
            # Copy missing shortcuts from current directory
            if not innioasis_updater_exists:
                source_updater = current_dir / "Innioasis Updater.lnk"
                if source_updater.exists():
                    # Copy to first available start menu path
                    for start_menu_path in start_menu_paths:
                        if start_menu_path.exists():
                            dest_updater = start_menu_path / "Innioasis Updater.lnk"
                            shutil.copy2(source_updater, dest_updater)
                            silent_print(f"Added Innioasis Updater.lnk to {start_menu_path}")
                            break
            
            if not innioasis_y1_remote_exists:
                source_remote = current_dir / "Innioasis Y1 Remote Control.lnk"
                if source_remote.exists():
                    # Copy to first available start menu path
                    for start_menu_path in start_menu_paths:
                            dest_remote = start_menu_path / "Innioasis Y1 Remote Control.lnk"
                            shutil.copy2(source_remote, dest_remote)
                            silent_print(f"Added Innioasis Y1 Remote Control.lnk to {start_menu_path}")
                            break
            
            if not innioasis_toolkit_exists:
                source_toolkit = current_dir / "Innioasis Toolkit.lnk"
                if source_toolkit.exists():
                    # Copy to first available start menu path
                    for start_menu_path in start_menu_paths:
                        if start_menu_path.exists():
                            dest_toolkit = start_menu_path / "Innioasis Toolkit.lnk"
                            shutil.copy2(source_toolkit, dest_toolkit)
                            silent_print(f"Added Innioasis Toolkit.lnk to {start_menu_path}")
                            break
                            
        except Exception as e:
            silent_print(f"Error ensuring proper start menu shortcuts: {e}")

    def show_y1_helper_replacement_dialog(self, y1_helper_shortcuts):
        """Show dialog offering to replace Y1 Helper shortcuts with Y1 Remote Control"""
        try:
            # Group shortcuts by location for better display
            desktop_items = [item for location, item in y1_helper_shortcuts if location == "Desktop"]
            start_menu_items = [item for location, item in y1_helper_shortcuts if location == "Start Menu"]
            start_menu_folders = [item for location, item in y1_helper_shortcuts if location == "Start Menu Folder"]
            
            message = "Found Y1 Helper shortcuts that can be replaced with Y1 Remote Control:\n\n"
            
            if desktop_items:
                message += "Desktop:\n"
                for item in desktop_items:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += "\n"
            
            if start_menu_items:
                message += "Start Menu:\n"
                for item in start_menu_items:
                    message += f"‚Ä¢ {Path(item).name}\n"
                message += f"‚Ä¢ {item}\n"
                message += "\n"
            
            if start_menu_folders:
                message += "Start Menu Folders (will be deleted):\n"
                for item in start_menu_folders:
                    message += f"‚Ä¢ {item}\n"
                message += "\n"
            
            silent_print(f"Found {len(y1_helper_shortcuts)} Y1 Helper shortcuts, replacing with Y1 Remote Control...")
            self.replace_y1_helper_shortcuts(y1_helper_shortcuts)
                
        except Exception as e:
            silent_print(f"Error showing Y1 Helper replacement dialog: {e}")

    def replace_y1_helper_shortcuts(self, y1_helper_shortcuts):
        """Replace Y1 Helper shortcuts with Y1 Remote Control"""
        try:
            replaced_count = 0
            failed_items = []
            
            for location, item_path in y1_helper_shortcuts:
                try:
                    item_path = Path(item_path)
                    if item_path.exists():
                        if location == "Start Menu Folder":
                            # Delete the entire folder
                            shutil.rmtree(item_path)
                            replaced_count += 1
                            silent_print(f"Deleted folder: {item_path}")
                        else:
                            # Replace shortcut with Y1 Remote Control
                            new_shortcut_name = item_path.name.replace("Y1 Helper", "Y1 Remote Control")
                            new_shortcut_path = item_path.parent / new_shortcut_name
                            
                            # Copy the shortcut and modify it to point to Y1 Remote Control
                            shutil.copy2(item_path, new_shortcut_path)
                            
                            # Remove the old Y1 Helper shortcut
                            item_path.unlink()
                            
                            replaced_count += 1
                            silent_print(f"Replaced: {item_path} -> {new_shortcut_path}")
                except PermissionError:
                    # Some items may need admin privileges
                    failed_items.append(f"{item_path} (needs admin)")
                except Exception as e:
                    failed_items.append(f"{item_path} ({e})")
            
            # Show results silently
            if failed_items:
                silent_print(f"Successfully replaced {replaced_count} shortcuts.")
                silent_print(f"Some shortcuts could not be replaced (may need admin privileges): {', '.join(failed_items)}")
            else:
                silent_print(f"Successfully replaced {replaced_count} Y1 Helper shortcuts with Y1 Remote Control.")
                
        except Exception as e:
            silent_print(f"Error during replacement: {e}")
            
        # Download troubleshooting shortcuts
        self.download_troubleshooting_shortcuts()

    def download_troubleshooting_shortcuts(self):
        """Download and extract troubleshooting shortcuts zip file"""
        try:
            self.status_label.setText("Downloading troubleshooting shortcuts...")
            silent_print("Downloading troubleshooting shortcuts...")
            
            # Download URL for troubleshooting shortcuts
            url = "https://innioasis.app/Troubleshooters.-.Windows.zip"
            
            # Download the zip file
            response = requests.get(url, stream=True, timeout=30)
            response.raise_for_status()
            
            # Save to temporary zip file
            temp_zip = Path("troubleshooters_temp.zip")
            with open(temp_zip, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            
            silent_print("Downloaded troubleshooting shortcuts zip file")
            
            # Extract the zip file to current directory
            with zipfile.ZipFile(temp_zip, 'r') as zip_ref:
                zip_ref.extractall(".")
            
            silent_print("Extracted troubleshooting shortcuts")
            
            # Check if Troubleshooters - Windows.zip was extracted and extract its contents
            troubleshooters_zip = Path("Troubleshooters - Windows.zip")
            if troubleshooters_zip.exists():
                silent_print("Found Troubleshooters - Windows.zip, extracting nested contents...")
                with zipfile.ZipFile(troubleshooters_zip, 'r') as nested_zip:
                    nested_zip.extractall(".")
                silent_print("Extracted nested troubleshooting shortcuts")
                
                # Remove the nested zip file after extraction
                troubleshooters_zip.unlink()
                silent_print("Removed nested zip file")
            
            # Delete the temporary zip file
            temp_zip.unlink()
            silent_print("Cleaned up temporary zip file")
            
            # Verify shortcuts were extracted
            current_dir = Path.cwd()
            recovery_lnk = current_dir / "Recover Firmware Install.lnk"
            sp_flash_tool_lnk = current_dir / "Recover Firmware Install - SP Flash Tool.lnk"
            
            if recovery_lnk.exists() and sp_flash_tool_lnk.exists():
                self.status_label.setText("Troubleshooting shortcuts downloaded successfully")
                silent_print("Troubleshooting shortcuts downloaded and extracted successfully")
                # Auto-clear status after 3 seconds
                QTimer.singleShot(3000, lambda: self.status_label.setText("Ready"))
            else:
                self.status_label.setText("Warning: Some troubleshooting shortcuts may be missing")
                silent_print("Warning: Some troubleshooting shortcuts may be missing after extraction")
                # Auto-clear warning after 3 seconds
                QTimer.singleShot(3000, lambda: self.status_label.setText("Ready"))
                
        except Exception as e:
            self.status_label.setText("Failed to download troubleshooting shortcuts")
            silent_print(f"Error downloading troubleshooting shortcuts: {e}")
            # Auto-clear error status after 3 seconds
            QTimer.singleShot(3000, lambda: self.status_label.setText("Ready"))
            # Don't show error dialog - this is not critical for basic functionality

    def ensure_troubleshooting_shortcuts_available(self):
        """Ensure troubleshooting shortcuts are available, extract from zip if needed"""
        try:
            current_dir = Path.cwd()
            recovery_lnk = current_dir / "Recover Firmware Install.lnk"
            sp_flash_tool_lnk = current_dir / "Recover Firmware Install - SP Flash Tool.lnk"
            
            # Check if shortcuts exist
            if recovery_lnk.exists() and sp_flash_tool_lnk.exists():
                silent_print("Troubleshooting shortcuts already available")
                return
            
            # Check if Troubleshooters - Windows.zip exists and extract it
            troubleshooters_zip = current_dir / "Troubleshooters - Windows.zip"
            if troubleshooters_zip.exists():
                silent_print("Found Troubleshooters - Windows.zip, extracting shortcuts...")
                try:
                    with zipfile.ZipFile(troubleshooters_zip, 'r') as zip_ref:
                        zip_ref.extractall(current_dir)
                    
                    # Remove the zip file after extraction
                    troubleshooters_zip.unlink()
                    silent_print("Troubleshooting shortcuts extracted successfully")
                    
                    # Verify extraction
                    if recovery_lnk.exists() and sp_flash_tool_lnk.exists():
                        silent_print("Troubleshooting shortcuts verified")
                    else:
                        silent_print("Warning: Troubleshooting shortcuts still missing after extraction")
                        
                except Exception as e:
                    silent_print(f"Error extracting troubleshooting shortcuts: {e}")
            else:
                silent_print("No troubleshooting shortcuts zip found")
                
        except Exception as e:
            silent_print(f"Error ensuring troubleshooting shortcuts: {e}")

    def check_failed_installation_on_startup(self):
        """Check for failed installation on startup and show troubleshooting options"""
        if not check_for_failed_installation():
            return
            
        # Check driver availability for Windows users
        if platform.system() == "Windows":
            driver_info = self.check_drivers_and_architecture()
            
            if driver_info['is_arm64']:
                silent_print("ARM64 Windows detected during failed install check; skipping full-install troubleshooting prompts.")
                remove_installation_marker()
                return
                
            elif not driver_info['can_install_firmware'] and not driver_info.get('has_mtk_driver') and not driver_info.get('has_usbdk_driver'):
                # No drivers detected: Show informational message but don't block functionality completely
                msg_box = QMessageBox(self)
                msg_box.setWindowTitle("Using Fallback Methods")
                msg_box.setText("No specific drivers detected. You can still attempt installation using fallback methods.")
                msg_box.setInformativeText("For better compatibility, consider installing drivers.")
                msg_box.setIcon(QMessageBox.Information)
                msg_box.setStandardButtons(QMessageBox.Ok)
                msg_box.exec()
                # Don't return here - let the user continue with troubleshooting options
            
        # Show failed installation dialog with troubleshooting options
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Firmware Installation Incomplete")
        msg_box.setText("A previous firmware installation appears to have been interrupted or failed.")
        msg_box.setInformativeText("Would you like to try troubleshooting the installation?")
        msg_box.setIcon(QMessageBox.Warning)
        
        # Create simplified buttons for troubleshooting options
        try_again_btn = msg_box.addButton("Try Again", QMessageBox.ActionRole)
        settings_btn = msg_box.addButton("Settings", QMessageBox.ActionRole)
        quit_app_btn = msg_box.addButton("Quit App", QMessageBox.RejectRole)
        
        # Set default button
        msg_box.setDefaultButton(try_again_btn)
        
        reply = msg_box.exec()
        clicked_button = msg_box.clickedButton()
        
        if clicked_button == try_again_btn:
            # Try Again - use Method 1 (default method for the platform)
            remove_installation_marker()
            if platform.system() == "Windows":
                # Windows: Use guided SP Flash Tool process (Method 1)
                self.try_method_3()
            else:
                # Non-Windows: Use guided MTKclient process (Method 1)
                self.stop_mtk_processes()
                self.cleanup_libusb_state()
                QTimer.singleShot(1000, self.run_mtk_command)
        elif clicked_button == settings_btn:
            # Settings - clear marker and open settings dialog
            remove_installation_marker()
            self.show_settings_dialog()
        else:
            # Quit App - exit the application
            QApplication.quit()

    def ensure_recovery_shortcut(self):
        """Ensure recovery shortcut exists, download if missing"""
        current_dir = Path.cwd()
        recovery_lnk = current_dir / "Recover Firmware Install.lnk"
        
        if recovery_lnk.exists():
            return True
            
        # Shortcut missing, try to download
        self.status_label.setText("Recovery shortcut missing, downloading...")
        self.download_troubleshooting_shortcuts()
        # Auto-clear status after 3 seconds
        QTimer.singleShot(3000, lambda: self.status_label.setText("Ready"))
        
        # Check again after download
        if recovery_lnk.exists():
            return True
            
        # Still missing, show error
        QMessageBox.warning(
            self,
            "Shortcut Missing",
            "The recovery firmware installer shortcut could not be downloaded.\n\n"
            "Please check your internet connection and try again."
        )
        return False

    def ensure_sp_flash_tool_shortcut(self):
        """Ensure SP Flash Tool shortcut exists, download if missing"""
        current_dir = Path.cwd()
        sp_flash_tool_lnk = current_dir / "Recover Firmware Install - SP Flash Tool.lnk"
        
        if sp_flash_tool_lnk.exists():
            return True
            
        # Shortcut missing, try to download
        self.status_label.setText("SP Flash Tool shortcut missing, downloading...")
        self.download_troubleshooting_shortcuts()
        # Auto-clear status after 3 seconds
        QTimer.singleShot(3000, lambda: self.status_label.setText("Ready"))
        
        # Check again after download
        if sp_flash_tool_lnk.exists():
            return True
            
        # Still missing, show error
        QMessageBox.warning(
            self,
            "Shortcut Missing",
            "The SP Flash Tool shortcut could not be downloaded.\n\n"
            "Please check your internet connection and try again."
        )
        return False

    def keyPressEvent(self, event):
        """Handle key press events"""
        # Control+D (Windows/Linux) or Cmd+D (macOS) to toggle debug mode
        if event.key() == Qt.Key_D and (event.modifiers() == Qt.ControlModifier or event.modifiers() == Qt.MetaModifier):
            self.debug_mode = not self.debug_mode
            if self.debug_mode:
                self.status_label.setText("Debug mode enabled - guided installations will show full output")
            else:
                self.status_label.setText("Debug mode disabled - guided installations will show minimal output")
        else:
            super().keyPressEvent(event)




    def show_custom_message_box(self, icon_type, title, message, buttons=QMessageBox.Ok, default_button=QMessageBox.Ok):
        """Show a message box with standard system icons"""
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle(title)
        msg_box.setText(message)
        msg_box.setStandardButtons(buttons)
        msg_box.setDefaultButton(default_button)

        # Set appropriate icon type
        if icon_type == "information":
            msg_box.setIcon(QMessageBox.Information)
        elif icon_type == "warning":
            msg_box.setIcon(QMessageBox.Warning)
        elif icon_type == "critical":
            msg_box.setIcon(QMessageBox.Critical)
        elif icon_type == "question":
            msg_box.setIcon(QMessageBox.Question)
        else:
            msg_box.setIcon(QMessageBox.NoIcon)

        return msg_box.exec()

    def init_ui(self):
        """Initialize the user interface"""
        # Add seasonal emoji to window title
        seasonal_emoji = get_seasonal_emoji()
        title_emoji = f" {seasonal_emoji}" if seasonal_emoji else ""
        self.setWindowTitle(f"Innioasis Updater {APP_VERSION}{title_emoji}")
        self.setGeometry(100, 100, 1220, 574)
        
        # Set fixed window size to maintain layout
        self.setFixedSize(1220, 600)
        
        # Force normal window state (not maximized)
        self.setWindowState(Qt.WindowNoState)



        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        # Create main layout
        main_layout = QVBoxLayout(central_widget)

        # Create splitter for resizable sections
        splitter = QSplitter(Qt.Horizontal)
        main_layout.addWidget(splitter)

        # Left panel - Package selection
        self.left_panel = QWidget()
        left_layout = QVBoxLayout(self.left_panel)

        # Device filters
        filter_group = QGroupBox()
        filter_layout = QVBoxLayout(filter_group)

        # Device type filter
        device_type_layout = QHBoxLayout()
        self.device_type_layout = device_type_layout  # Store reference for button movement
        self.device_type_label = QLabel("Device Type:")
        device_type_layout.addWidget(self.device_type_label)

        self.device_type_combo = QComboBox()
        self.device_type_combo.currentTextChanged.connect(self.filter_firmware_options)
        device_type_layout.addWidget(self.device_type_combo)

        # Add help button with tooltip (to the right of dropdown) - using native styling
        self.type_help_btn = QPushButton("Type?")
        # Use native styling - no custom stylesheet for automatic theme adaptation
        # Use default cursor for native OS feel
        self.type_help_btn.setToolTip("Try Type A System Software first. If your scroll wheel doesn't respond after installation, install one of the Type B options.")
        self.type_help_btn.clicked.connect(self.show_device_type_help)
        device_type_layout.addWidget(self.type_help_btn)
        
        # Add Settings button (combines Tools and Settings functionality) - using native styling
        seasonal_emoji = get_seasonal_emoji_random()
        settings_text = f"Settings{seasonal_emoji}" if seasonal_emoji else "Settings"
        self.settings_btn = QPushButton(settings_text)
        self.settings_base_text = settings_text
        # Use native styling - no custom stylesheet for automatic theme adaptation
        # Use default cursor for native OS feel
        self.settings_btn.setToolTip("Settings and Tools - Installation method, shortcuts, and Y1 Remote Control")
        self.settings_btn.clicked.connect(self.show_settings_dialog)
        device_type_layout.addWidget(self.settings_btn)
        self.settings_badge = QLabel()
        self.settings_badge.setFixedSize(10, 10)
        self.settings_badge.setVisible(False)
        self.settings_badge.setAttribute(Qt.WA_TransparentForMouseEvents, True)
        self.settings_badge.setStyleSheet("""
            QLabel {
                background-color: #FF8800;
                border-radius: 5px;
            }
        """)
        device_type_layout.addWidget(self.settings_badge)
        device_type_layout.setAlignment(self.settings_badge, Qt.AlignVCenter)
        
        # Add small spacing between Settings and Toolkit buttons
        device_type_layout.addSpacing(4)
        
        # Add Toolkit button for all platforms - using native styling
        seasonal_emoji = get_seasonal_emoji_random()
        toolkit_text = f"Toolkit{seasonal_emoji}" if seasonal_emoji else "Toolkit"
        self.toolkit_btn = QPushButton(toolkit_text)
        # Use native styling - no custom stylesheet for automatic theme adaptation
        # Use default cursor for native OS feel
        self.toolkit_btn.setToolTip("Open Innioasis Toolkit - Access all utilities and tools")
        self.toolkit_btn.clicked.connect(self.show_tools_dialog)
        device_type_layout.addWidget(self.toolkit_btn)
        
        device_type_layout.addStretch()

        # Device model filter
        device_model_layout = QHBoxLayout()
        device_model_layout.addWidget(QLabel("Device Model:"))

        self.device_model_combo = QComboBox()
        self.device_model_combo.currentTextChanged.connect(self.filter_firmware_options)
        device_model_layout.addWidget(self.device_model_combo)
        device_model_layout.addStretch()

        # Software filter (Repository)
        software_layout = QHBoxLayout()
        software_layout.addWidget(QLabel("Software:"))

        self.firmware_combo = QComboBox()
        # No "All Software" option - users must select specific software
        # Default selection will be set dynamically in populate_firmware_combo
        self.firmware_combo.currentTextChanged.connect(self.update_package_group_title)
        self.firmware_combo.currentTextChanged.connect(self.on_firmware_changed)
        # Make the software dropdown wider
        self.firmware_combo.setMinimumWidth(300)
        software_layout.addWidget(self.firmware_combo)
        software_layout.addStretch()

        # Pre-release filter checkbox (hidden by default, shown only when pre-releases exist)
        prerelease_layout = QHBoxLayout()
        self.show_prerelease_checkbox = QCheckBox("Show pre-release builds")
        self.show_prerelease_checkbox.setToolTip("Show alpha, beta, nightly, and RC releases")
        self.show_prerelease_checkbox.setChecked(False)
        self.show_prerelease_checkbox.stateChanged.connect(self.on_prerelease_filter_changed)
        self.show_prerelease_checkbox.setVisible(False)  # Hidden by default
        prerelease_layout.addWidget(self.show_prerelease_checkbox)
        prerelease_layout.addStretch()

        filter_layout.addLayout(device_type_layout)
        filter_layout.addLayout(device_model_layout)
        filter_layout.addLayout(software_layout)
        filter_layout.addLayout(prerelease_layout)

        left_layout.addWidget(filter_group)

        # Package list (now shows releases for selected repository)
        package_group = QGroupBox("Available System Software")
        self.package_group = package_group  # Store reference for dynamic updates
        package_layout = QVBoxLayout(package_group)
        package_group.setObjectName("package_group")
        package_group.setStyleSheet("QGroupBox#package_group { margin-top: 6px; }")
        
        self.update_alert_banner = QLabel()
        self.update_alert_banner.setObjectName("update_alert_banner")
        self.update_alert_banner.setWordWrap(True)
        self.update_alert_banner.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        self.update_alert_banner.setVisible(False)
        self.update_alert_banner.setCursor(Qt.PointingHandCursor)
        # Initial stylesheet without color - will be set dynamically by _refresh_update_notice_label
        self.update_alert_banner.setStyleSheet(
            "font-weight: 600; padding: 10px; border-radius: 7px; margin: 0 0 6px 0;"
        )
        package_layout.addWidget(self.update_alert_banner)
        self.update_alert_banner.mousePressEvent = self._on_update_banner_clicked
        # Refresh banner colors immediately after creation to ensure correct theme colors
        QTimer.singleShot(0, self._refresh_update_notice_label)
        
        # Keep layout margins consistent after inserting banner
        package_layout.setSpacing(6)

        self.package_list = QListWidget()
        self.package_list.itemClicked.connect(self.on_release_selected)
        self.package_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.package_list.customContextMenuRequested.connect(self.show_context_menu)

        # Add loading placeholder
        loading_item = QListWidgetItem("Loading...")
        loading_item.setFlags(loading_item.flags() & ~Qt.ItemIsSelectable)  # Make it non-selectable
        self.package_list.addItem(loading_item)

        package_layout.addWidget(self.package_list)

        left_layout.addWidget(package_group)

        # Install/Restore button - using native styling with system accent colors
        seasonal_emoji = get_seasonal_emoji_random()
        download_text = f"Install / Restore{seasonal_emoji}" if seasonal_emoji else "Install / Restore"
        self.download_btn = QPushButton(download_text)
        self.download_btn.setToolTip("Install or restore the selected system software to your Y1")
        self.download_btn.clicked.connect(self.start_download)
        self.download_btn.setEnabled(False)
        # Make this a Default button to get system accent color (like Y1 Remote Control)
        self.download_btn.setDefault(True)
        self.download_btn.setAutoDefault(True)
        if not getattr(self, 'is_windows_arm64', False):
            left_layout.addWidget(self.download_btn)
        else:
            self.download_btn.hide()
        
        # Fast Update button - only shown for releases with update.zip
        self.send_update_btn = QPushButton("‚ö° Fast Update")
        self.send_update_btn.clicked.connect(self.send_update_to_y1)
        self.send_update_btn.setEnabled(False)
        self.send_update_btn.setVisible(False)  # Hidden by default
        self.send_update_btn.setToolTip("Quick update: Downloads update.zip and places it in .rockbox folder on your Y1")
        left_layout.addWidget(self.send_update_btn)
        
        # Initially enable settings button (it will be disabled during operations if needed)
        self.settings_btn.setEnabled(True)
        # Enable toolkit button for all platforms
        if hasattr(self, 'toolkit_btn'):
            self.toolkit_btn.setEnabled(True)
        print("DEBUG: Settings button initially enabled")



        # Right panel - Status and output
        right_panel = QWidget()
        right_layout = QVBoxLayout(right_panel)

        # Top right - Creator credit and social buttons
        coffee_layout = QHBoxLayout()
        self.coffee_layout = coffee_layout  # Store reference for button movement

        # Creator credit
        # Creator label with alternating messages
        creator_label = QLabel()
        creator_label.setOpenExternalLinks(True)
        coffee_layout.addWidget(creator_label)
        self.creator_label = creator_label
        self._creator_messages = [
            "Made with ü©µ by Y1 users, for Y1 users",
            "Developer: Ryan Specter",
        ]
        self._creator_message_index = 0
        self.update_creator_label()
        self.creator_timer = QTimer(self)
        self.creator_timer.timeout.connect(self.cycle_creator_message)
        self.creator_timer.start(7000)

        coffee_layout.addStretch()  # Push buttons to the right

        # Driver Setup button - Windows only, defer driver checks for instant UI loading
        if platform.system() == "Windows":
            # Create placeholder for driver-dependent buttons (will be populated after driver check)
            self.driver_buttons_container = QWidget()
            self.driver_buttons_layout = QHBoxLayout(self.driver_buttons_container)
            self.driver_buttons_layout.setContentsMargins(0, 0, 0, 0)
            coffee_layout.addWidget(self.driver_buttons_container)
            
            # Schedule driver check in background (reduced delay for faster UI population)
            QTimer.singleShot(50, self.update_driver_dependent_ui)
        else:
            # On non-Windows systems, show "Browse Files" button immediately
            self.install_zip_btn = QPushButton("üìÅ Browse Files")
            # Use native styling - no custom stylesheet for automatic theme adaptation
            # Use default cursor for native OS feel
            self.install_zip_btn.clicked.connect(self.browse_files)
            coffee_layout.addWidget(self.install_zip_btn)

        # Reddit button moved to About tab

        # Discord button - using native styling
        seasonal_emoji = get_seasonal_emoji_random()
# 2025-11-09 22:10:00 UTC - original: Button label permanently read "Get Help" and always opened Discord support.
        discord_text = f"Get Help{seasonal_emoji}" if seasonal_emoji else "Get Help"
        self.discord_btn = QPushButton(discord_text)
        self.discord_btn_base_text = discord_text
        self.discord_btn_base_tooltip = self.discord_btn.toolTip() or ""
        # Use native styling - no custom stylesheet for automatic theme adaptation
        self.discord_btn.setCursor(Qt.PointingHandCursor)  # Keep pointing hand for web link
        self.discord_btn.clicked.connect(self.open_discord_link)
        coffee_layout.addWidget(self.discord_btn)

        # About button (opens Settings dialog to About tab) - using native styling
# 2025-11-09 22:10:00 UTC - original: Button label permanently read "About" and navigated directly to the About tab.
        self.about_btn = QPushButton("About")
        self.about_btn_base_text = "About"
        self.about_btn_base_tooltip = self.about_btn.toolTip() or ""
        # Use native styling - no custom stylesheet for automatic theme adaptation
        # Use default cursor for native OS feel
        self.about_btn.clicked.connect(self.open_about_tab)
        coffee_layout.addWidget(self.about_btn)
        self._top_right_update_mode = False
        # Removed: _refresh_top_right_update_cta - no longer modifying Discord/About buttons
        
        # ADB status indicator (will be shown if device is connected) - positioned in corner
        self.adb_status_widget = QWidget()
        self.adb_status_layout = QHBoxLayout(self.adb_status_widget)
        self.adb_status_layout.setContentsMargins(0, 0, 0, 0)
        self.adb_status_layout.setSpacing(4)
        
        self.adb_status_label = QLabel("ADB")
        self.adb_status_label.setStyleSheet("""
            QLabel {
                color: #666666;
                font-size: 10px;
                font-weight: bold;
            }
        """)
        
        # Status light indicator (circle) - can be green or orange
        self.adb_status_light = QLabel("‚óè")
        self.adb_status_light.setStyleSheet("""
            QLabel {
                color: #00FF00;
                font-size: 12px;
            }
        """)
        
        self.adb_status_layout.addWidget(self.adb_status_label)
        self.adb_status_layout.addWidget(self.adb_status_light)
        self.adb_status_widget.setVisible(False)  # Hidden by default, shown when ADB device is connected
        
        # Make ADB status widget clickable to trigger connection check (only when not connected)
        # Will be set dynamically based on connection status
        self.adb_status_widget.mousePressEvent = self.on_adb_status_clicked
        
        coffee_layout.addWidget(self.adb_status_widget)
        
        # Initialize ADB update script worker and timer
        self.adb_update_script_worker = None
        self.prefer_usb_for_transfers = False
        
        # Central broker for ADB status coordination
        self.adb_status_broker = ADBStatusBroker(self)
        self.adb_status_broker.snapshot_changed.connect(self._on_adb_snapshot_changed)
        
        self.adb_check_timer = QTimer()
        self.adb_check_timer.timeout.connect(lambda: self._check_usb_and_adb_status())
        self.adb_check_timer.start(7000)  # Check every 7 seconds
        
        # Also check USB/ADB status immediately at startup
        QTimer.singleShot(1000, self._check_usb_and_adb_status)
        
        # Flag to track if ADB operation is in progress (prevents periodic checks during operations)
        self.adb_operation_in_progress = False
        
        # Initialize blinking animation timer for orange light
        self.adb_blink_timer = QTimer()
        self.adb_blink_timer.timeout.connect(self.blink_orange_light)
        self.adb_light_blinking = False
        self.adb_light_visible = True  # Track visibility state for blinking

        right_layout.addLayout(coffee_layout)

        # App Update button container (button only shown when update is available)
        self.update_layout = QHBoxLayout()
        self.update_layout.addStretch()  # Layout kept for potential future use, but no buttons added
        
        right_layout.addLayout(self.update_layout)

        # Status group
        status_group = QGroupBox("Status")
        status_layout = QVBoxLayout(status_group)

        self.status_label = QLabel("Please follow the instructions below to install this software on your Y1")
        self.status_label.setWordWrap(True)
        self.status_label.setMinimumHeight(30)  # Reduced height for compact display
        self.status_label.setMaximumHeight(40)  # Added maximum height constraint
        status_layout.addWidget(self.status_label)

        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setMinimumHeight(20)  # Ensure progress bar has proper height
        self.progress_bar.setMaximumHeight(25)  # Set maximum height for consistency
        status_layout.addWidget(self.progress_bar)

        right_layout.addWidget(status_group)

        # Output group
        self.output_group = QGroupBox("Getting Ready:")
        output_layout = QVBoxLayout(self.output_group)

        # Image/Release Notes display area - using stacked widget to switch between image and text
        self.image_notes_stack = DragDropStackedWidget(self)
        self.image_notes_stack.setMinimumSize(400, 300)  # Set minimum size for proper initial display
        
        # Image widget (page 0)
        self.image_label = QLabel()
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setStyleSheet("""
            QLabel {
                background-color: transparent;
                border: none;
                color: #333;
            }
        """)
        
        # Release notes widget (page 1)
        self.release_notes_browser = QTextBrowser()
        self.release_notes_browser.setReadOnly(True)
        # Get theme-aware text color for initial styling
        try:
            text_color = self._get_text_color_for_theme()
        except:
            text_color = "#0C1B33"  # Default to dark text
        self.release_notes_browser.setStyleSheet(f"""
            QTextBrowser {{
                background-color: transparent;
                border: none;
                padding: 10px;
                color: {text_color};
            }}
        """)
        
        # Add both widgets to stack
        self.image_notes_stack.addWidget(self.image_label)  # Index 0 - image
        self.image_notes_stack.addWidget(self.release_notes_browser)  # Index 1 - release notes

        # Load initial image with proper sizing
        self.load_presteps_image()
        
        # Show image initially (page 0)
        self.image_notes_stack.setCurrentIndex(0)

        # Ensure proper image sizing after window is fully initialized
        QTimer.singleShot(100, self.ensure_proper_image_sizing)

        output_layout.addWidget(self.image_notes_stack)
        # 2025-11-09 12:24:00 - original: The Smart Drop feature area did not include a beta badge or explanatory label.
        # 2025-11-09 12:33:00 - original: Smart Drop guidance was static text without a help link; users had no way to learn detailed requirements.
        # This function renders the right-side preview stack; previously users had no visual cue that Smart Drop was experimental.
        # By adding the label below, we clearly mark Smart Drop as a beta feature while reminding users it depends on an ADB connection.
        # The string now includes a More info link that opens a dialog describing Smart Drop capabilities and limitations.
        self.smart_drop_hint_label = QLabel(
            "Drop themes, albums, tracks, photos, videos, firmwares here to transfer. "
            "<a href='smart-drop-info'>More Info</a>"
        )
        self.smart_drop_hint_label.setWordWrap(True)
        self.smart_drop_hint_label.setAlignment(Qt.AlignCenter)
        self.smart_drop_hint_label.setStyleSheet("""
            QLabel {
                color: #6c757d;
                font-size: 11px;
                margin-top: 6px;
            }
        """)
        self.smart_drop_hint_label.setTextFormat(Qt.RichText)
        self.smart_drop_hint_label.setTextInteractionFlags(Qt.TextBrowserInteraction)
        self.smart_drop_hint_label.setOpenExternalLinks(False)
        self.smart_drop_hint_label.linkActivated.connect(self.show_smart_drop_info_dialog)
        output_layout.addWidget(self.smart_drop_hint_label)

        right_layout.addWidget(self.output_group)

        # Add panels to splitter
        splitter.addWidget(self.left_panel)
        splitter.addWidget(right_panel)
        splitter.setSizes([480, 720])  # Adjusted for 1220px total width
        
        # Store references for panel hiding/showing functionality
        self.splitter = splitter
        # self.left_panel already set above
        self.right_panel = right_panel
        self.original_splitter_sizes = [480, 720]  # Store original sizes for restoration
        self.panel_hidden = False  # Track panel state

        # Check for test.py availability asynchronously to avoid blocking GUI launch
        self.check_test_py_availability_async()
        
        # Add status bar for driver information
        if platform.system() == "Windows":
            self.create_driver_status_bar()
    
    def is_test_py_available(self):
        """Check if test.py is available locally or at innioasis.app"""
        try:
            # Check local file first
            local_test_py = Path("test.py")
            if local_test_py.exists():
                return True
            
            # Check remote availability
            try:
                response = requests.get("https://innioasis.app/test.py", timeout=5)
                if response.status_code == 200:
                    return True
            except:
                pass
            
            return False
        except Exception:
            return False
    
    def check_test_py_availability_async(self):
        """Check for test.py availability asynchronously and add Labs link if available"""
        def check_and_add_labs():
            try:
                # Check local file first (fast)
                local_test_py = Path("test.py")
                if local_test_py.exists():
                    self.add_labs_link()
                    return
                
                # Check remote availability (slow, but async)
                try:
                    response = requests.get("https://innioasis.app/test.py", timeout=5)
                    if response.status_code == 200:
                        self.add_labs_link()
                except:
                    pass
            except Exception:
                pass
        
        # Run the check in a separate thread to avoid blocking GUI
        import threading
        thread = threading.Thread(target=check_and_add_labs, daemon=True)
        thread.start()
    
    def add_labs_link(self):
        """Add the Labs link to the GUI (called from async thread)"""
        # Use QTimer to safely update GUI from background thread
        QTimer.singleShot(0, self._add_labs_link_safe)
    
    def _add_labs_link_safe(self):
        """Safely add Labs link to GUI from main thread"""
        try:
            # Check if we already added the labs link
            if hasattr(self, 'labs_link'):
                return
            
            labs_layout = QHBoxLayout()
            labs_layout.addStretch()  # Push to the right
            
            # Check if current file is test.py or firmware_downloader.py
            current_file = Path(__file__).name
            if current_file == "test.py":
                labs_text = "Labs ON"
            else:
                labs_text = "Labs OFF"
                
            self.labs_link = QLabel(labs_text)
            self.labs_link.setStyleSheet("""
                QLabel {
                    color: #0066CC;
                    font-size: 11px;
                    text-decoration: underline;
                    cursor: pointer;
                }
                QLabel:hover {
                    color: #004499;
                }
            """)
            self.labs_link.setCursor(Qt.PointingHandCursor)
            self.labs_link.mousePressEvent = self.switch_to_labs_version
            labs_layout.addWidget(self.labs_link)
            
            # Find the main layout and add the labs layout
            # We need to find the right layout to add to
            main_widget = self.centralWidget()
            if main_widget:
                main_layout = main_widget.layout()
                if main_layout:
                    main_layout.addLayout(labs_layout)
        except Exception as e:
            silent_print(f"Error adding labs link: {e}")
    
    def download_test_py(self):
        """Download test.py from innioasis.app with progress bar"""
        try:
            # Create progress dialog
            progress_dialog = QDialog(self)
            progress_dialog.setWindowTitle("Downloading test.py")
            progress_dialog.setFixedSize(400, 150)
            progress_dialog.setModal(True)
            
            layout = QVBoxLayout(progress_dialog)
            
            # Status label
            status_label = QLabel("Downloading test.py from innioasis.app...")
            status_label.setAlignment(Qt.AlignCenter)
            layout.addWidget(status_label)
            
            # Progress bar
            progress_bar = QProgressBar()
            progress_bar.setRange(0, 0)  # Indeterminate progress
            layout.addWidget(progress_bar)
            
            # Show dialog
            progress_dialog.show()
            QApplication.processEvents()
            
            # Download the file
            url = "https://innioasis.app/test.py"
            response = requests.get(url, stream=True, timeout=30)
            response.raise_for_status()
            
            # Get file size for progress tracking
            total_size = int(response.headers.get('content-length', 0))
            if total_size > 0:
                progress_bar.setRange(0, total_size)
                progress_bar.setValue(0)
            
            # Download and save file
            downloaded = 0
            with open("test.py", "wb") as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
                        downloaded += len(chunk)
                        if total_size > 0:
                            progress_bar.setValue(downloaded)
                        QApplication.processEvents()
            
            # Update status
            status_label.setText("Download completed successfully!")
            progress_bar.setValue(progress_bar.maximum())
            QApplication.processEvents()
            
            # Close dialog after a brief delay
            QTimer.singleShot(1000, progress_dialog.accept)
            progress_dialog.exec()
            
            return True
            
        except Exception as e:
            # Close dialog on error
            if 'progress_dialog' in locals():
                progress_dialog.close()
            silent_print(f"Error downloading test.py: {e}")
            return False

    def create_driver_status_bar(self):
        """Create a status bar showing driver information for Windows users"""
        driver_info = self.check_drivers_and_architecture()
        
        # Create status bar
        status_bar = self.statusBar()
        
        if driver_info['is_arm64']:
            status_bar.clearMessage()
        else:
            status_bar.showMessage("")

    def stop_mtk_processes(self):
        """Stop any running MTK processes"""
        try:
            if platform.system() == "Windows":
                # Stop any running mtk.py processes on Windows
                subprocess.run(['taskkill', '/F', '/IM', 'python.exe', '/FI', 'WINDOWTITLE eq *mtk*'], 
                              capture_output=True, timeout=5)
            else:
                # Stop any running mtk.py processes on Unix-like systems
                subprocess.run(['pkill', '-f', 'mtk.py'], capture_output=True, timeout=5)
            silent_print("Stopped any running MTK processes")
        except Exception as e:
            silent_print(f"Error stopping MTK processes: {e}")

    def cleanup_libusb_state(self):
        """Clean up libusb state and USB device connections"""
        try:
            if platform.system() == "Windows":
                # On Windows, try to reset USB devices
                silent_print("Cleaning up USB state on Windows...")
                # This is a placeholder - actual USB reset would require more complex implementation
            else:
                # On Unix-like systems, try to reset USB devices
                silent_print("Cleaning up USB state on Unix-like system...")
                # This is a placeholder - actual USB reset would require more complex implementation
            silent_print("USB state cleanup completed")
        except Exception as e:
            silent_print(f"Error during USB state cleanup: {e}")

    def revert_to_startup_state(self):
        """Revert the application to its startup state"""
        try:
            # Reset status and progress
            # Add seasonal emoji to ready status
            seasonal_emoji = get_seasonal_emoji_random()
            ready_text = f"Ready{seasonal_emoji}" if seasonal_emoji else "Ready"
            self.status_label.setText(ready_text)
            self.progress_bar.setVisible(False)
            
            # Load initial image
            self.load_presteps_image()
            
            # Restore left panel to default state
            self.show_left_panel()
            
            # Update driver status bar if on Windows
            if platform.system() == "Windows":
                self.create_driver_status_bar()
                
            silent_print("Application reverted to startup state")
        except Exception as e:
            silent_print(f"Error reverting to startup state: {e}")

    def run_mtk_command(self):
        """Run the MTK command for firmware installation"""
        try:
            # Check driver availability for Windows users
            if platform.system() == "Windows":
                driver_info = self.check_drivers_and_architecture()
                
                if driver_info['is_arm64']:
                    silent_print("ARM64 Windows requested MTK install; ignoring because full installs are disabled.")
                    self.status_label.setText("Install / Restore is unavailable on Windows ARM64.")
                    return
                    
                elif not driver_info['can_install_firmware'] and not driver_info.get('has_mtk_driver') and not driver_info.get('has_usbdk_driver'):
                    # Show warning but don't block - allow fallback methods
                    result = QMessageBox.information(
                        self,
                        "No Specific Drivers Detected",
                        "No specific drivers detected. The application will attempt installation using fallback methods.\n\n"
                        "If installation fails, consider installing drivers for better compatibility.\n\n"
                        "Click OK to continue with fallback methods or Cancel to install drivers.",
                        QMessageBox.Ok | QMessageBox.Cancel,
                        QMessageBox.Ok
                    )
                    if result == QMessageBox.Cancel:
                        self.open_driver_setup_link()
                        return
                    # Continue with fallback methods if OK is clicked
            
            # Create installation marker
            create_installation_marker()
            
            # Start MTK worker
            if not self.mtk_worker or not self.mtk_worker.isRunning():
                # Create debug window if debug mode is enabled
                debug_window = None
                if getattr(self, 'debug_mode', False):
                    debug_window = DebugOutputWindow(self)
                    debug_window.show()
                
                self.mtk_worker = MTKWorker(debug_mode=getattr(self, 'debug_mode', False), debug_window=debug_window)
                self.mtk_worker.status_updated.connect(self.update_status)
                self.mtk_worker.show_installing_image.connect(self.load_installing_image)
                self.mtk_worker.show_reconnect_image.connect(self.load_handshake_error_image)
                self.mtk_worker.show_presteps_image.connect(self.load_presteps_image)
                self.mtk_worker.show_please_wait_image.connect(self.load_please_wait_image)
                self.mtk_worker.show_initsteps_image.connect(self.load_initsteps_image)
                self.mtk_worker.show_instructions_image.connect(self.load_initsteps_image)
                self.mtk_worker.show_try_again_dialog.connect(self.show_try_again_dialog)
                self.mtk_worker.mtk_completed.connect(self.handle_mtk_completion)
                self.mtk_worker.handshake_failed.connect(self.handle_handshake_failure)
                self.mtk_worker.errno2_detected.connect(self.handle_errno2_error)
                self.mtk_worker.backend_error_detected.connect(self.handle_backend_error)
                self.mtk_worker.keyboard_interrupt_detected.connect(self.handle_keyboard_interrupt)
                self.mtk_worker.disable_update_button.connect(self.disable_update_button)
                self.mtk_worker.enable_update_button.connect(self.enable_update_button)
                self.mtk_worker.start()
                
                self.status_label.setText("Starting MTK installation...")
                silent_print("MTK worker started")
            else:
                silent_print("MTK worker already running")
                
        except Exception as e:
            silent_print(f"Error starting MTK command: {e}")
            self.status_label.setText(f"Error starting MTK command: {e}")

    def update_progress(self, value):
        """Update the progress bar value"""
        self.progress_bar.setValue(value)
    
    def update_status(self, message, auto_clear_seconds=5):
        """Update the status label with a message and optionally auto-clear after timeout"""
        # Cancel any existing clear timer
        if hasattr(self, 'status_clear_timer') and self.status_clear_timer:
            self.status_clear_timer.stop()
            self.status_clear_timer = None
        
        if not message or message.strip() == "":
            self.status_label.setText("Please follow the instructions below to install this software on your Y1")
        elif message.strip() == "MTK: Preloader":
            # Just "MTK: Preloader" indicates freeze state
            self.status_label.setText("Please disconnect your Y1 and restart the app")
        elif message.startswith("MTK:") and (message.strip() == "MTK:" or 
                                              message.strip() == "MTK:..........." or 
                                              message.strip() == "MTK: ..........." or
                                              message.strip() == "MTK: .........." or
                                              message.strip() == "MTK: ........" or
                                              message.strip() == "MTK: ......." or
                                              message.strip() == "MTK: ......" or
                                              message.strip() == "MTK: ....." or
                                              message.strip() == "MTK: ...." or
                                              message.strip() == "MTK: ..." or
                                              message.strip() == "MTK: .." or
                                              message.strip() == "MTK: ." or
                                              message.strip() == "MTK: " or  # Just "MTK: " with space
                                              message.strip().startswith("MTK:...") or  # Lines beginning with dots
                                              message.strip().startswith("MTK:  ") or  # Lines with just spaces
                                              len(message.strip()) <= 10):  # Very short MTK messages likely indicate waiting
            # MTK is waiting for device connection or showing dots/spaces
            self.status_label.setText("Now please follow the instructions displayed below. Please force quit the app if not responding and restart it.")
        else:
            self.status_label.setText(message)
            # Auto-clear status after timeout (unless it's a persistent message like MTK or installation progress)
            # Don't auto-clear if message indicates an active operation
            persistent_keywords = ["MTK:", "Installing", "Downloading", "Preparing", "Starting", "Progress", "Please follow"]
            if auto_clear_seconds > 0 and not any(keyword in message for keyword in persistent_keywords):
                self.status_clear_timer = QTimer()
                self.status_clear_timer.setSingleShot(True)
                self.status_clear_timer.timeout.connect(lambda: self.status_label.setText("Ready"))
                self.status_clear_timer.start(auto_clear_seconds * 1000)

    def _ensure_adb_idle(self, action_description):
        """
        Verify that no other ADB task is currently running before starting a new one.
        Returns True when idle, otherwise shows a friendly notice and returns False.
        """
        if getattr(self, 'adb_operation_in_progress', False):
            notice = (
                "Another ADB task is already running.\n\n"
                "Please wait for the current Fast Update or device preparation to finish "
                "before starting {}."
            ).format(action_description)
            QMessageBox.information(self, "ADB Busy", notice)
            return False
        return True

    def _read_fastupdate_marker(self, adb_path, device_id, env):
        """Return (exists, date_string) for the .fastupdate marker on device (primary with legacy fallback)."""
        def _read_marker(path):
            try:
                marker_cmd = [str(adb_path)]
                if device_id:
                    marker_cmd.extend(['-s', device_id])
                marker_cmd.extend(['shell', 'su', '-c', f'cat {path}'])
                result = subprocess.run(
                    marker_cmd,
                    capture_output=True,
                    text=True,
                    timeout=3,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                if result.returncode == 0:
                    marker_output = result.stdout.strip()
                    marker_value = marker_output.splitlines()[0] if marker_output else ""
                    if marker_value:
                        return True, marker_value
            except Exception as e:
                silent_print(f"Fast Update marker read failed for {path}: {e}")
            return False, ""
        
        exists, value = _read_marker(FASTUPDATE_MARKER_PATH)
        if exists:
            return exists, value
        # Legacy fallback for older versions that stored marker under /data/data/update/
        legacy_exists, legacy_value = _read_marker(LEGACY_FASTUPDATE_MARKER_PATH)
        if legacy_exists:
            silent_print("Found legacy Fast Update marker, migrating to primary location‚Ä¶")
            try:
                self._write_fastupdate_marker(adb_path, device_id, env)
            except Exception as migrate_error:
                silent_print(f"Failed to migrate legacy Fast Update marker: {migrate_error}")
            return True, legacy_value
        return False, ""

    def _write_fastupdate_marker(self, adb_path, device_id, env):
        """Write today's date into the Fast Update marker on the device."""
        try:
            today_str = datetime.now().strftime('%Y-%m-%d')
            write_cmd = [str(adb_path)]
            if device_id:
                write_cmd.extend(['-s', device_id])
            write_cmd.extend(['shell', 'su', '-c', f'echo {today_str} > {FASTUPDATE_MARKER_PATH}'])
            subprocess.run(
                write_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            # Ensure readable permissions
            chmod_cmd = [str(adb_path)]
            if device_id:
                chmod_cmd.extend(['-s', device_id])
            chmod_cmd.extend(['shell', 'su', '-c', f'chmod 644 {FASTUPDATE_MARKER_PATH}'])
            subprocess.run(
                chmod_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            # Clean up legacy marker if present
            if LEGACY_FASTUPDATE_MARKER_PATH != FASTUPDATE_MARKER_PATH:
                cleanup_cmd = [str(adb_path)]
                if device_id:
                    cleanup_cmd.extend(['-s', device_id])
                cleanup_cmd.extend(['shell', 'su', '-c', f'rm -f {LEGACY_FASTUPDATE_MARKER_PATH}'])
                subprocess.run(
                    cleanup_cmd,
                    capture_output=True,
                    text=True,
                    timeout=3,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
            silent_print(f"Fast Update marker written for device {device_id}: {today_str}")
        except Exception as e:
            silent_print(f"Failed to write Fast Update marker: {e}")

    def _check_update_script_exists(self, adb_path, device_id, env):
        """Return True if update.sh exists in the expected location."""
        try:
            check_cmd = [str(adb_path)]
            if device_id:
                check_cmd.extend(['-s', device_id])
            check_cmd.extend(['shell', 'su', '-c', f'test -f {UPDATE_SCRIPT_PATH} && echo exists'])
            result = subprocess.run(
                check_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            return (
                result.returncode == 0 and
                result.stdout.strip() == 'exists'
            )
        except Exception as e:
            silent_print(f"Update script existence check failed: {e}")
            return False

    def handle_mtk_completion(self, success, message):
        """Handle MTK command completion"""
        if success:
            # Add seasonal emoji to completion message
            seasonal_emoji = get_seasonal_emoji_random()
            completion_text = f"Installation completed successfully{seasonal_emoji}" if seasonal_emoji else "Installation completed successfully"
            self.status_label.setText(completion_text)
            self.load_installed_image()
            remove_installation_marker()
            # Restore left panel after successful installation
            self.show_left_panel()
        else:
            self.status_label.setText(f"Installation failed: {message}")
            self.load_process_ended_image()
            remove_installation_marker()
            # Restore left panel after failed installation
            self.show_left_panel()
            # Revert to startup state after showing error
            QTimer.singleShot(3000, self.revert_to_startup_state)

    def handle_handshake_failure(self):
        """Handle handshake failure"""
        self.status_label.setText("Please unplug your Y1 and try again")
        self.load_initsteps_image()

    def handle_errno2_error(self):
        """Handle errno2 error"""
        self.status_label.setText("Errno2 error - Innioasis Updater reinstall required")
        self.load_process_ended_image()
        # Revert to startup state after showing error
        QTimer.singleShot(3000, self.revert_to_startup_state)

    def handle_backend_error(self):
        """Handle backend error"""
        self.status_label.setText("Backend error - libusb backend issue")
        self.load_process_ended_image()
        # Revert to startup state after showing error
        QTimer.singleShot(3000, self.revert_to_startup_state)

    def handle_keyboard_interrupt(self):
        """Handle keyboard interrupt"""
        self.status_label.setText("Installation interrupted by user")
        self.load_process_ended_image()
        # Revert to startup state after showing error
        QTimer.singleShot(3000, self.revert_to_startup_state)

    def disable_update_button(self):
        """Disable the update button during MTK installation"""
            # Disable buttons during operation - but don't reference update_btn_right
            # (update buttons removed - only banner is shown)

    def enable_update_button(self):
        """Enable the update button when returning to ready state"""
            # Re-enable buttons after operation - but don't reference update_btn_right
            # (update buttons removed - only banner is shown)

    def show_troubleshooting_instructions(self):
        """Show Method 2 troubleshooting instructions"""
        try:
            # Load Method 2 image
            self.load_method2_image()
            
            # Show dialog with Method 2 instructions
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Method 2 - in Terminal Troubleshooting")
            msg_box.setIcon(QMessageBox.Information)
            msg_box.setText("Method 2: in Terminal Direct Installation")
            msg_box.setInformativeText(
                "This method uses the MTKclient library directly for firmware installation.\n\n"
                "Please follow the on-screen instructions and ensure your device is properly connected.\n\n"
                "If this method fails, you may need to check your drivers or try Method 3 (SP Flash Tool Console Mode)."
            )
            msg_box.setStandardButtons(QMessageBox.Ok)
            msg_box.exec()
            
        except Exception as e:
            silent_print(f"Error showing Method 2 instructions: {e}")

    def try_method_3(self):
        """Try Method 3 - SP Flash Tool (Windows only) - Guided Process"""
        try:
            if platform.system() != "Windows":
                QMessageBox.warning(
                    self,
                    "Method 3 Not Available",
                    "Method 3 (SP Flash Tool) is only available on Windows."
                )
                return
            
            # No need to check for shortcut since we're using flash_tool.exe directly
            
            # Load please wait image initially
            self.load_please_wait_image()
            
            # Show dialog with Method 3 instructions
            reply = QMessageBox.question(
                self,
                "Software Install instructions",
                "Before continuing, please:\n\n"
                "1. Power off your Y1\n"
                "   (You can use a pin or paperclip to press the reset button if needed)\n\n"
                "2. Make sure your Y1 is NOT connected via USB\n\n"
                "Then click OK and follow the on-screen instructions.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                # Show appropriate buttons again when cancelled
                self.show_appropriate_buttons_for_spflash()
                # Show left panel again when cancelled
                self.show_left_panel()
                return
            
            # No need to stop MTK processes since Method 3 uses flash_tool.exe directly
            
            # Check if flash_tool.exe and install_rom_sp.xml exist
            current_dir = Path.cwd()
            flash_tool_exe = current_dir / "flash_tool.exe"
            install_rom_xml = current_dir / "install_rom_sp.xml"
            
            if not flash_tool_exe.exists():
                # Show appropriate buttons again when flash tool is missing
                self.show_appropriate_buttons_for_spflash()
                # Show left panel again when flash tool is missing
                self.show_left_panel()
                QMessageBox.critical(
                    self,
                    "Flash Tool Not Found",
                    "flash_tool.exe not found. Please ensure it's properly installed."
                )
                return
                
            if not install_rom_xml.exists():
                # Show appropriate buttons again when XML is missing
                self.show_appropriate_buttons_for_spflash()
                # Show left panel again when XML is missing
                self.show_left_panel()
                QMessageBox.critical(
                    self,
                    "Install ROM XML Not Found",
                    "install_rom_sp.xml not found. Please ensure it's properly installed."
                )
                return
            
            # Start the SP Flash Tool worker
            self.spflash_worker = SPFlashToolWorker()
            self.spflash_worker.status_updated.connect(self.status_label.setText)
            self.spflash_worker.show_installing_image.connect(self.load_installing_image)
            self.spflash_worker.show_initsteps_image.connect(self.load_method3_image)  # Use initsteps_sp.png for SP Flash Tool initsteps
            self.spflash_worker.show_installed_image.connect(self.load_installed_image)  # Use installed.png for completion
            self.spflash_worker.show_please_wait_image.connect(self.load_please_wait_image)  # Use please_wait.png for initial phase
            self.spflash_worker.spflash_completed.connect(self.on_spflash_completed)
            self.spflash_worker.disable_update_button.connect(self.disable_update_button)
            self.spflash_worker.enable_update_button.connect(self.enable_update_button)
            
            # Hide inappropriate buttons for SP Flash Tool method
            self.hide_inappropriate_buttons_for_spflash()
            
            # Hide left panel for SP Flash Tool installation to focus user attention on instructions
            self.hide_left_panel()
            
            # Disable remaining buttons during installation
            self.settings_btn.setEnabled(False)
            if hasattr(self, 'toolkit_btn'):
                self.toolkit_btn.setEnabled(False)
            
            # Start the worker
            self.spflash_worker.start()
            
        except Exception as e:
            silent_print(f"Error starting Method 3: {e}")
            # Show appropriate buttons again in case of error
            self.show_appropriate_buttons_for_spflash()
            # Show left panel again in case of error
            self.show_left_panel()
            QMessageBox.critical(
                self,
                "Method 3 Error",
                f"Failed to start SP Flash Tool:\n{e}"
            )

    def on_spflash_completed(self, success, message):
        """Handle SP Flash Tool completion"""
        try:
            # Show appropriate buttons for SP Flash Tool method
            self.show_appropriate_buttons_for_spflash()
            
            # Show left panel again after installation
            self.show_left_panel()
            
            # Re-enable buttons
            self.settings_btn.setEnabled(True)
            if hasattr(self, 'toolkit_btn'):
                self.toolkit_btn.setEnabled(True)
            
            if success:
                # Show success message and load completion image
                self.status_label.setText("Your software installation completed successfully")
                # Load the installed completion image
                self.load_installed_image()
                
                # Show success dialog with seasonal emoji
                seasonal_emoji = get_seasonal_emoji_random()
                dialog_title = f"Installation Complete{seasonal_emoji}" if seasonal_emoji else "Installation Complete"
                QMessageBox.information(
                    self,
                    dialog_title,
                    "Your installation has completed successfully!\n\n"
                    "Please disconnect your Y1 and hold the middle button to turn it on."
                )
            else:
                # Show error message and revert to startup state
                self.status_label.setText(f"Flash Tool installation failed: {message}")
                QMessageBox.critical(
                    self,
                    "Installation Failed",
                    f"Installation failed:\n{message}\n\n"
                    "Please disconnect your Y1 from USB and try again, if this fails visit troubleshooting.innioasis.app."
                )
                # Revert to startup state after showing error
                self.revert_to_startup_state()
                
        except Exception as e:
            silent_print(f"Error handling Flash Tool completion: {e}")

    def try_method_4(self):
        """Try SP Flash Tool GUI (Windows only) - Launches SP Flash Tool - GUI.lnk from Toolkit directory"""
        try:
            if platform.system() != "Windows":
                QMessageBox.warning(
                    self,
                    "SP Flash Tool GUI Not Available",
                    "SP Flash Tool GUI is only available on Windows."
                )
                return
            
            # Check if SP Flash Tool - GUI.lnk exists in Toolkit directory
            current_dir = Path.cwd()
            toolkit_dir = current_dir / "Toolkit"
            sp_flash_tool_lnk = toolkit_dir / "SP Flash Tool - GUI.lnk"
            
            if not sp_flash_tool_lnk.exists():
                QMessageBox.critical(
                    self,
                    "SP Flash Tool GUI Not Found",
                    "SP Flash Tool - GUI.lnk not found in Toolkit directory. Please ensure it's properly installed."
                )
                return
            
            # Show dialog with SP Flash Tool GUI instructions
            reply = QMessageBox.question(
                self,
                "SP Flash Tool GUI",
                "SP Flash Tool GUI will now launch.\n\n"
                "Power off your Y1:\n"
                "Make sure is NOT connected then, Press OK.\n\n"
                "Then follow the on screen instructions...\n\n"
                "Powering Off: You can also insert a pin/paper clip in the hole on the bottom).\n\n"
                "This method launches the SP Flash Tool GUI interface.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                return
            
            # Launch SP Flash Tool - GUI.lnk from Toolkit directory using proper Windows method
            try:
                # Use os.startfile() to properly launch .lnk files on Windows
                import os
                os.startfile(str(sp_flash_tool_lnk))
                silent_print(f"Launched SP Flash Tool GUI: {sp_flash_tool_lnk}")
                
                # Show success message
                QMessageBox.information(
                    self,
                    "SP Flash Tool GUI Launched",
                    "Your downloaded ROM is loaded into SP Flash Tool's GUI\n\n"
                    "Make sure you power off your Y1 and select Format All + Download in the drop down menu."
                )
                
                # Revert to ready and presteps.png state after successful launch
                self.revert_to_startup_state()
                
            except Exception as e:
                silent_print(f"Error launching SP Flash Tool GUI: {e}")
                QMessageBox.critical(
                    self,
                    "Launch Error",
                    f"Failed to launch SP Flash Tool GUI:\n\n{e}"
                )
            
        except Exception as e:
            silent_print(f"Error in SP Flash Tool GUI method: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred: {e}"
            )

    def try_method_3_console(self):
        """Try Method 3 - SP Flash Tool Console Mode (Windows only) - Launches SP Flash Tool.lnk from Toolkit directory"""
        try:
            if platform.system() != "Windows":
                QMessageBox.warning(
                    self,
                    "Method 3 Not Available",
                    "Method 3 (SP Flash Tool Console Mode) is only available on Windows."
                )
                return
            
            # Check if SP Flash Tool.lnk exists in Toolkit directory
            current_dir = Path.cwd()
            toolkit_dir = current_dir / "Toolkit"
            sp_flash_tool_lnk = toolkit_dir / "SP Flash Tool.lnk"
            
            if not sp_flash_tool_lnk.exists():
                QMessageBox.critical(
                    self,
                    "SP Flash Tool Console Mode Not Found",
                    "SP Flash Tool.lnk not found in Toolkit directory. Please ensure it's properly installed."
                )
                return
            
            # Show dialog with Method 3 Console Mode instructions
            reply = QMessageBox.question(
                self,
                "SP Flash Tool Console Mode",
                "SP Flash Tool Console Mode will now launch.\n\n"
                "Power off your Y1:\n"
                "Make sure is NOT connected then, Press OK.\n\n"
                "Then follow the on screen instructions...\n\n"
                "Powering Off: You can also insert a pin/paper clip in the hole on the bottom).\n\n"
                "This method launches the SP Flash Tool console interface.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                return
            
            # Launch SP Flash Tool.lnk from Toolkit directory using proper Windows method
            try:
                # Use os.startfile() to properly launch .lnk files on Windows
                import os
                os.startfile(str(sp_flash_tool_lnk))
                silent_print(f"Launched SP Flash Tool Console Mode: {sp_flash_tool_lnk}")
                
                # Show success message
                QMessageBox.information(
                    self,
                    "SP Flash Tool Console Mode Launched",
                    "SP Flash Tool Console Mode has been launched successfully.\n\n"
                    "Please follow the instructions in the SP Flash Tool window to complete the installation."
                )
                
                # Revert to ready and presteps.png state after successful launch
                self.revert_to_startup_state()
                
            except Exception as e:
                silent_print(f"Error launching SP Flash Tool Console Mode: {e}")
                QMessageBox.critical(
                    self,
                    "Launch Error",
                    f"Failed to launch SP Flash Tool Console Mode:\n\n{e}"
                )
            
        except Exception as e:
            silent_print(f"Error in SP Flash Tool Console Mode method: {e}")
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred: {e}"
            )

    def load_method2_image(self):
        """Load Method 2 troubleshooting image"""
        try:
            if not hasattr(self, '_method2_pixmap'):
                image_path = self.get_platform_image_path("method2")
                self._method2_pixmap = QPixmap(image_path)
                if self._method2_pixmap.isNull():
                    silent_print(f"Failed to load Method 2 image from {image_path}")
                    return
            
            self._current_pixmap = self._method2_pixmap
            self.set_image_with_aspect_ratio(self._method2_pixmap)
        except Exception as e:
            silent_print(f"Error loading Method 2 image: {e}")
            return

    def load_method3_image(self):
        """Load Method 3 SP Flash Tool initsteps image"""
        try:
            if not hasattr(self, '_method3_pixmap'):
                # Use initsteps_sp.png directly (Windows-only method, no platform suffix needed)
                image_path = Path("mtkclient/gui/images/initsteps_sp.png")
                self._method3_pixmap = QPixmap(str(image_path))
                if self._method3_pixmap.isNull():
                    silent_print(f"Failed to load Method 3 SP Flash Tool image from {image_path}")
                    return
            
            self._current_pixmap = self._method3_pixmap
            self.set_image_with_aspect_ratio(self._method3_pixmap)
        except Exception as e:
            silent_print(f"Error loading Method 3 SP Flash Tool image: {e}")

    def load_installed_image(self):
        """Load installed completion image"""
        try:
            if not hasattr(self, '_installed_pixmap'):
                image_path = self.get_platform_image_path("installed")
                self._installed_pixmap = QPixmap(image_path)
                if self._installed_pixmap.isNull():
                    silent_print(f"Failed to load installed image from {image_path}")
                    return
            
            self._current_pixmap = self._installed_pixmap
            self.set_image_with_aspect_ratio(self._installed_pixmap)
        except Exception as e:
            silent_print(f"Error loading installed image: {e}")
            return

    def load_please_wait_image(self):
        """Load please wait image"""
        try:
            if not hasattr(self, '_please_wait_pixmap'):
                image_path = self.get_platform_image_path("please_wait")
                self._please_wait_pixmap = QPixmap(image_path)
                if self._please_wait_pixmap.isNull():
                    silent_print(f"Failed to load please wait image from {image_path}")
                    return
            
            self._current_pixmap = self._please_wait_pixmap
            self.set_image_with_aspect_ratio(self._please_wait_pixmap)
        except Exception as e:
            silent_print(f"Error loading please wait image: {e}")
            return

    def load_method4_image(self):
        """Load SP Flash Tool GUI Method image"""
        try:
            if not hasattr(self, '_method4_pixmap'):
                # Try method4.png first, fallback to method3.png if not found
                image_path = self.get_platform_image_path("method4")
                self._method4_pixmap = QPixmap(image_path)
                if self._method4_pixmap.isNull():
                    silent_print(f"SP Flash Tool GUI Method image not found, trying fallback to method3.png")
                    # Fallback to method3.png
                    fallback_path = self.get_platform_image_path("method3")
                    self._method4_pixmap = QPixmap(fallback_path)
                    if self._method4_pixmap.isNull():
                        silent_print(f"Failed to load SP Flash Tool GUI Method fallback image from {fallback_path}")
                        return
            
            self._current_pixmap = self._method4_pixmap
            self.set_image_with_aspect_ratio(self._method4_pixmap)
        except Exception as e:
            silent_print(f"Error loading SP Flash Tool GUI Method image: {e}")
            return

    def start_data_loader_worker(self):
        """Start data loader in worker thread to avoid blocking UI"""
        try:
            self.status_label.setText("Loading configuration...")
            silent_print("Loading configuration and manifest data...")

            # Stop any existing data loader worker
            if hasattr(self, 'data_loader_worker') and self.data_loader_worker:
                try:
                    old_worker = self.data_loader_worker
                    if old_worker.isRunning():
                        old_worker.stop()
                        # Disconnect signals first
                        try:
                            old_worker.data_loaded.disconnect()
                            old_worker.loading_failed.disconnect()
                        except:
                            pass
                        # Let it clean up asynchronously (non-blocking)
                        def cleanup_worker():
                            try:
                                if not old_worker.isRunning():
                                    old_worker.deleteLater()
                            except:
                                pass
                        old_worker.finished.connect(cleanup_worker)
                    else:
                        old_worker.deleteLater()
                except:
                    pass
                self.data_loader_worker = None
            
            # Initialize github_api with empty tokens immediately (works offline too)
            self.github_api = GitHubAPI([])
            silent_print("Initialized GitHub API with empty tokens for instant startup")
            
            # Create and start worker thread
            self.data_loader_worker = DataLoaderWorker(self.config_downloader)
            self.data_loader_worker.setParent(self)  # Parent to main window for proper cleanup
            
            # Connect signals
            self.data_loader_worker.data_loaded.connect(
                self.on_data_loaded, 
                Qt.ConnectionType.QueuedConnection
            )
            self.data_loader_worker.loading_failed.connect(
                self.on_data_loading_failed, 
                Qt.ConnectionType.QueuedConnection
            )
            
            # Connect finished signal for cleanup
            worker_ref = self.data_loader_worker
            def cleanup_worker():
                if hasattr(self, 'data_loader_worker') and self.data_loader_worker == worker_ref:
                    try:
                        if not self.data_loader_worker.isRunning():
                            self.data_loader_worker.deleteLater()
                    except:
                        pass
            
            self.data_loader_worker.finished.connect(cleanup_worker)
            self.data_loader_worker.start()
            
            silent_print("Started data loader in background thread")
        except Exception as e:
            silent_print(f"Error starting data loader worker: {e}")
            # Fallback to offline mode if worker fails to start
            self.on_data_loaded([])
    
    def on_data_loaded(self, packages):
        """Handle data loaded from worker thread"""
        try:
            self.packages = packages
            
            if self.packages:
                silent_print(f"Loaded {len(self.packages)} software packages from local manifest")
                self.status_label.setText("Ready: Select system software to Download. Your music will stay safe.")
                
                # Populate UI components immediately
                self.populate_device_type_combo()
                self.populate_device_model_combo()
                self.populate_firmware_combo()
                # Skip filter_firmware_options - it causes blocking network calls during startup
                # self.filter_firmware_options()  # DISABLED for instant startup
                # Delay release loading slightly to ensure offline message is shown first
                QTimer.singleShot(50, self.apply_initial_release_display)
                self.status_label.setText("Ready")
                silent_print("Data loading complete - instant startup achieved")
            else:
                # No packages (offline mode) - still initialize UI
                silent_print("No packages loaded - app is running in offline mode")
                self.status_label.setText("Ready: Use 'Browse Files' to install firmware from local files")
                
                # Initialize empty dropdowns so app doesn't crash
                self.populate_device_type_combo()
                self.populate_device_model_combo()
                self.populate_firmware_combo()
                
                # Show offline message immediately
                QTimer.singleShot(50, self._show_initial_offline_state)
                silent_print("App initialized in offline mode - ready for local file installation")
        
        # Start background token validation and remote manifest refresh (reduced delay for faster startup)
            # This is non-blocking and will gracefully fail if offline - runs in worker thread
            QTimer.singleShot(25, self.start_token_loader_worker)
        except Exception as e:
            silent_print(f"Error handling loaded data: {e}")
            # Fallback to offline mode
            self.on_data_loading_failed(str(e))
    
    def on_data_loading_failed(self, error_msg):
        """Handle data loading failure"""
        try:
            silent_print(f"Data loading failed: {error_msg}")
            # Fallback to offline mode
            self.packages = []
            self.github_api = GitHubAPI([])
            
            # Initialize empty dropdowns so app doesn't crash
            self.populate_device_type_combo()
            self.populate_device_model_combo()
            self.populate_firmware_combo()
            
            # Show offline message immediately
            QTimer.singleShot(50, self._show_initial_offline_state)
            self.status_label.setText("Ready: Use 'Browse Files' to install firmware from local files")
            silent_print("App initialized in offline mode due to loading failure")
        except Exception as e:
            silent_print(f"Error handling data loading failure: {e}")

    def start_token_loader_worker(self):
        """Start token loader in worker thread to avoid blocking UI"""
        try:
            # Stop any existing token loader worker (non-blocking)
            if hasattr(self, 'token_loader_worker') and self.token_loader_worker:
                try:
                    old_worker = self.token_loader_worker
                    if old_worker.isRunning():
                        old_worker.stop()
                        # Disconnect signals first
                        try:
                            old_worker.tokens_loaded.disconnect()
                            old_worker.loading_failed.disconnect()
                        except:
                            pass
                        # Let it clean up asynchronously (non-blocking)
                        def cleanup_worker():
                            try:
                                if not old_worker.isRunning():
                                    old_worker.deleteLater()
                            except:
                                pass
                        old_worker.finished.connect(cleanup_worker)
                    else:
                        old_worker.deleteLater()
                except:
                    pass
                self.token_loader_worker = None
            
            # Create and start worker thread
            self.token_loader_worker = TokenLoaderWorker(self.config_downloader)
            self.token_loader_worker.setParent(self)  # Parent to main window for proper cleanup
            
            # Connect signals
            self.token_loader_worker.tokens_loaded.connect(
                self.on_tokens_loaded, 
                Qt.ConnectionType.QueuedConnection
            )
            self.token_loader_worker.loading_failed.connect(
                self.on_tokens_loading_failed, 
                Qt.ConnectionType.QueuedConnection
            )
            
            # Connect finished signal for cleanup
            worker_ref = self.token_loader_worker
            def cleanup_worker():
                if hasattr(self, 'token_loader_worker') and self.token_loader_worker == worker_ref:
                    try:
                        if not self.token_loader_worker.isRunning():
                            self.token_loader_worker.deleteLater()
                    except:
                        pass
            
            self.token_loader_worker.finished.connect(cleanup_worker)
            self.token_loader_worker.start()
            
            silent_print("Started token loader in background thread")
        except Exception as e:
            silent_print(f"Error starting token loader worker: {e}")
    
    def on_tokens_loaded(self, tokens):
        """Handle tokens loaded from worker thread"""
        try:
            if not tokens:
                silent_print("No API tokens available - using unauthenticated mode")
                return

            # Replace the empty GitHubAPI with properly initialized one
            self.github_api = GitHubAPI(tokens)
            silent_print(f"Loaded {len(tokens)} API tokens")

            # Start parallel token validation in background (this is already in a thread pool)
            if tokens:
                silent_print(f"Validating {len(tokens)} API tokens in background...")
                # Start parallel token validation (uses ThreadPoolExecutor, non-blocking)
                self.validate_tokens_parallel(tokens)

            # Retry loading releases now that we have tokens (for instant cached display when online)
            # This allows cached releases to show instantly when tokens are loaded
            QTimer.singleShot(100, self.populate_releases_list)
        except Exception as e:
            silent_print(f"Error handling loaded tokens: {e}")
    
    def on_tokens_loading_failed(self, error_msg):
        """Handle token loading failure"""
        silent_print(f"Token loading failed: {error_msg}")
        # Continue with unauthenticated mode - app will work fine

    def validate_tokens_parallel(self, tokens):
        """Validate tokens in parallel for faster startup"""
        if not tokens:
            silent_print("No tokens to validate, using unauthenticated mode")
            # Don't update status label - keep it as "Ready" for user experience
            self.finish_data_loading([])
            return

        def validate_single_token(token):
            """Validate a single token"""
            try:
                # Check if token already has prefix to avoid double-prefixing
                if token.startswith('github_pat_'):
                    test_token = token
                else:
                    test_token = f"github_pat_{token}"
                silent_print(f"Testing token: {test_token[:20]}...")

                headers = {
                    'Authorization': f'token {test_token}',
                    'Accept': 'application/vnd.github.v3+json'
                }

                response = requests.get('https://api.github.com/user',
                                      headers=headers,
                                      timeout=TOKEN_VALIDATION_TIMEOUT)

                silent_print(f"Token validation response: {response.status_code}")

                if response.status_code == 200:
                    user_data = response.json()
                    silent_print(f"Token valid - authenticated as: {user_data.get('login', 'Unknown')}")
                    return token, user_data.get('login', 'Unknown')
                elif response.status_code == 401:
                    silent_print(f"Token invalid (401 Unauthorized)")
                    return None, None
                elif response.status_code == 403:
                    silent_print(f"Token rate limited (403 Forbidden) - will retry later")
                    # Don't mark rate-limited tokens as invalid, they might work later
                    return None, None
                else:
                    silent_print(f"Token failed - status: {response.status_code}")
                    return None, None

            except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
                # Network error - offline or connection failed (non-blocking)
                silent_print(f"Token validation network error (offline?): {e}")
                return None, None
            except Exception as e:
                silent_print(f"Token validation error: {e}")
                return None, None

        # Use ThreadPoolExecutor for parallel validation
        with ThreadPoolExecutor(max_workers=min(len(tokens), MAX_CONCURRENT_REQUESTS)) as executor:
            # Submit all token validation tasks
            future_to_token = {executor.submit(validate_single_token, token): token for token in tokens}

            # Process results as they complete
            for future in as_completed(future_to_token):
                token, username = future.result()
                if token is not None:
                    # Found a working token, cancel other tasks and proceed
                    silent_print(f"Found working token for user: {username}")
                    # Don't update status label - keep it as "Ready" for user experience

                    # Cancel remaining tasks
                    for remaining_future in future_to_token:
                        if not remaining_future.done():
                            remaining_future.cancel()

                    # Mark token as working and proceed
                    self.github_api.mark_token_working(token)
                    silent_print("Background token validation completed - authenticated mode enabled")
                    return

        # If we get here, no tokens worked
        silent_print("All tokens failed validation, using unauthenticated mode")
        # Try with at least one token anyway, in case validation was too strict
        if tokens:
            silent_print("Attempting to use first token despite validation failure")
            # Check if token already has prefix to avoid double-prefixing
            first_token = tokens[0]
            if not first_token.startswith('github_pat_'):
                first_token = f"github_pat_{first_token}"
            self.github_api = GitHubAPI([first_token])
            silent_print("Background token validation completed - fallback mode enabled")
        else:
            silent_print("Background token validation completed - unauthenticated mode enabled")

    def finish_data_loading(self, working_tokens):
        """Complete data loading with working tokens"""
        self.status_label.setText("Loading software manifest...")

        # Ensure all tokens have github_pat_ prefix for GitHub API class
        api_tokens = []
        for token in working_tokens:
            if not token.startswith('github_pat_'):
                api_tokens.append(f"github_pat_{token}")
            else:
                api_tokens.append(token)

        silent_print(f"Prepared {len(api_tokens)} tokens for GitHub API")
        for i, token in enumerate(api_tokens):
            silent_print(f"Token {i+1}: {token[:20]}...")

        # Create GitHub API with properly formatted tokens
        self.github_api = GitHubAPI(api_tokens)
        
        # Start periodic cache cleanup
        self.github_api.cleanup_cache_periodically()

        # Download manifest (local-first for instant startup)
        self.packages = self.config_downloader.download_manifest(use_local_first=True)
        if not self.packages:
            silent_print("ERROR: Failed to load software manifest")
            self.status_label.setText("Error: Failed to load software manifest")
            return

        silent_print(f"Loaded {len(self.packages)} software packages")
        self.status_label.setText("Ready: Select system software to Download. Your music will stay safe.")

        # Populate UI components
        self.populate_device_type_combo()
        self.populate_device_model_combo()
        self.populate_firmware_combo()

        # Apply initial filters
        self.filter_firmware_options()

        # Use a timer to ensure the default selection is properly applied
        QTimer.singleShot(100, self.apply_initial_release_display)

        # Native widgets automatically adapt to theme changes - no timer needed

        self.status_label.setText("Ready")
        silent_print("Data loading complete")

    def apply_initial_release_display(self):
        """Apply the initial release display based on default software selection"""
        selected_repo = self.firmware_combo.currentData()
        if selected_repo:
            # Show releases for selected software
            self.populate_releases_list()
        else:
            # Show releases from all available software progressively
            self.populate_all_releases_list_progressive()

    def show_device_type_help(self):
        """Show device type help information in a dialog box"""
        help_text = """<h3>Device Type Selection Guide</h3>

<p><b>Type A Devices:</b> This is the recommended starting point for most users. Install this first to see if it meets your needs.</p>

<p><b>Type B Devices:</b> If your scroll wheel doesn't respond properly after installing Type A, try one of the Type B options. These are alternative configurations that may resolve scroll wheel issues.</p>

<p><b>Recommendation:</b> Always start with Type A. Only move to Type B if you experience scroll wheel problems.</p>"""

        # Create a native system dialog box
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Device Type Help")
        msg_box.setText(help_text)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.setDefaultButton(QMessageBox.Ok)

        # Ensure it uses native system styling
        msg_box.setModal(True)
        msg_box.exec()

    def open_y1_remote_control(self):
        """Open Y1 Remote Control application without closing firmware downloader"""
        print("DEBUG: Tools button clicked! open_y1_remote_control method called.")
        
        # Check if any operations are in progress
        if INSTALLATION_MARKER_FILE.exists():
            print("DEBUG: Installation marker exists, showing warning.")
            QMessageBox.warning(self, "Operation in Progress", 
                              "Cannot open Y1 Helper while firmware installation or troubleshooting is in progress.\n\nPlease wait for the current operation to complete.")
            return
        
        try:
            if platform.system() == "Windows":
                # On Windows, use the Toolkit shortcut to get separate process/taskbar icon
                toolkit_shortcut = Path("Toolkit") / "Remote Control.lnk"
                if toolkit_shortcut.exists():
                    subprocess.Popen([str(toolkit_shortcut)], shell=True)
                    self.status_label.setText("Y1 Remote Control launched successfully")
                else:
                    # Fallback to direct y1_helper.py if shortcut not found
                    y1_helper_path = Path("y1_helper.py")
                    if y1_helper_path.exists():
                        subprocess.Popen([sys.executable, str(y1_helper_path)])
                        self.status_label.setText("Y1 Remote Control launched successfully")
                    else:
                        QMessageBox.error(self, "Error", 
                                        "Y1 Remote Control not found. Please ensure y1_helper.py is in the same directory.")
            else:
                # On non-Windows systems, use direct Python execution
                y1_helper_path = Path("y1_helper.py")
                if y1_helper_path.exists():
                    subprocess.Popen([sys.executable, str(y1_helper_path)])
                    self.status_label.setText("Y1 Remote Control launched successfully")
                else:
                    QMessageBox.error(self, "Error", 
                                    "Y1 Remote Control not found. Please ensure y1_helper.py is in the same directory.")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to launch Y1 Remote Control: {e}")

    def try_new_features(self, dialog=None):
        """Run local copy of test.py for trying new features"""
        try:
            # Close the dialog if provided
            if dialog:
                dialog.accept()
            
            # On Windows, check for shortcut in Toolkit folder first
            if platform.system() == "Windows":
                current_dir = Path.cwd()
                toolkit_dir = current_dir / "Toolkit"
                try_new_features_lnk = toolkit_dir / "Try New Features.lnk"
                
                if try_new_features_lnk.exists():
                    # Use the shortcut to launch test.py
                    silent_print(f"Found Try New Features shortcut: {try_new_features_lnk}")
                    subprocess.Popen([str(try_new_features_lnk)], shell=True)
                    self.status_label.setText("Launching new features version...")
                    # Terminate current instance after a short delay
                    QTimer.singleShot(1000, self.close)
                    return
            
            # Check for local copy of test.py
            test_path = Path("test.py")
            
            if not test_path.exists():
                QMessageBox.warning(
                    self,
                    "test.py Not Found",
                    "test.py not found in the current directory.\n\n"
                    "Please ensure test.py is present before using this feature."
                )
                return
            
            # Launch local copy of test.py
            self.status_label.setText("Launching new features version...")
            QApplication.processEvents()
            
            if platform.system() == "Windows":
                # On Windows, use pythonw if available to avoid console window
                python_exe = sys.executable
                if python_exe.endswith("python.exe"):
                    pythonw_exe = python_exe.replace("python.exe", "pythonw.exe")
                    if Path(pythonw_exe).exists():
                        python_exe = pythonw_exe
                
                subprocess.Popen([python_exe, str(test_path)], creationflags=subprocess.CREATE_NO_WINDOW)
            else:
                # On macOS/Linux, use regular Python
                subprocess.Popen([sys.executable, str(test_path)])
            
            # Terminate current instance after a short delay
            QTimer.singleShot(1000, self.close)
            
        except Exception as e:
            silent_print(f"Error launching test.py: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            QMessageBox.warning(self, "Error", f"Error launching new features: {str(e)}")

    def open_toolkit_folder(self):
        """Open the Innioasis Toolkit folder in File Explorer (Windows only)"""
        try:
            if platform.system() != "Windows":
                return
            
            # Open the actual Toolkit folder in %LocalAppData%\Innioasis Updater\Toolkit
            toolkit_path = Path.home() / "AppData" / "Local" / "Innioasis Updater" / "Toolkit"
            
            if toolkit_path.exists():
                # Open the folder in File Explorer
                subprocess.run(["explorer", str(toolkit_path)], check=True)
                self.status_label.setText("Toolkit folder opened in File Explorer")
            else:
                QMessageBox.warning(self, "Toolkit Not Found", 
                                  f"Toolkit folder not found at:\n{toolkit_path}\n\nPlease ensure the toolkit is properly installed.")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to open toolkit folder: {e}")
    
    def launch_240p_theme_downloader(self):
        """Launch the 240p theme downloader"""
        try:
            script_path = Path("rockbox_240p_theme_downloader.py")
            if script_path.exists():
                subprocess.Popen([sys.executable, str(script_path)])
                self.status_label.setText("240p Theme Downloader launched")
            else:
                QMessageBox.warning(self, "File Not Found", 
                                  "240p Theme Downloader not found. Please ensure rockbox_240p_theme_downloader.py is in the same directory.")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to launch 240p Theme Downloader: {e}")
    
    def launch_360p_theme_downloader(self):
        """Launch the 360p theme downloader"""
        try:
            script_path = Path("rockbox_360p_theme_downloader.py")
            if script_path.exists():
                subprocess.Popen([sys.executable, str(script_path)])
                self.status_label.setText("360p Theme Downloader launched")
            else:
                QMessageBox.warning(self, "File Not Found", 
                                  "360p Theme Downloader not found. Please ensure rockbox_360p_theme_downloader.py is in the same directory.")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to launch 360p Theme Downloader: {e}")
    
    def open_original_y1_menu_themes(self):
        """Open Original Y1 Menu Themes in browser"""
        try:
            import webbrowser
            webbrowser.open("https://themes.innioasis.app")
            self.status_label.setText("Opened Original Y1 Menu Themes in browser")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to open Original Y1 Menu Themes: {e}")
    
    def open_240p_rockbox_themes(self):
        """Open 240p Rockbox Themes in browser"""
        try:
            import webbrowser
            webbrowser.open("https://themes.rockbox.org/index.php?target=ipodvideo")
            self.status_label.setText("Opened 240p Rockbox Themes in browser")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to open 240p Rockbox Themes: {e}")
    
    def open_360p_rockbox_themes(self):
        """Open 360p Rockbox Themes in browser"""
        try:
            import webbrowser
            webbrowser.open("https://www.github.com/rockbox-y1/themes/releases/latest")
            self.status_label.setText("Opened 360p Rockbox Themes in browser")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to open 360p Rockbox Themes: {e}")
    
    def launch_storage_management_tool(self):
        """Launch the storage management tool"""
        try:
            script_path = Path("manage_storage.py")
            if script_path.exists():
                subprocess.Popen([sys.executable, str(script_path)])
                self.status_label.setText("Storage Management Tool launched")
            else:
                QMessageBox.warning(self, "File Not Found", 
                                  "Storage Management Tool not found. Please ensure manage_storage.py is in the same directory.")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to launch Storage Management Tool: {e}")
    
    def launch_rockbox_utility(self):
        """Launch Rockbox Utility from Toolkit directory"""
        try:
            # Get the LocalAppData path
            local_app_data = os.environ.get('LOCALAPPDATA', '')
            if not local_app_data:
                QMessageBox.warning(self, "Error", "Could not find LocalAppData directory")
                return
            
            # Construct the path to Rockbox Utility.lnk
            rockbox_utility_path = Path(local_app_data) / "Innioasis Updater" / "Toolkit" / "Rockbox Utility.lnk"
            
            if rockbox_utility_path.exists():
                # Launch the shortcut
                subprocess.Popen([str(rockbox_utility_path)])
                self.status_label.setText("Rockbox Utility launched")
            else:
                QMessageBox.warning(self, "File Not Found", 
                                  f"Rockbox Utility not found at:\n{rockbox_utility_path}\n\nPlease ensure the Toolkit is properly installed.")
        except Exception as e:
            QMessageBox.error(self, "Error", f"Failed to launch Rockbox Utility: {e}")
    
    def show_settings_dialog(self, initial_tab="updates", auto_download_latest=False):
        """Show enhanced settings dialog with installation method and shortcut management."""
        # 2025-11-09 22:45 UTC original signature: def show_settings_dialog(self, initial_tab="about")
        # Updated default to open the Version tab first, matching the new UX requirement.
        silent_print(f"Opening settings dialog with initial_tab: {initial_tab}")
        dialog = QDialog(self)
        dialog.setWindowTitle("Settings")
        dialog.resize(960, 760)
        dialog.setMinimumSize(720, 600)
        dialog.setModal(True)
        # Use native styling - no custom stylesheet for automatic theme adaptation
        self._active_settings_dialog = dialog
        self._pending_auto_download_latest = auto_download_latest
        
        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(16, 16, 16, 16)
        layout.setSpacing(12)
        
        # Create tabbed interface or sections
        tab_widget = QTabWidget()
        tab_widget.setIconSize(QSize(12, 12))
        tab_widget.setDocumentMode(True)
        tab_widget.setElideMode(Qt.ElideRight)
        # Use native styling - no custom stylesheet for automatic theme adaptation
        layout.addWidget(tab_widget)
        self._active_settings_tab_widget = tab_widget
        update_available = bool(self.app_update_available and self._latest_app_version)
        self._current_update_checkbox = None
        
        # Installation Method Tab
        install_tab = QWidget()
        install_layout = QVBoxLayout(install_tab)
        install_layout.setSpacing(8)
        install_layout.setContentsMargins(10, 10, 10, 10)
        
        show_install_tab = not self.is_windows_arm64
        driver_info = None
        if platform.system() == "Windows":
            driver_info = self.check_drivers_and_architecture()
            if driver_info.get('is_arm64'):
                show_install_tab = False
        
        self.method_combo = None
        
        if show_install_tab:
            if platform.system() == "Windows" and driver_info:
                if not driver_info['can_install_firmware'] and not driver_info.get('has_mtk_driver') and not driver_info.get('has_usbdk_driver'):
                    status_label = QLabel("‚ö†Ô∏è No Specific Drivers Detected")
                    status_label.setStyleSheet("color: #FF6B35; font-weight: bold; margin: 2px;")
                    install_layout.addWidget(status_label)
                    
                    status_desc = QLabel("No specific drivers detected. Fallback methods are available below.\n\nMore methods will become available if you install the appropriate drivers.")
                    status_desc.setStyleSheet("color: #666; margin: 2px;")
                    install_layout.addWidget(status_desc)
                
            desc_label = QLabel("This setting will be used for the next firmware installation.")
            desc_label.setStyleSheet("margin: 2px;")
            install_layout.addWidget(desc_label)
            
            method_label = QLabel("Installation Method:")
            install_layout.addWidget(method_label)
            
            self.method_combo = QComboBox()
            
            if platform.system() == "Windows" and driver_info:
                if driver_info['has_mtk_driver'] and driver_info['has_usbdk_driver']:
                    seasonal_emoji = get_seasonal_emoji_random()
                    method1_text = f"Method 1 - Guided{seasonal_emoji}" if seasonal_emoji else "Method 1 - Guided"
                    method2_text = f"Method 2 - SP Flash Tool GUI{seasonal_emoji}" if seasonal_emoji else "Method 2 - SP Flash Tool GUI"
                    method3_text = f"Method 3 - SP Flash Tool Console Mode{seasonal_emoji}" if seasonal_emoji else "Method 3 - SP Flash Tool Console Mode"
                    method4_text = f"SP Flash Tool GUI Method{seasonal_emoji}" if seasonal_emoji else "SP Flash Tool GUI Method"
                    method5_text = f"Method 5 - MTKclient (advanced){seasonal_emoji}" if seasonal_emoji else "Method 5 - MTKclient (advanced)"
                    
                    self.method_combo.addItem(method1_text, "spflash")
                    self.method_combo.addItem(method2_text, "spflash4")
                    self.method_combo.addItem(method3_text, "spflash_console")
                    self.method_combo.addItem(method4_text, "guided")
                    self.method_combo.addItem(method5_text, "mtkclient")
                elif driver_info['has_mtk_driver'] and not driver_info['has_usbdk_driver']:
                    seasonal_emoji = get_seasonal_emoji_random()
                    method1_text = f"Method 1 - Guided (Only available method){seasonal_emoji}" if seasonal_emoji else "Method 1 - Guided (Only available method)"
                    method2_text = f"Method 2 - SP Flash Tool GUI{seasonal_emoji}" if seasonal_emoji else "Method 2 - SP Flash Tool GUI"
                    method3_text = f"Method 3 - SP Flash Tool Console Mode{seasonal_emoji}" if seasonal_emoji else "Method 3 - SP Flash Tool Console Mode"
                    
                    self.method_combo.addItem(method1_text, "spflash")
                    self.method_combo.addItem(method2_text, "spflash4")
                    self.method_combo.addItem(method3_text, "spflash_console")
                elif not driver_info['has_mtk_driver'] and driver_info['has_usbdk_driver']:
                    available_methods = driver_info.get('available_methods', ['guided', 'mtkclient'])
                    if available_methods:
                        seasonal_emoji = get_seasonal_emoji_random()
                        for method in available_methods:
                            if method == 'guided':
                                method_text = f"Method 1 - Guided (Default){seasonal_emoji}" if seasonal_emoji else "Method 1 - Guided (Default)"
                                self.method_combo.addItem(method_text, "guided")
                            elif method == 'mtkclient':
                                method_text = f"Method 2 - MTKclient (Advanced){seasonal_emoji}" if seasonal_emoji else "Method 2 - MTKclient (Advanced)"
                                self.method_combo.addItem(method_text, "mtkclient")
                else:
                    available_methods = driver_info.get('available_methods', ['guided', 'mtkclient'])
                    if available_methods:
                        seasonal_emoji = get_seasonal_emoji_random()
                        for method in available_methods:
                            if method == 'guided':
                                method_text = f"Method 1 - Guided (Default){seasonal_emoji}" if seasonal_emoji else "Method 1 - Guided (Default)"
                                self.method_combo.addItem(method_text, "guided")
                            elif method == 'mtkclient':
                                method_text = f"Method 2 - MTKclient (Advanced){seasonal_emoji}" if seasonal_emoji else "Method 2 - MTKclient (Advanced)"
                                self.method_combo.addItem(method_text, "mtkclient")
                    else:
                        self.method_combo.addItem("Method 1 - Guided (Fallback)", "guided")
            else:
                seasonal_emoji = get_seasonal_emoji_random()
                method1_text = f"Method 1 - Guided{seasonal_emoji}" if seasonal_emoji else "Method 1 - Guided"
                method2_text = f"Method 2 - in Terminal{seasonal_emoji}" if seasonal_emoji else "Method 2 - in Terminal"
                
                self.method_combo.addItem(method1_text, "guided")
                self.method_combo.addItem(method2_text, "mtkclient")
            
            current_method = getattr(self, 'installation_method', 'guided')
            if platform.system() == "Windows" and driver_info and not driver_info.get('has_mtk_driver'):
                current_method = 'guided'
                silent_print("No MTK driver detected, defaulting to guided method")
            
            index = self.method_combo.findData(current_method)
            if index >= 0:
                self.method_combo.setCurrentIndex(index)
            
            install_layout.addWidget(self.method_combo)
            tab_widget.addTab(install_tab, "Installation")
        else:
            self.method_combo = None
        
        # Shortcut Management Tab (Windows only)
        if platform.system() == "Windows":
            shortcut_tab = QWidget()
            shortcut_layout = QVBoxLayout(shortcut_tab)
            
            shortcut_title = QLabel("Shortcut Management")
            shortcut_title.setStyleSheet("font-size: 14px; font-weight: bold; margin: 5px;")
            shortcut_layout.addWidget(shortcut_title)
            
            # Desktop shortcuts section
            desktop_group = QGroupBox("Desktop Shortcuts")
            desktop_layout = QVBoxLayout(desktop_group)
            
            self.desktop_updater_checkbox = QCheckBox("Updater")
            self.desktop_updater_checkbox.setToolTip("Create Innioasis Updater shortcut on desktop")
            desktop_updater = getattr(self, 'desktop_updater_enabled', True)
            self.desktop_updater_checkbox.setChecked(desktop_updater)
            self.desktop_updater_checkbox.toggled.connect(self.on_desktop_updater_toggled)
            desktop_layout.addWidget(self.desktop_updater_checkbox)
            
            self.desktop_toolkit_checkbox = QCheckBox("Toolkit")
            self.desktop_toolkit_checkbox.setToolTip("Create Innioasis Toolkit shortcut on desktop")
            desktop_toolkit = getattr(self, 'desktop_toolkit_enabled', False)  # Default to False for desktop
            self.desktop_toolkit_checkbox.setChecked(desktop_toolkit)
            self.desktop_toolkit_checkbox.toggled.connect(self.on_desktop_toolkit_toggled)
            desktop_layout.addWidget(self.desktop_toolkit_checkbox)
            
            shortcut_layout.addWidget(desktop_group)
            
            # Start menu shortcuts section
            startmenu_group = QGroupBox("Start Menu Shortcuts")
            startmenu_layout = QVBoxLayout(startmenu_group)
            
            self.startmenu_updater_checkbox = QCheckBox("Updater")
            self.startmenu_updater_checkbox.setToolTip("Create Innioasis Updater shortcut in start menu")
            startmenu_updater = getattr(self, 'startmenu_updater_enabled', True)
            self.startmenu_updater_checkbox.setChecked(startmenu_updater)
            self.startmenu_updater_checkbox.toggled.connect(self.on_startmenu_updater_toggled)
            startmenu_layout.addWidget(self.startmenu_updater_checkbox)
            
            self.startmenu_toolkit_checkbox = QCheckBox("Toolkit")
            self.startmenu_toolkit_checkbox.setToolTip("Create Innioasis Toolkit shortcut in start menu")
            startmenu_toolkit = getattr(self, 'startmenu_toolkit_enabled', True)
            self.startmenu_toolkit_checkbox.setChecked(startmenu_toolkit)
            self.startmenu_toolkit_checkbox.toggled.connect(self.on_startmenu_toolkit_toggled)
            startmenu_layout.addWidget(self.startmenu_toolkit_checkbox)
            
            shortcut_layout.addWidget(startmenu_group)
            
            # Note: Automatic cleanup is always enabled and not exposed to users
            # as it's required for proper shortcut management
            
            # Add shortcut tab to tab widget
            shortcuts_tab_index = tab_widget.addTab(shortcut_tab, "Shortcuts")
        
        # About Tab
        about_tab = QWidget()
        # Use native styling - no custom stylesheet for automatic theme adaptation
        about_layout = QVBoxLayout(about_tab)
        about_layout.setAlignment(Qt.AlignCenter)
        
        # App icon (load from mtkclient/gui/images/icon.png)
        icon_label = QLabel()
        icon_path = Path("mtkclient/gui/images/icon.png")
        if icon_path.exists():
            try:
                pixmap = QPixmap(str(icon_path))
                # Scale the icon to a larger size for better visibility
                scaled_pixmap = pixmap.scaled(80, 80, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                icon_label.setPixmap(scaled_pixmap)
            except Exception as e:
                # Fallback to emoji if icon loading fails
                icon_label.setText("üì±")
                icon_label.setStyleSheet("""
                    QLabel {
                        font-size: 80px;
                        color: #007AFF;
                        margin: 20px;
                    }
                """)
        else:
            # Fallback to emoji if icon file doesn't exist
            icon_label.setText("üì±")
            icon_label.setStyleSheet("""
                QLabel {
                    font-size: 64px;
                    color: #007AFF;
                    margin: 20px;
                }
            """)
        icon_label.setAlignment(Qt.AlignCenter)
        icon_label.setFixedHeight(100)  # Ensure enough space for the icon
        icon_label.setContentsMargins(0, 10, 0, 10)  # Add vertical padding
        about_layout.addWidget(icon_label)
        
        # Determine seasonal message
        if is_christmas_season():
            seasonal_message = "üéÑ Merry Christmas! üéÖ"
        elif is_halloween_season():
            seasonal_message = "üéÉ Happy Halloween! üëª"
        elif is_thanksgiving_season() and is_thanksgiving_region():
            seasonal_message = "ü¶É Happy Thanksgiving! üçó"
        elif is_st_patricks_day():
            seasonal_message = "üçÄ Happy St. Patrick's Day! ‚òòÔ∏è"
        elif is_valentines_day():
            seasonal_message = "üíï Happy Valentine's Day! üíñ"
        elif is_easter_season():
            seasonal_message = "üê∞ Happy Easter! üê£"
        elif is_new_years_day():
            seasonal_message = "üéä Happy New Year! üéâ"
        elif is_independence_day() and is_us_user():
            seasonal_message = "üá∫üá∏ Happy Independence Day! üéÜ"
        elif is_summer_solstice():
            seasonal_message = "‚òÄÔ∏è Happy Summer Solstice! üåû"
        else:
            seasonal_message = ""
        
        # App name - use seasonal message as title if available, otherwise use default title
        if seasonal_message:
            app_name_label = QLabel(seasonal_message)
            app_name_label.setStyleSheet("font-size: 20px; font-weight: bold; margin: 18px 10px 10px 10px; color: #FF6B35;")  # Use seasonal color
        else:
            app_name_label = QLabel("Innioasis Updater")
            app_name_label.setStyleSheet("font-size: 20px; font-weight: bold; margin: 18px 10px 10px 10px;")  # Default styling
        app_name_label.setAlignment(Qt.AlignCenter)
        about_layout.addWidget(app_name_label)
        
        # App description
        desc_label = QLabel("Official Firmware Installer created by Y1 users in collaboration with Innioasis")
        desc_label.setStyleSheet("font-size: 12px; margin: 10px;")
        desc_label.setAlignment(Qt.AlignCenter)
        desc_label.setWordWrap(True)
        about_layout.addWidget(desc_label)
        
        # Remove redundant version line - version will be shown in credits
        
        # Special thanks label
        special_thanks_label = QLabel("A special thanks to:")
        special_thanks_label.setStyleSheet("font-size: 12px; font-weight: bold; margin: 10px;")
        special_thanks_label.setAlignment(Qt.AlignCenter)
        about_layout.addWidget(special_thanks_label)
        
        # Credits section with line-by-line display and fade transitions
        credits_container = QWidget()
        credits_container.setFixedHeight(50)  # Single line height
        credits_container.setStyleSheet("""
            QWidget {
                background-color: transparent;
                border: none;
            }
        """)
        
        # Create a container for the credits label
        credits_label_container = QWidget()
        credits_label_container.setFixedHeight(50)  # Single line height
        credits_label_container.setStyleSheet("""
            QWidget {
                background-color: transparent;
                border: none;
            }
        """)
        
        credits_label = QLabel()
        credits_label.setStyleSheet("""
            font-size: 10px;
            margin: 5px;
            padding: 8px;
        """)
        # Set link color to system accent color
        credits_label.setStyleSheet(credits_label.styleSheet() + """
            QLabel a {
                color: palette(highlight);
                text-decoration: none;
            }
            QLabel a:hover {
                color: palette(highlight);
                text-decoration: underline;
            }
        """)
        credits_label.setAlignment(Qt.AlignCenter)
        credits_label.setOpenExternalLinks(True)
        credits_label.setWordWrap(False)  # Disable word wrap for horizontal scrolling
        
        # Use proper layout centering instead of manual geometry
        credits_container_layout = QVBoxLayout(credits_container)
        credits_container_layout.setContentsMargins(0, 0, 0, 0)
        credits_container_layout.setAlignment(Qt.AlignCenter)
        credits_container_layout.addWidget(credits_label)
        
        about_layout.addWidget(credits_container)
        
        # Set up line-by-line display with fade transitions
        self.setup_credits_line_display(credits_label, credits_container)
        
        # Automatic updates are now manual by default - no checkbox needed
        
        # Reddit button - using native styling
        seasonal_emoji = get_seasonal_emoji_random()
        reddit_text = f"üì± r/innioasis{seasonal_emoji}" if seasonal_emoji else "üì± r/innioasis"
        reddit_btn = QPushButton(reddit_text)
        # Use completely native styling - no custom stylesheet
        reddit_btn.setCursor(Qt.PointingHandCursor)
        reddit_btn.clicked.connect(self.open_reddit_link)
        
        # Center the reddit button
        reddit_layout = QHBoxLayout()
        reddit_layout.addStretch()
        reddit_layout.addWidget(reddit_btn)
        reddit_layout.addStretch()
        about_layout.addLayout(reddit_layout)
        
        # Support The Devs button - using native styling
        support_btn = QPushButton("Support The Devs")
        # Use native styling - no custom stylesheet for automatic theme adaptation
        support_btn.setCursor(Qt.PointingHandCursor)  # Keep pointing hand for web link
        support_btn.clicked.connect(self.open_coffee_link)
        
        # Center the support button
        support_layout = QHBoxLayout()
        support_layout.addStretch()
        support_layout.addWidget(support_btn)
        support_layout.addStretch()
        about_layout.addLayout(support_layout)
        
        # Add some spacing
        about_layout.addStretch()
        
        # Wireless ADB Tab (scrollable for smaller displays)
        wireless_scroll = QScrollArea()
        wireless_scroll.setWidgetResizable(True)
        wireless_tab = QWidget()
        wireless_layout = QVBoxLayout(wireless_tab)
        wireless_layout.setSpacing(16)
        wireless_layout.setContentsMargins(16, 16, 16, 16)
        wireless_scroll.setWidget(wireless_tab)
        
# 2025-11-09 12:00:00 - original: QLabel text was 'Wireless Fast Update and Remote Control' without beta designation.
        wireless_title = QLabel("Wireless Fast Update and Remote Control (Beta)")
        wireless_title.setStyleSheet("font-size: 14px; font-weight: bold; margin: 5px;")
        wireless_layout.addWidget(wireless_title)
        
# 2025-11-09 12:00:00 - original: Wireless description did not mention beta state.
        wireless_desc = QLabel("Wireless ADB features are currently in beta. If your device is already connected via ADB Wi-Fi, it will be detected automatically. Otherwise, enter the device's IP address and click Connect.")
        wireless_desc.setStyleSheet("margin: 5px;")
        wireless_desc.setWordWrap(True)
        wireless_layout.addWidget(wireless_desc)
        
        # Check current connection status
        status_label = QLabel("Checking connection status...")
        status_label.setStyleSheet("margin: 5px; font-style: italic;")
        wireless_layout.addWidget(status_label)
        
        # Connect/Disconnect button (will be created below)
        connect_btn = None
        
        # Auto-check for wireless connection (non-blocking, runs in background)
        def check_wireless_connection():
            nonlocal connect_btn
            # Use the unified ADB status method in a background thread to avoid blocking
            adb_path = self.find_adb_executable()
            if not adb_path:
                status_label.setText("ADB not found")
                status_label.setStyleSheet("margin: 5px; color: #666;")
                if connect_btn:
                    connect_btn.setText("Connect")
                return
            
            # Show searching status while checking
            status_label.setText("Checking connection status...")
            status_label.setStyleSheet("margin: 5px; font-style: italic; color: #666;")
            
            # Run check in background thread to prevent UI hang
            def check_in_background():
                try:
                    env = os.environ.copy()
                    if platform.system() == "Darwin":
                        homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                        current_path = env.get("PATH", "")
                        for brew_path in homebrew_paths:
                            if brew_path not in current_path:
                                env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
                    
                    # Use unified ADB status method (blocking=True because we're already off the GUI thread)
                    status, connected_device_id, device_hostname, details = self.get_unified_adb_status(
                        adb_path, env, blocking=True
                    )
                    
                    # Update UI in main thread
                    QTimer.singleShot(0, lambda: update_ui_from_status(status, connected_device_id, device_hostname, details))
                except Exception as e:
                    silent_print(f"Error checking wireless connection: {e}")
                    QTimer.singleShot(0, lambda: status_label.setText("Error checking connection"))
            
            def update_ui_from_status(status, connected_device_id, device_hostname, details):
                try:
                    # Use the status already computed by check_in_background (consistent with main status light)
                    # This ensures both use the same detection logic
                    unified_status = status
                    unified_device_id = connected_device_id
                    unified_hostname = device_hostname
                    
                    target_device_id = "0123456789ABCDEF"
                    metadata = details or {}
                    wireless_device_id = metadata.get('wireless_device_id')
                    usb_device_id = metadata.get('usb_device_id')
                    all_devices = metadata.get('all_devices', []) or []
                    
                    # Determine connection type from unified status and device_id
                    is_wireless_connection = unified_device_id and ':' in unified_device_id
                    is_usb_connection = unified_device_id == target_device_id
                    
                    # Update UI based on unified status (consistent with main ADB status light)
                    if unified_status == 'no_adb':
                        # No ADB connection
                        status_label.setText("Not connected (searching for device...)")
                        status_label.setStyleSheet("margin: 5px; font-style: italic; color: #666;")
                        if connect_btn:
                            connect_btn.setText("Connect")
                    elif unified_status == 'adb_only':
                        # ADB connected but not rooted
                        if is_wireless_connection:
                            host_part = unified_device_id.split(':')[0]
                            connection_method = "hostname" if host_part.startswith('android-') else "IP address"
                            status_label.setText(f"‚úì Wirelessly connected at {host_part}:5555 ({connection_method}) - not rooted")
                            status_label.setStyleSheet("margin: 5px; color: #FFA500; font-weight: bold;")
                            if connect_btn:
                                connect_btn.setText("Disconnect")
                                connect_btn.setProperty("wireless_device_id", unified_device_id)
                            if host_part:
                                self.save_wireless_adb_ip(host_part)
                                if hasattr(self, 'wireless_ip_input'):
                                    self.wireless_ip_input.setText(host_part)
                        elif is_usb_connection:
                            status_label.setText("Connected via USB (not wireless) - not rooted")
                            status_label.setStyleSheet("margin: 5px; color: #666;")
                            if connect_btn:
                                connect_btn.setText("Connect")
                        else:
                            status_label.setText("Connected (not rooted)")
                            status_label.setStyleSheet("margin: 5px; color: #666;")
                            if connect_btn:
                                connect_btn.setText("Connect")
                    elif unified_status == 'adb_root':
                        # ADB connected and rooted - check for update script
                        update_script_exists = False
                        if unified_device_id:
                            try:
                                update_script_path = '/data/data/update/update.sh'
                                check_cmd = [str(adb_path), '-s', unified_device_id, 'shell', f'test -f {update_script_path} && echo exists']
                                check_env = self._build_adb_environment()
                                check_result = subprocess.run(
                                    check_cmd,
                                    capture_output=True,
                                    text=True,
                                    timeout=3,
                                    env=check_env,
                                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                )
                                update_script_exists = (check_result.returncode == 0 and 
                                                       'exists' in check_result.stdout.strip() and
                                                       check_result.stdout.strip() == 'exists')
                            except:
                                pass
                        
                        if is_wireless_connection:
                            host_part = unified_device_id.split(':')[0]
                            connection_method = "hostname" if host_part.startswith('android-') else "IP address"
                            script_status = " (Fast Update ready)" if update_script_exists else " (preparing Fast Update)"
                            status_label.setText(f"‚úì Wirelessly connected at {host_part}:5555 ({connection_method}){script_status}")
                            status_label.setStyleSheet("margin: 5px; color: #00FF00; font-weight: bold;")
                            if connect_btn:
                                connect_btn.setText("Disconnect")
                                connect_btn.setProperty("wireless_device_id", unified_device_id)
                            if host_part:
                                self.save_wireless_adb_ip(host_part)
                                if hasattr(self, 'wireless_ip_input'):
                                    self.wireless_ip_input.setText(host_part)
                        elif is_usb_connection:
                            script_status = " (Fast Update ready)" if update_script_exists else " (preparing Fast Update)"
                            status_label.setText(f"Connected via USB (not wireless){script_status}")
                            status_label.setStyleSheet("margin: 5px; color: #666;")
                            if connect_btn:
                                connect_btn.setText("Connect")
                        else:
                            script_status = " (Fast Update ready)" if update_script_exists else " (preparing Fast Update)"
                            status_label.setText(f"Connected{script_status}")
                            status_label.setStyleSheet("margin: 5px; color: #00FF00; font-weight: bold;")
                            if connect_btn:
                                connect_btn.setText("Connect")
                    else:
                        # Unknown status
                        status_label.setText("Checking connection status...")
                        status_label.setStyleSheet("margin: 5px; font-style: italic; color: #666;")
                        if connect_btn:
                            connect_btn.setText("Connect")
                except Exception as e:
                    silent_print(f"Error updating UI from status: {e}")
                    status_label.setText("Error checking connection")
                    if connect_btn:
                        connect_btn.setText("Connect")
            
            # Run check in background thread
            import threading
            thread = threading.Thread(target=check_in_background, daemon=True)
            thread.start()
        
        # IP Address field (for manual connection)
        ip_group = QGroupBox("Manual Connection (if needed)")
        ip_layout = QVBoxLayout(ip_group)
        
        ip_input_layout = QHBoxLayout()
        ip_label = QLabel("IP Address:")
        ip_input_layout.addWidget(ip_label)
        
        self.wireless_ip_input = QLineEdit()
        # Load saved IP address or hostname
        saved_ip = self.load_wireless_adb_ip()
        if saved_ip:
            self.wireless_ip_input.setText(saved_ip)
        # No default - user must enter IP/hostname or click Connect to auto-detect
        self.wireless_ip_input.setPlaceholderText("IP address or hostname (leave empty to auto-detect)")
        ip_input_layout.addWidget(self.wireless_ip_input)
        
        ip_layout.addLayout(ip_input_layout)
        
        # Connect/Disconnect button
        connect_btn = QPushButton("Connect")
        
        def on_connect_clicked():
            # Check if currently connected
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB executable not found.")
                return
            
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Check current connection status
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Check for wireless connection (IP address OR hostname format)
            target_device_id = "0123456789ABCDEF"
            wireless_connected = False
            wireless_device_id = None
            
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    # Check for wireless connection (IP address OR hostname format like android-XXXXX:5555)
                    if ':' in device_id:
                        parts = device_id.split(':')
                        if len(parts) == 2:
                            host_part = parts[0]
                            
                            # Check if it's an IP address (has dots and 4 numeric parts)
                            is_ip_address = False
                            if '.' in host_part:
                                ip_parts = host_part.split('.')
                                if len(ip_parts) == 4 and all(p.isdigit() for p in ip_parts):
                                    is_ip_address = True
                            
                            # Check if it's a hostname (like android-XXXXX)
                            is_hostname = False
                            if host_part.startswith('android-') and len(host_part) > 8:
                                is_hostname = True
                            
                            # Check if this device has the target ID (for both IP and hostname formats)
                            if is_ip_address or is_hostname:
                                try:
                                    device_check = subprocess.run(
                                        [str(adb_path), '-s', device_id, 'shell', 'getprop', 'ro.serialno'],
                                        capture_output=True,
                                        text=True,
                                        timeout=3,
                                        env=env,
                                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                    )
                                    if device_check.returncode == 0 and target_device_id in device_check.stdout.strip():
                                        wireless_connected = True
                                        wireless_device_id = device_id
                                        break
                                except:
                                    pass
            
            # Disconnect if wireless connection is active (check actual state, not button text)
            if wireless_connected:
                # Disconnect
                try:
                    # Extract hostname/IP from device_id (remove port if present)
                    disconnect_target = wireless_device_id
                    if ':' in disconnect_target:
                        disconnect_target = disconnect_target.split(':')[0]
                    
                    disconnect_result = subprocess.run(
                        [str(adb_path), 'disconnect', disconnect_target],
                        capture_output=True,
                        text=True,
                        timeout=5,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                    if disconnect_result.returncode == 0:
                        QMessageBox.information(self, "Disconnected", f"Disconnected from {wireless_device_id}")
                        connect_btn.setText("Connect")
                        status_label.setText("Not connected wirelessly")
                        status_label.setStyleSheet("margin: 5px; color: #666;")
                        if hasattr(self, 'adb_status_broker'):
                            self.adb_status_broker.suppress_auto_reconnect(seconds=15)
                            self.adb_status_broker.update_snapshot(
                                status='no_adb',
                                device_id=None,
                                hostname=None,
                                is_wireless=False,
                                rooted=False,
                                update_script_exists=False,
                                fastupdate_marker_exists=False,
                                fastupdate_marker_date=None,
                                fast_update_ready=False,
                                last_checked=datetime.now(),
                            )
                            self.adb_status_broker.flush_callbacks()
                        # Immediately trigger ADB status update to refresh status light
                        # Use a short delay to ensure disconnect is fully processed
                        QTimer.singleShot(500, lambda: self.start_adb_check_worker(force=True, reason="manual-disconnect"))
                    else:
                        QMessageBox.warning(self, "Disconnect Failed", f"Failed to disconnect: {disconnect_result.stderr}")
                except Exception as e:
                    QMessageBox.warning(self, "Disconnect Error", f"Error disconnecting: {str(e)}")
            else:
                # Connect - if field is empty, auto-detect from USB ADB
                ip_or_hostname = self.wireless_ip_input.text().strip()
                if not ip_or_hostname or ip_or_hostname == self.wireless_ip_input.placeholderText():
                    # Auto-detect from USB ADB
                    self._auto_detect_and_connect_wireless(adb_path, env, dialog)
                else:
                    # Connect using provided IP/hostname
                    # After successful connection, status will be updated immediately in connect_wireless_adb
                    self.connect_wireless_adb(ip_or_hostname, dialog)
                # Re-check connection status after a delay (for UI consistency)
                # Also trigger ADB status update to refresh status light
                QTimer.singleShot(1000, check_wireless_connection)
                QTimer.singleShot(1500, lambda: self.start_adb_check_worker(force=True, reason="manual-connect"))
        
        connect_btn.clicked.connect(on_connect_clicked)
        ip_layout.addWidget(connect_btn)
        
        # Forget Device button
        forget_btn = QPushButton("Forget Device")
        forget_btn.setStyleSheet("font-size: 11px; padding: 5px;")
        forget_btn.setToolTip("Clear saved hostname and IP address. The field will be auto-populated when you connect via USB.")
        
        def on_forget_clicked():
            # First, disconnect Wi-Fi ADB if connected
            adb_path = self.find_adb_executable()
            if adb_path:
                import os
                import platform
                env = os.environ.copy()
                if platform.system() == "Darwin":
                    homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                    current_path = env.get("PATH", "")
                    for brew_path in homebrew_paths:
                        if brew_path not in current_path:
                            env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
                
                # Check if there's a wireless connection
                try:
                    result = subprocess.run(
                        [str(adb_path), 'devices'],
                        capture_output=True,
                        text=True,
                        timeout=5,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                    
                    target_device_id = "0123456789ABCDEF"
                    wireless_device_id = None
                    usb_connected = False
                    
                    # Check all connected devices
                    for line in result.stdout.split('\n'):
                        if '\tdevice' in line:
                            device_id = line.split('\t')[0]
                            if device_id == target_device_id:
                                usb_connected = True
                            elif ':' in device_id:
                                # Check if it's a wireless connection for our target device
                                try:
                                    device_check = subprocess.run(
                                        [str(adb_path), '-s', device_id, 'shell', 'getprop', 'ro.serialno'],
                                        capture_output=True,
                                        text=True,
                                        timeout=3,
                                        env=env,
                                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                    )
                                    if device_check.returncode == 0 and target_device_id in device_check.stdout.strip():
                                        wireless_device_id = device_id
                                        break
                                except:
                                    pass
                    
                    # Disconnect Wi-Fi ADB if connected
                    if wireless_device_id:
                        disconnect_target = wireless_device_id.split(':')[0] if ':' in wireless_device_id else wireless_device_id
                        try:
                            disconnect_result = subprocess.run(
                                [str(adb_path), 'disconnect', disconnect_target],
                                capture_output=True,
                                text=True,
                                timeout=5,
                                env=env,
                                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                            )
                            if disconnect_result.returncode == 0:
                                silent_print(f"Disconnected Wi-Fi ADB: {disconnect_target}")
                        except Exception as e:
                            silent_print(f"Error disconnecting Wi-Fi ADB: {e}")
                except Exception as e:
                    silent_print(f"Error checking devices for disconnect: {e}")
            
            # Clear saved hostname and IP address
            self.forget_wireless_adb_device()
            # Clear the input field
            if hasattr(self, 'wireless_ip_input'):
                self.wireless_ip_input.clear()
            
            # Update ADB status (will update status light if not connected by USB)
            self.start_adb_check_worker()
            
            # Show confirmation
            QMessageBox.information(
                self,
                "Device Forgotten",
                "Saved hostname and IP address have been cleared.\n\n"
                "If connected wirelessly, the Wi-Fi ADB connection has been disconnected.\n\n"
                "The field will be automatically populated when you connect your device via USB."
            )
            # Re-check connection status to update UI
            QTimer.singleShot(100, check_wireless_connection)
        
        forget_btn.clicked.connect(on_forget_clicked)
        ip_layout.addWidget(forget_btn)
        
        wireless_layout.addWidget(ip_group)
        
        # Check connection status immediately after UI is set up (non-blocking)
        # This ensures the Connect button text is updated correctly
        QTimer.singleShot(100, check_wireless_connection)
        
        # ADB Wi-Fi Reborn Setup section (only shown if app is not installed)
# 2025-11-09 12:00:00 - original: Setup group title read 'Setup Wireless ADB' without beta label.
        setup_group = QGroupBox("Setup Wireless ADB (Beta)")
        setup_layout = QVBoxLayout(setup_group)
        
        wifi_info = QLabel(
            "Wireless ADB tools let Smart Drop and Fast Update run without a cable. "
            "Connect your rooted Y1 over USB, then use the Wi-Fi settings to pair it."
        )
        wifi_info.setWordWrap(True)
        layout.addWidget(wifi_info)
        
        setup_desc = QLabel(
            "Want Smart Drop and Fast Update without a cable? Install ADB Wi-Fi Reborn and configure Wi-Fi on your Y1."
        )
        setup_desc.setStyleSheet("margin: 5px;")
        setup_desc.setWordWrap(True)
        setup_layout.addWidget(setup_desc)
        
        # Install ADB Wi-Fi Reborn button
        install_adb_wifi_btn = QPushButton("üì± Setup Wi-Fi ADB App")
        install_adb_wifi_btn.clicked.connect(lambda: self.install_adb_wifi_reborn())
        
        wifi_settings_shortcut = QPushButton("üì∂ Y1 Wi-Fi Settings")
        wifi_settings_shortcut.setEnabled(False)
        wifi_settings_shortcut.setToolTip("Connect your Y1 with the Wi-Fi helper over USB to use this feature.")
        wifi_settings_shortcut.clicked.connect(lambda: self.open_wireless_wifi_dialog())
        self.wifi_settings_shortcut = wifi_settings_shortcut
        
        button_row = QHBoxLayout()
        button_row.addWidget(install_adb_wifi_btn)
        button_row.addWidget(wifi_settings_shortcut)
        setup_layout.addLayout(button_row)
        
        # Credit label with link to Google Play Store
        credit_label = QLabel('<a href="https://play.google.com/store/apps/details?id=com.ryosoftware.adbw&hl=en">ADB Wi-Fi Reborn by RYO Software</a>')
        credit_label.setStyleSheet("font-size: 10px; color: #666; margin: 5px; font-style: italic;")
        credit_label.setAlignment(Qt.AlignCenter)
        credit_label.setOpenExternalLinks(True)
        setup_layout.addWidget(credit_label)
        
        # Function to check if ADB Wi-Fi Reborn is installed
        # Check installation status when dialog opens (non-blocking, runs in background)
        def check_in_background():
            try:
                adb_path = self.find_adb_executable()
                if not adb_path:
                    QTimer.singleShot(0, lambda: setup_group.setVisible(False))
                    return
                
                env = os.environ.copy()
                if platform.system() == "Darwin":
                    homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                    current_path = env.get("PATH", "")
                    for brew_path in homebrew_paths:
                        if brew_path not in current_path:
                            env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
                
                result = subprocess.run(
                    [str(adb_path), 'devices'],
                    capture_output=True,
                    text=True,
                    timeout=5,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                
                target_device_id = "0123456789ABCDEF"
                usb_device_id = None
                wireless_device_id = None
                
                for line in result.stdout.split('\n'):
                    if '\tdevice' in line:
                        device_id = line.split('\t')[0]
                        if device_id == target_device_id:
                            usb_device_id = device_id
                        elif ':' in device_id:
                            # Check if it's a wireless connection
                            parts = device_id.split(':')
                            if len(parts) == 2:
                                host_part = parts[0]
                                is_ip = '.' in host_part and len(host_part.split('.')) == 4
                                is_hostname = host_part.startswith('android-') and len(host_part) > 8
                                
                                if is_ip or is_hostname:
                                    try:
                                        device_check = subprocess.run(
                                            [str(adb_path), '-s', device_id, 'shell', 'getprop', 'ro.serialno'],
                                            capture_output=True,
                                            text=True,
                                            timeout=3,
                                            env=env,
                                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                        )
                                        if device_check.returncode == 0 and target_device_id in device_check.stdout.strip():
                                            wireless_device_id = device_id
                                    except:
                                        pass
                
                # Update UI in main thread
                def update_ui():
                    try:
                        # If device is already connected via Wi-Fi, don't show setup section
                        if wireless_device_id:
                            setup_group.setVisible(False)
                            return
                        
                        # If no USB device connected, keep card but disable controls
                        if not usb_device_id:
                            return
                        
                        # Check if USB device is rooted (in background)
                        def check_root():
                            try:
                                root_check = subprocess.run(
                                    [str(adb_path), '-s', usb_device_id, 'shell', 'su', '-c', 'id'],
                                    capture_output=True,
                                    text=True,
                                    timeout=5,
                                    env=env,
                                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                )
                                is_rooted = (root_check.returncode == 0 and 'uid=0' in root_check.stdout)
                                
                                # Update UI in main thread
                                QTimer.singleShot(0, lambda: check_package(is_rooted))
                            except:
                                QTimer.singleShot(0, lambda: setup_group.setVisible(False))
                        
                        def check_package(is_rooted):
                            try:
                                install_adb_wifi_btn.setEnabled(is_rooted)
                                wifi_settings_shortcut.setEnabled(is_rooted)
                                if hasattr(self, 'open_wifi_btn') and self.open_wifi_btn:
                                    self.open_wifi_btn.setEnabled(is_rooted)
                                tooltip_disabled = "Connect your Y1 with the Wi-Fi helper firmware over USB to use this feature."
                                if not is_rooted:
                                    install_adb_wifi_btn.setToolTip("Wireless ADB setup requires root access on the Y1.")
                                    wifi_settings_shortcut.setToolTip(tooltip_disabled)
                                    if hasattr(self, 'open_wifi_btn') and self.open_wifi_btn:
                                        self.open_wifi_btn.setToolTip(tooltip_disabled)
                                    return
                                else:
                                    install_adb_wifi_btn.setToolTip("")
                                    wifi_settings_shortcut.setToolTip("")
                                    if hasattr(self, 'open_wifi_btn') and self.open_wifi_btn:
                                        self.open_wifi_btn.setToolTip("")
                                    wifi_info.setText(
                                        "Your Y1 is connected over USB with root access. Use Y1 Wi-Fi Settings to configure wireless transfers."
                                    )
                                
                                # Check if ADB Wi-Fi Reborn is installed
                                pm_result = subprocess.run(
                                    [str(adb_path), '-s', usb_device_id, 'shell', 'pm', 'list', 'packages', 'com.ryosoftware.adbw'],
                                    capture_output=True,
                                    text=True,
                                    timeout=5,
                                    env=env,
                                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                )
                                
                                # If package is found, hide setup section
                                if pm_result.returncode == 0 and 'com.ryosoftware.adbw' in pm_result.stdout:
                                    setup_group.setVisible(False)
                                else:
                                    # Package not found, show setup section (rooted USB device without app)
                                    setup_group.setVisible(True)
                            except:
                                setup_group.setVisible(False)
                        
                        # Check root in background thread
                        import threading
                        thread = threading.Thread(target=check_root, daemon=True)
                        thread.start()
                    except:
                        setup_group.setVisible(False)
                
                QTimer.singleShot(0, update_ui)
            except:
                QTimer.singleShot(0, lambda: setup_group.setVisible(False))
        
        # Run check in background thread to prevent UI hang
        import threading
        check_thread = threading.Thread(target=check_in_background, daemon=True)
        check_thread.start()
        
        # Also check when wireless tab is shown (non-blocking)
        def on_wireless_tab_shown():
            # Refresh connection status when tab is shown
            check_wireless_connection()
        
        # Connect to tab change signal to re-check when tab is shown (non-blocking)
        tab_widget.currentChanged.connect(lambda index: on_wireless_tab_shown() if tab_widget.tabText(index) == "Smart Drop & Wi-Fi" else None)
        
        # Set up periodic refresh of connection status (every 5 seconds while dialog is open)
        status_refresh_timer = QTimer()
        status_refresh_timer.timeout.connect(check_wireless_connection)
        status_refresh_timer.start(5000)  # Refresh every 5 seconds
        
        wireless_layout.addWidget(setup_group)
        
        # Add Smart Drop USB Storage Settings section
        self.populate_smart_drop_tab(wireless_layout)
        
        wireless_layout.addStretch()
        
        # What's New Tab
        whats_new_tab = QWidget()
        whats_new_layout = QVBoxLayout(whats_new_tab)
        whats_new_layout.setContentsMargins(10, 10, 10, 10)
        
        # Release notes browser (store reference for theme refresh)
        whats_new_browser = QTextBrowser()
        whats_new_browser.setReadOnly(True)
        whats_new_browser.setStyleSheet("""
            QTextBrowser {
                background-color: transparent;
                border: none;
                padding: 10px;
            }
        """)
        # Store reference for theme refresh
        self.whats_new_browser = whats_new_browser
        whats_new_layout.addWidget(whats_new_browser)
        
        preferred_version = self._latest_app_version or self.app_version
        # 2025-11-09 21:40:00 UTC - original: Version tab populated without any inline notice about newer releases.
        self.populate_version_tab(whats_new_layout, whats_new_browser, preferred_version)
        
        # 2025-11-09 21:40:00 UTC - original: Update suppression checkbox did not update UI until settings were saved.
        dont_notify_checkbox = QCheckBox("Don't notify me about updates")
        dont_notify_checkbox.setChecked(self.suppress_update_notifications)
        dont_notify_checkbox.toggled.connect(self._handle_update_notification_toggle)
        whats_new_layout.addWidget(dont_notify_checkbox)
        self._current_update_checkbox = dont_notify_checkbox
        
        # Load release notes for current app version
        
        # Add tabs to tab widget in order
        update_is_newer = update_available and self.has_update_available()
        updates_label = "Update Available" if update_is_newer else f"Version {self.app_version}"
        tab_widget.addTab(about_tab, "About")
        updates_tab_index = tab_widget.addTab(whats_new_tab, updates_label)
        self._active_updates_tab_index = updates_tab_index
        installation_tab_index = None
        if self.method_combo:
            installation_tab_index = tab_widget.addTab(install_tab, "Installation")
        shortcuts_tab_index = None
# 2025-11-09 12:00:00 - original: Tab label was 'Wireless ADB' and did not indicate beta availability.
        tab_widget.addTab(wireless_scroll, "Smart Drop & Wi-Fi")
        
        self._apply_update_tab_badge(tab_widget, updates_tab_index, update_is_newer)
        if update_is_newer and self._latest_app_version:
            tab_widget.setTabToolTip(updates_tab_index, f"Update {self._latest_app_version} available")
        else:
            tab_widget.setTabToolTip(updates_tab_index, "")
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        close_btn = QPushButton("Close")
        if not update_available:
            close_btn.setDefault(True)
        close_btn.clicked.connect(lambda: self.save_settings(dialog))
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        
        # Set initial tab based on parameter
        if initial_tab == "about":
            tab_widget.setCurrentIndex(0)
        elif initial_tab == "updates":
            tab_widget.setCurrentIndex(updates_tab_index)
        elif initial_tab == "installation":
            if installation_tab_index is not None:
                tab_widget.setCurrentIndex(installation_tab_index)
            else:
                tab_widget.setCurrentIndex(updates_tab_index)
        elif initial_tab == "shortcuts":
            if shortcuts_tab_index is not None:
                tab_widget.setCurrentIndex(shortcuts_tab_index)
            else:
                tab_widget.setCurrentIndex(updates_tab_index)
        else:
            tab_widget.setCurrentIndex(0)
        
        silent_print("About to show settings dialog")
        if auto_download_latest:
            QTimer.singleShot(150, lambda: self._maybe_auto_download_latest(dialog))
        dialog.exec()
        self._active_settings_tab_widget = None
        self._active_updates_tab_index = None
        self._active_settings_dialog = None
        self._pending_auto_download_latest = False
        self._active_settings_dialog = None
        silent_print("Settings dialog closed")
    
    def _get_release_data(self, version):
        """Retrieve release data for the specified version."""
        if not version:
            return None
        if hasattr(self, '_latest_release_data') and version in self._latest_release_data:
            return self._latest_release_data[version]
        try:
            headers = {'Accept': 'application/vnd.github.v3+json'}
            if hasattr(self, 'github_api') and hasattr(self.github_api, 'tokens') and self.github_api.tokens:
                token = self.github_api.get_next_token()
                if token:
                    headers['Authorization'] = f'token {token}'
            possible_tags = [f"v{version}", version, f"V{version}"]
            response = requests.get(
                "https://api.github.com/repos/y1-community/Innioasis-Updater/releases",
                headers=headers,
                timeout=10
            )
            if response.status_code == 200:
                releases = response.json()
                for release in releases:
                    tag = release.get('tag_name', '')
                    if tag in possible_tags or tag.replace('v', '').replace('V', '') == version:
                        if not hasattr(self, '_latest_release_data'):
                            self._latest_release_data = {}
                        self._latest_release_data[version] = release
                        return release
        except Exception as e:
            silent_print(f"Error fetching release data for {version}: {e}")
        return None

    def ensure_release_catalog(self):
        """Ensure the release catalog has been fetched."""
        if not self.available_versions:
            self.get_latest_github_version()

    def populate_smart_drop_tab(self, layout):
        """Populate Smart Drop USB storage settings section (now part of Smart Drop tab)"""
        from PySide6.QtWidgets import QLabel, QLineEdit, QPushButton, QHBoxLayout, QFileDialog, QMessageBox, QGroupBox
        
        # Add separator/spacing before Smart Drop section
        separator = QLabel("")
        separator.setStyleSheet("margin: 10px 0;")
        layout.addWidget(separator)
        
        # Title
        title_label = QLabel("Smart Drop USB Storage Settings")
        title_label.setStyleSheet("font-weight: bold; font-size: 14px; margin-bottom: 8px;")
        layout.addWidget(title_label)
        
        # Description
        desc_label = QLabel(
            "Configure the USB storage drive path for your Y1 device. "
            "This is used when USB Storage Mode is enabled and ADB file transfers are not available.\n\n"
            "The app will automatically detect drives containing '.rockbox' or 'Themes' folders, "
            "but you can manually specify a path if auto-detection fails."
        )
        desc_label.setWordWrap(True)
        layout.addWidget(desc_label)
        
        # USB Drive Path Section
        path_group = QGroupBox("Y1 USB Drive Path")
        path_layout = QVBoxLayout(path_group)
        
        # Current path display
        current_layout = QHBoxLayout()
        current_label = QLabel("Current path:")
        self.smart_drop_path_display = QLineEdit()
        self.smart_drop_path_display.setReadOnly(True)
        self.smart_drop_path_display.setPlaceholderText("Not set - will auto-detect")
        # Load saved path
        saved_path = self.load_usb_drive_path()
        if saved_path:
            self.smart_drop_path_display.setText(saved_path)
        else:
            # Try auto-detection
            detected = self._detect_usb_storage_drive()
            if detected:
                self.smart_drop_path_display.setText(detected)
        current_layout.addWidget(current_label)
        current_layout.addWidget(self.smart_drop_path_display)
        path_layout.addLayout(current_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        detect_btn = QPushButton("Auto-Detect")
        detect_btn.clicked.connect(self._on_detect_usb_drive)
        select_btn = QPushButton("Browse...")
        select_btn.clicked.connect(self._on_select_usb_drive)
        clear_btn = QPushButton("Clear")
        clear_btn.clicked.connect(self._on_clear_usb_drive)
        button_layout.addWidget(detect_btn)
        button_layout.addWidget(select_btn)
        button_layout.addWidget(clear_btn)
        button_layout.addStretch()
        path_layout.addLayout(button_layout)
        
        layout.addWidget(path_group)

        wifi_info = QLabel(
            "Wireless ADB tools let Smart Drop and Fast Update run without a cable. "
            "Connect your rooted Y1 over USB, then use the Wi-Fi settings to pair it."
        )
        wifi_info.setWordWrap(True)
        layout.addWidget(wifi_info)
        
        open_wifi_btn = QPushButton("Y1 Wi-Fi Settings‚Ä¶")
        open_wifi_btn.setEnabled(False)
        open_wifi_btn.setToolTip("Connect your Y1 with the Wi-Fi helper firmware over USB to use this feature.")
        open_wifi_btn.clicked.connect(lambda: self.open_wireless_wifi_dialog())
        self.open_wifi_btn = open_wifi_btn
        layout.addWidget(open_wifi_btn)
    
    def _on_detect_usb_drive(self):
        """Handle auto-detect USB drive button click"""
        detected = self._detect_usb_storage_drive()
        if detected:
            self.smart_drop_path_display.setText(detected)
            self.saved_usb_drive_path = detected
            self.save_usb_drive_path(detected)
            QMessageBox.information(self, "Auto-Detection", f"Found Y1 USB drive:\n\n{detected}")
        else:
            QMessageBox.information(self, "Auto-Detection", "No Y1 USB drive detected.\n\nPlease ensure your Y1 is connected in USB Storage Mode and contains a '.rockbox' or 'Themes' folder.")
    
    def _on_select_usb_drive(self):
        """Handle browse USB drive button click"""
        from PySide6.QtWidgets import QFileDialog, QMessageBox
        folder = QFileDialog.getExistingDirectory(
            self,
            "Select Y1 USB Drive",
            self.smart_drop_path_display.text() or "",
            QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
        )
        if folder:
            # Verify it's a Y1 drive
            folder_path = Path(folder)
            themes_path = folder_path / "Themes"
            rockbox_path = folder_path / ".rockbox"
            if themes_path.exists() or rockbox_path.exists():
                self.smart_drop_path_display.setText(folder)
                self.saved_usb_drive_path = folder
                self.save_usb_drive_path(folder)
                QMessageBox.information(self, "Path Set", f"Y1 USB drive path set to:\n\n{folder}")
            else:
                reply = QMessageBox.warning(
                    self,
                    "Invalid Path",
                    "The selected folder doesn't appear to be a Y1 USB drive.\n\n"
                    "Y1 drives should contain a '.rockbox' or 'Themes' folder.\n\n"
                    "Do you want to use this path anyway?",
                    QMessageBox.Yes | QMessageBox.No
                )
                if reply == QMessageBox.Yes:
                    self.smart_drop_path_display.setText(folder)
                    self.saved_usb_drive_path = folder
                    self.save_usb_drive_path(folder)
    
    def _on_clear_usb_drive(self):
        """Handle clear USB drive path button click"""
        self.smart_drop_path_display.clear()
        self.saved_usb_drive_path = None
        self.save_usb_drive_path(None)
    
    def save_usb_drive_path(self, path):
        """Save USB drive path to preferences"""
        try:
            preferences_file = Path("installation_preferences.json")
            import json
            preferences = {}
            if preferences_file.exists():
                with open(preferences_file, 'r') as f:
                    preferences = json.load(f)
            
            if path:
                preferences['usb_drive_path'] = path
            elif 'usb_drive_path' in preferences:
                del preferences['usb_drive_path']
            
            with open(preferences_file, 'w') as f:
                json.dump(preferences, f, indent=2)
            
            silent_print(f"Saved USB drive path: {path}")
        except Exception as e:
            silent_print(f"Error saving USB drive path: {e}")
    
    def load_usb_drive_path(self):
        """Load USB drive path from preferences"""
        try:
            preferences_file = Path("installation_preferences.json")
            if preferences_file.exists():
                import json
                with open(preferences_file, 'r') as f:
                    preferences = json.load(f)
                
                if 'usb_drive_path' in preferences:
                    path = preferences['usb_drive_path']
                    # Verify path still exists and is valid
                    if Path(path).exists():
                        self.saved_usb_drive_path = path
                        return path
                    else:
                        silent_print(f"Saved USB drive path no longer exists: {path}")
        except Exception as e:
            silent_print(f"Error loading USB drive path: {e}")
        
        return None

    def _clear_layout(self, layout):
        """Remove and delete all items from the given layout."""
        if layout is None:
            return
        while layout.count():
            item = layout.takeAt(0)
            widget = item.widget()
            child_layout = item.layout()
            if widget is not None:
                widget.deleteLater()
            elif child_layout is not None:
                self._clear_layout(child_layout)
                child_layout.deleteLater()

    def populate_version_tab(self, layout, browser, preferred_version=None):
        """Populate the version tab with selector and release notes."""
        self.ensure_release_catalog()
        if not self.available_versions:
            self.load_whats_new_release_notes(browser)
            return

        # 2025-11-09 21:41:00 UTC - original: Layout did not include an inline banner about the user's app version status.
        if hasattr(self, '_update_notice_label') and self._update_notice_label:
            try:
                if self._update_notice_label.parent():
                    self._update_notice_label.setParent(None)
            except Exception:
                pass
            self._update_notice_label.deleteLater()
            self._update_notice_label = None

        notice_label = QLabel()
        notice_label.setWordWrap(True)
        notice_label.setAlignment(Qt.AlignLeft | Qt.AlignVCenter)
        notice_label.setObjectName("update_notice_label")
        # Don't set color here - _refresh_update_notice_label will set it based on theme
        notice_label.setStyleSheet("font-weight: 600; margin: 6px 4px; padding: 10px; border-radius: 7px;")
        self._update_notice_label = notice_label
        
        # Trigger update check if not already done or in progress
        if not getattr(self, '_update_check_in_progress', False) and self._update_check_attempts < self._max_update_check_attempts:
            silent_print("populate_version_tab: Triggering update check")
            self.check_for_updates_and_show_button()
        
        # Refresh the notice label after a short delay to ensure update check completes
        QTimer.singleShot(500, self._refresh_update_notice_label)
        self._refresh_update_notice_label()
        self._version_tab_layout = layout
        self._version_browser = browser

        controls_container = getattr(self, 'version_controls_container', None)
        controls_layout = getattr(self, 'version_controls_layout', None)
        if controls_container is None or controls_layout is None:
            controls_container = QWidget()
            controls_layout = QVBoxLayout(controls_container)
            controls_layout.setContentsMargins(0, 0, 0, 0)
            controls_layout.setSpacing(8)
            self.version_controls_container = controls_container
            self.version_controls_layout = controls_layout
            insert_index = layout.indexOf(browser)
            if insert_index == -1:
                layout.addWidget(controls_container)
            else:
                layout.insertWidget(insert_index, controls_container)
        else:
            self._clear_layout(controls_layout)

        controls_layout.addWidget(notice_label)

        self.version_combo = None
        self.version_download_btn = None
        self.version_run_once_btn = None
        self.show_older_releases_checkbox = None

        # Initialize show_older_releases flag if not set
        if not hasattr(self, 'show_older_releases'):
            self.show_older_releases = False
        
        # Check if app version is newer than latest available release
        # If so, enable show_older_releases by default and make checkbox read-only
        app_version_newer_than_latest = False
        if self.available_versions:
            latest_release_version = self.available_versions[0]['version'].lstrip('vV')
            current_app_version = APP_VERSION.lstrip('vV')
            try:
                if self.compare_versions(current_app_version, latest_release_version) > 0:
                    app_version_newer_than_latest = True
                    self.show_older_releases = True  # Enable by default
                    silent_print(f"App version {current_app_version} is newer than latest release {latest_release_version} - enabling 'Show older releases'")
            except Exception as compare_error:
                silent_print(f"Error comparing versions: {compare_error}")
        
        selector_layout = QHBoxLayout()
        selector_layout.setContentsMargins(0, 0, 8, 6)
        selector_layout.setSpacing(8)
        
        selector_label = QLabel("Select version:")
        selector_label.setStyleSheet("font-weight: 600;")
        selector_layout.addWidget(selector_label)
        
        self.version_combo = QComboBox()
        self.version_combo.setMinimumWidth(220)
        self.version_combo.blockSignals(True)
        
        filtered_entries = []
        for entry in self.available_versions:
            normalized_version = entry['version'].lstrip('vV')
            if not self.show_older_releases:
                try:
                    if self.compare_versions(normalized_version, APP_VERSION) < 0:
                        continue
                except Exception:
                    continue
            display = entry['version']
            commit_display = entry.get('commit')
            if commit_display:
                normalized_commit = commit_display.lstrip('vV')
                normalized_entry_version = entry['version'].lstrip('vV')
                if normalized_commit and normalized_commit != normalized_entry_version:
                    display += f" ({commit_display})"
            self.version_combo.addItem(display, entry)
            filtered_entries.append(entry)
        self.version_combo.blockSignals(False)
        selector_layout.addWidget(self.version_combo, 1)
        controls_layout.addLayout(selector_layout)
        
        # Add checkbox for showing older releases
        checkbox_layout = QHBoxLayout()
        checkbox_layout.setContentsMargins(0, 0, 8, 6)
        checkbox_layout.setSpacing(8)
        checkbox_layout.addStretch()
        
        self.show_older_releases_checkbox = QCheckBox("Show older releases")
        self.show_older_releases_checkbox.blockSignals(True)
        self.show_older_releases_checkbox.setChecked(self.show_older_releases)
        self.show_older_releases_checkbox.blockSignals(False)
        # If app version is newer than latest, make checkbox read-only
        if app_version_newer_than_latest:
            self.show_older_releases_checkbox.setEnabled(False)
            self.show_older_releases_checkbox.setToolTip("App version is newer than latest release - older releases are always shown")
        else:
            self.show_older_releases_checkbox.stateChanged.connect(lambda state: self._on_show_older_releases_changed(state, browser))
        checkbox_layout.addWidget(self.show_older_releases_checkbox)
        controls_layout.addLayout(checkbox_layout)
        
        self.version_combo.currentIndexChanged.connect(lambda _: self.on_version_selection_changed(browser))
        
        action_layout = QHBoxLayout()
        action_layout.addStretch()
        self.version_run_once_btn = QPushButton("Run older version once")
        self.version_run_once_btn.setCursor(Qt.PointingHandCursor)
        self.version_run_once_btn.clicked.connect(self.run_selected_version_once)
        self.version_run_once_btn.setVisible(False)
        action_layout.addWidget(self.version_run_once_btn)
        self.version_download_btn = QPushButton("Install selected version")
        self.version_download_btn.setCursor(Qt.PointingHandCursor)
        self.version_download_btn.clicked.connect(lambda: self.download_selected_version(self._active_settings_dialog))
        action_layout.addWidget(self.version_download_btn)
        controls_layout.addLayout(action_layout)
        
        target_index = None
        normalized_preferred = preferred_version.lstrip('vV') if preferred_version else None
        current_version = getattr(self, 'app_version', '') or ''

        if normalized_preferred:
            for idx, entry in enumerate(filtered_entries):
                if entry['version'].lstrip('vV') == normalized_preferred:
                    target_index = idx
                    break

        if target_index is None:
            for idx, entry in enumerate(filtered_entries):
                try:
                    if self.compare_versions(entry['version'].lstrip('vV'), current_version) > 0:
                        target_index = idx
                        break
                except Exception:
                    continue

        if target_index is None and filtered_entries:
            # Default to the latest release
            target_index = 0

        if filtered_entries:
            self.version_combo.setEnabled(True)
            self.version_download_btn.setEnabled(True)
            if target_index is not None:
                self.version_combo.setCurrentIndex(target_index)
            self.on_version_selection_changed(browser)
        else:
            self.version_combo.addItem("No releases found", None)
            self.version_combo.setEnabled(False)
            self.version_download_btn.setEnabled(False)
            if self.version_run_once_btn:
                self.version_run_once_btn.setVisible(False)
                self.version_run_once_btn.setEnabled(False)

        controls_layout.addSpacing(4)

        # ensure buttons reflect current selection
        self._refresh_version_action_ctas()
    
    def _on_show_older_releases_changed(self, state, browser):
        """Handle changes to the 'Show older releases' checkbox"""
        self.show_older_releases = (state == Qt.Checked)
        layout = getattr(self, '_version_tab_layout', None)
        if layout:
            self.populate_version_tab(layout, browser)

    # 2025-11-09 21:41:00 UTC - original: Version tab checkbox toggles only changed state on save and the UI never refreshed inline.
    def _handle_update_notification_toggle(self, checked):
        """Handle live updates to the update notification suppression toggle."""
        self.suppress_update_notifications = checked
        self._refresh_update_notice_label()
        self.update_update_badges()
        # Removed: _refresh_top_right_update_cta - no longer modifying Discord/About buttons

    # 2025-11-09 21:41:00 UTC - original: There was no inline status message alerting users when their build was behind.
    def _refresh_update_notice_label(self):
        """Refresh the inline update notice in the Version tab and main GUI banner."""
        label = getattr(self, '_update_notice_label', None)
        banner = getattr(self, 'update_alert_banner', None)
        had_error = False
        try:
            messages = []
            has_update = self.has_update_available()
            suppress = self.suppress_update_notifications
            silent_print(f"_refresh_update_notice_label: has_update={has_update}, suppress={suppress}, _latest_app_version={getattr(self, '_latest_app_version', None)}")
            
            if has_update and not suppress:
                latest_version = self._latest_app_version or ""
                current_version = self.app_version or APP_VERSION
                messages.append(
                    f"Innioasis Updater {latest_version} is available. "
                    f"You're currently running {current_version}. Download the new release to stay up to date."
                )
                silent_print(f"_refresh_update_notice_label: Adding message for banner/label")

            for target in (label, banner):
                if not target:
                    silent_print(f"_refresh_update_notice_label: Target is None (label={label is not None}, banner={banner is not None})")
                    continue
                if messages:
                    try:
                        is_dark = self.is_dark_mode()
                    except Exception:
                        is_dark = False
                    if is_dark:
                        bg_rgba = "rgba(255, 255, 255, 0.12)"
                        text_color = "#F5F9FF"
                    else:
                        bg_rgba = "rgba(12, 27, 51, 0.10)"
                        text_color = "#0C1B33"
                    margin_rule = "margin: 6px 4px;" if target is label else "margin: 0 0 6px 0;"
                    target.setStyleSheet(
                        f"font-weight: 600; {margin_rule} padding: 10px; border-radius: 7px;"
                        f"background-color: {bg_rgba}; color: {text_color};"
                    )
                    target.setText("\n".join(messages))
                    target.setVisible(True)
                    silent_print(f"_refresh_update_notice_label: Set message and made visible on {target.objectName() if hasattr(target, 'objectName') else 'target'}")
                else:
                    target.clear()
                    target.setVisible(False)
                    silent_print(f"_refresh_update_notice_label: Cleared and hid {target.objectName() if hasattr(target, 'objectName') else 'target'}")
        except Exception as e:
            had_error = True
            silent_print(f"Error refreshing update notice label: {e}")
            import traceback
            traceback.print_exc()
        finally:
            if had_error:
                if label:
                    label.clear()
                    label.setVisible(False)
                if banner:
                    banner.clear()
                    banner.setVisible(False)

            try:
                if hasattr(self, 'firmware_combo') and self.firmware_combo:
                    self.update_package_group_title(self.firmware_combo.currentText())
            except Exception:
                pass

    def _schedule_update_check(self, delay_ms=0, force=False):
        """Schedule an update check with optional retry semantics."""
        try:
            max_attempts = getattr(self, '_max_update_check_attempts', 3)
            attempts = getattr(self, '_update_check_attempts', 0)
            if not force and attempts >= max_attempts:
                return
            delay = max(0, int(delay_ms))
            QTimer.singleShot(delay, lambda: self._run_scheduled_update_check(force))
        except Exception as e:
            silent_print(f"Error scheduling update check: {e}")

    def _run_scheduled_update_check(self, force=False):
        """Invoke the update check unless one is already running."""
        if getattr(self, '_update_check_in_progress', False):
            max_attempts = getattr(self, '_max_update_check_attempts', 3)
            attempts = getattr(self, '_update_check_attempts', 0)
            if force or attempts < max_attempts:
                QTimer.singleShot(1500, lambda: self._schedule_update_check(0, force))
            return
        max_attempts = getattr(self, '_max_update_check_attempts', 3)
        if not force and getattr(self, '_update_check_attempts', 0) >= max_attempts:
            return
        self._update_check_attempts = getattr(self, '_update_check_attempts', 0) + 1
        self.check_for_updates_and_show_button()


    def _on_update_banner_clicked(self, event):
        """Handle clicks on the main-window update banner."""
        if self.has_update_available() and not self.suppress_update_notifications:
            self._launch_auto_update_download()
        else:
            self.show_settings_dialog("updates")
        if event:
            event.accept()

    def _refresh_version_action_ctas(self):
        """Update the Version tab action buttons based on the current selection."""
        combo = getattr(self, 'version_combo', None)
        run_btn = getattr(self, 'version_run_once_btn', None)
        install_btn = getattr(self, 'version_download_btn', None)
        if install_btn:
            install_btn.setVisible(True)
        if combo is None or combo.count() == 0 or combo.currentData() is None:
            if run_btn:
                run_btn.setVisible(False)
            if install_btn:
                install_btn.setEnabled(False)
                install_btn.setText("Install selected version")
                install_btn.setToolTip("Select an Innioasis Updater release to install.")
            return
        
        data = combo.currentData()
        selected_version = data.get('version')
        normalized_selected = selected_version.lstrip('vV') if selected_version else ''
        current_version = (self.app_version or APP_VERSION).lstrip('vV')
        is_older = False
        try:
            if selected_version:
                is_older = self.compare_versions(normalized_selected, current_version) < 0
        except Exception:
            is_older = False
        is_windows = platform.system() == "Windows"

        if run_btn:
            if is_older:
                run_btn.setVisible(True)
                run_btn.setEnabled(True)
                run_btn.setToolTip(
                    f"Download and launch Innioasis Updater {selected_version} once without installing it."
                    if selected_version else
                    "Download and launch the selected Innioasis Updater once without installing it."
                )
            else:
                run_btn.setVisible(False)

        if install_btn:
            label_version = selected_version or "selected version"
            install_btn.setText(f"Install {label_version}" if selected_version else "Install selected version")
            if is_older and not is_windows:
                install_btn.setEnabled(False)
                install_btn.setToolTip("Installing older releases is disabled on this platform. Use 'Run older version once' instead.")
            else:
                install_btn.setEnabled(True)
                if is_older:
                    install_btn.setToolTip(
                        "Install the selected older Innioasis Updater release. "
                        "Use the 'Innioasis Updater (latest)' shortcut to return to the newest build."
                    )
                else:
                    install_btn.setToolTip("Install the selected Innioasis Updater release.")

    def _refresh_version_download_cta(self):
        """Backward-compatible wrapper for legacy calls."""
        self._refresh_version_action_ctas()

    def _maybe_auto_download_latest(self, settings_dialog=None):
        """Automatically download the latest release when prompted by the update dialog."""
        if not getattr(self, '_pending_auto_download_latest', False):
            return
        if self.suppress_update_notifications:
            silent_print("Auto download skipped because notifications are suppressed.")
            return
        if not self.has_update_available():
            silent_print("Auto download skipped because no update is available.")
            return
        combo = getattr(self, 'version_combo', None)
        if not combo or combo.count() == 0:
            QTimer.singleShot(200, lambda: self._maybe_auto_download_latest(settings_dialog))
            return
        target_version = self._latest_app_version
        if target_version:
            for idx in range(combo.count()):
                data = combo.itemData(idx)
                if not data:
                    continue
                version_value = data.get('version')
                if version_value and self.compare_versions(version_value, target_version) == 0:
                    combo.setCurrentIndex(idx)
                    break
        QTimer.singleShot(100, lambda: self.download_selected_version(settings_dialog or self._active_settings_dialog))

    def _launch_auto_update_download(self):
        """Open the Version tab and immediately download the newest release."""
        if self.suppress_update_notifications:
            silent_print("Auto update download suppressed by user preference.")
            return
        if not self.has_update_available():
            self.show_settings_dialog("updates")
            return
        QTimer.singleShot(0, lambda: self.show_settings_dialog("updates", auto_download_latest=True))

    def _set_button_connection(self, button, slot):
        """Utility to safely replace a button's clicked connection."""
        if not button or slot is None:
            return
        try:
            button.clicked.disconnect()
        except TypeError:
            pass
        button.clicked.connect(slot)

    def _open_updates_tab_from_cta(self):
        """Open the Settings dialog directly to the updates tab."""
# 2025-11-09 22:10:00 UTC - original: Update CTA reused Get Help/About actions; now it focuses the updates tab.
        self.show_settings_dialog("updates")

    def _refresh_top_right_update_cta(self):
        """Refresh the top-right buttons so they promote updates when appropriate."""
        try:
            latest_version = self._latest_app_version if self.has_update_available() and not getattr(self, 'suppress_update_notifications', False) else None
        except Exception:
            latest_version = None

        buttons = [getattr(self, 'discord_btn', None), getattr(self, 'about_btn', None)]

        if latest_version:
            update_text = f"Update to {latest_version}"
            for btn in buttons:
                if btn:
                    btn.setText(update_text)
                    btn.setToolTip(f"Open update details for Innioasis Updater {latest_version}")
            if getattr(self, 'discord_btn', None):
                self._set_button_connection(self.discord_btn, self._open_updates_tab_from_cta)
            if getattr(self, 'about_btn', None):
                self._set_button_connection(self.about_btn, self._open_updates_tab_from_cta)
            self._top_right_update_mode = True
        else:
            if not getattr(self, '_top_right_update_mode', False):
                return
            if getattr(self, 'discord_btn', None):
                self.discord_btn.setText(getattr(self, 'discord_btn_base_text', "Get Help"))
                self.discord_btn.setToolTip(getattr(self, 'discord_btn_base_tooltip', ""))
                self._set_button_connection(self.discord_btn, getattr(self, 'open_discord_link', None))
            if getattr(self, 'about_btn', None):
                self.about_btn.setText(getattr(self, 'about_btn_base_text', "About"))
                self.about_btn.setToolTip(getattr(self, 'about_btn_base_tooltip', ""))
                self._set_button_connection(self.about_btn, getattr(self, 'open_about_tab', None))
            self._top_right_update_mode = False

    def on_version_selection_changed(self, browser):
        """Handle updates to release notes when the version selection changes."""
        if not self.version_combo:
            return
        data = self.version_combo.currentData()
        if not data:
            return
        release = data.get('release')
        if not release:
            return
        text_color = self._get_text_color_for_theme()
        release_notes = release.get('body', '')
        release_name = release.get('name', '') or release.get('tag_name', data.get('version', ''))
        self._format_release_notes_for_display(browser, release_notes, release_name, text_color)
        self._refresh_version_action_ctas()

    def _handle_required_update(self, latest_version, current_version):
        """Handle forced manual updates that include required.txt."""
        try:
            if self.compare_versions(latest_version, current_version) <= 0:
                return False
            release_data = self._get_release_data(latest_version)
            if not release_data:
                return False
            assets = release_data.get('assets', [])
            requires_manual = any(asset.get('name', '').lower() == 'required.txt' for asset in assets)
            if not requires_manual:
                return False

            silent_print(f"Required update detected for version {latest_version}.")
            QTimer.singleShot(0, lambda: self._force_manual_update(latest_version))
            return True
        except Exception as e:
            silent_print(f"Error handling required update: {e}")
            return False

    def _force_manual_update(self, version):
        """Force user to install update manually."""
        try:
            silent_print("Launching manual update instructions in browser.")
            import webbrowser
            webbrowser.open("https://www.innioasis.app", new=2)
        except Exception as e:
            silent_print(f"Error opening manual update URL: {e}")
        finally:
            QTimer.singleShot(250, self.close)

    def run_selected_version_once(self):
        """Download and launch an older Innioasis Updater release without installing it."""
        if not self.version_combo:
            QMessageBox.information(self, "Run Once", "Select a version first.")
            return
        data = self.version_combo.currentData()
        if not data or not data.get('version'):
            QMessageBox.information(self, "Run Once", "Select a version first.")
            return

        selected_version = data.get('version')
        current_version = (self.app_version or APP_VERSION)
        normalized_selected = selected_version.lstrip('vV')
        normalized_current = current_version.lstrip('vV')
        try:
            if self.compare_versions(normalized_selected, normalized_current) >= 0:
                QMessageBox.information(
                    self,
                    "Run Once",
                    "This option is only available for versions older than the one you are currently running."
                )
                return
        except Exception:
            pass

        release = data.get('release') or {}
        tag_name = release.get('tag_name') or selected_version
        if not tag_name:
            QMessageBox.warning(self, "Run Once", "Unable to determine the release tag for this version.")
            return

        safe_version = re.sub(r'[^0-9A-Za-z._-]', '_', selected_version)
        destination = Path(f"firmware_downloader_{safe_version}.py")
        download_url = f"https://raw.githubusercontent.com/y1-community/Innioasis-Updater/{tag_name}/firmware_downloader.py"

        progress = QProgressDialog(f"Downloading Innioasis Updater {selected_version}‚Ä¶", None, 0, 0, self)
        progress.setWindowTitle("Run older version once")
        progress.setCancelButton(None)
        progress.setWindowModality(Qt.WindowModal)
        progress.show()
        self._run_once_progress_dialog = progress

        def finalize(success, error_message=None):
            try:
                progress.close()
            except Exception:
                pass
            self._run_once_progress_dialog = None
            if not success:
                QMessageBox.warning(
                    self,
                    "Run Once",
                    f"Failed to download Innioasis Updater {selected_version}.\n\n{error_message or 'Please try again later.'}"
                )
                return

            python_executable = sys.executable or shutil.which("python")
            if not python_executable:
                QMessageBox.warning(
                    self,
                    "Run Once",
                    "Unable to locate the Python executable to launch the downloaded version."
                )
                return

            try:
                popen_kwargs = {
                    "cwd": str(Path.cwd()),
                    "stdout": subprocess.DEVNULL,
                    "stderr": subprocess.DEVNULL,
                    "stdin": subprocess.DEVNULL,
                    "close_fds": platform.system() != "Windows",
                }
                if platform.system() == "Windows":
                    creation_flags = 0
                    for flag_name in ("CREATE_NEW_PROCESS_GROUP", "DETACHED_PROCESS", "CREATE_NO_WINDOW"):
                        if hasattr(subprocess, flag_name):
                            creation_flags |= getattr(subprocess, flag_name)
                    if creation_flags:
                        popen_kwargs["creationflags"] = creation_flags
                subprocess.Popen([str(python_executable), str(destination)], **popen_kwargs)
            except Exception as exc:
                QMessageBox.warning(
                    self,
                    "Run Once",
                    f"Unable to launch Innioasis Updater {selected_version}.\n\n{exc}"
                )
                return

            if getattr(self, '_active_settings_dialog', None):
                try:
                    self._active_settings_dialog.close()
                except Exception:
                    pass
            self.close()
            QTimer.singleShot(150, QApplication.instance().quit)

        def worker():
            try:
                response = requests.get(download_url, timeout=30)
                response.raise_for_status()
                destination.write_text(response.text, encoding='utf-8')
                QTimer.singleShot(0, lambda: finalize(True, None))
            except Exception as exc:
                QTimer.singleShot(0, lambda: finalize(False, str(exc)))

        threading.Thread(target=worker, daemon=True).start()

    def download_selected_version(self, settings_dialog=None):
        """Install the selected Innioasis Updater release directly from the GUI."""
        if not self.version_combo:
            QMessageBox.information(self, "Install Version", "Select a version first.")
            return
        data = self.version_combo.currentData()
        if not data:
            QMessageBox.information(self, "Install Version", "Select a version first.")
            return
        release = data.get('release')
        version = data.get('version')
        if not version:
            QMessageBox.warning(self, "Install Version", "Unable to determine release information.")
            return

        current_version = self.app_version or APP_VERSION
        normalized_version = version.lstrip('vV')
        normalized_current = current_version.lstrip('vV')
        is_windows = platform.system() == "Windows"
        is_older = False
        try:
            is_older = self.compare_versions(normalized_version, normalized_current) < 0
        except Exception:
            is_older = False

        if is_older and not is_windows:
            QMessageBox.information(
                self,
                "Install Version",
                "Installing older releases is disabled on this platform. "
                "Use 'Run older version once' to try this build without replacing your current installation."
            )
            return
        if is_older and is_windows:
            warning_message = (
                f"Innioasis Updater {version} is older than your current version {current_version}.\n\n"
                "Installing it will replace the copy you're running right now. "
                "To return to a newer build, launch the 'Innioasis Updater (latest)' Start Menu shortcut.\n\n"
                "Future updates to newer releases will continue to appear as usual. Continue with this rollback?"
            )
            reply = QMessageBox.warning(
                self,
                "Install older version",
                warning_message,
                QMessageBox.Yes | QMessageBox.Cancel,
                QMessageBox.Yes
            )
            if reply != QMessageBox.Yes:
                return

        tag_name = ""
        if release:
            tag_name = release.get('tag_name', "")
        if not tag_name:
            tag_name = version
        if tag_name and not tag_name.lower().startswith('v'):
            tag_name = f"v{tag_name}"

        if not release:
            release = self._get_release_data(version)
            if not release:
                QMessageBox.warning(self, "Install Version", "Unable to fetch release details for this version.")
                return

        if settings_dialog:
            try:
                self.save_settings(settings_dialog)
            except Exception as e:
                silent_print(f"Error saving settings before update: {e}")
            if settings_dialog.isVisible():
                # User cancelled settings save (e.g., shortcut prompt)
                return

        token = None
        try:
            if hasattr(self, 'github_api') and hasattr(self.github_api, 'tokens') and self.github_api.tokens:
                token = self.github_api.get_next_token()
        except Exception as e:
            silent_print(f"Warning: could not obtain GitHub token: {e}")

        install_dialog = ReleaseInstallDialog(self, version, release, token)
        result = install_dialog.exec()

        if result == QDialog.Accepted and install_dialog.success:
            QMessageBox.information(
                self,
                "Restart required",
                f"Innioasis Updater {version} has been installed.\nRestart the app to load the new version"
            )
            # 2025-11-09 18:45 UTC original restart logic kept for reference:
            # self.close()
            # QTimer.singleShot(200, QApplication.instance().quit)
            # Old behavior: the app quit after updating and relied on the user to relaunch it manually.
            self.close()
            self._schedule_post_update_relaunch()
        elif not install_dialog.success:
            error_message = install_dialog.error_message or "The selected version could not be installed."
            QMessageBox.warning(self, "Update not applied", error_message)

    def _ensure_legacy_updater_redirect(self):
        """Ensure legacy updater.py launches the main GUI by mirroring this module."""
        try:
            current_path = Path(__file__).resolve()
            updater_path = current_path.with_name("updater.py")
            if updater_path == current_path:
                return
            
            needs_update = True
            if updater_path.exists():
                try:
                    if updater_path.stat().st_size == current_path.stat().st_size:
                        with open(current_path, 'rb') as src, open(updater_path, 'rb') as dst:
                            if src.read() == dst.read():
                                needs_update = False
                except Exception as compare_error:
                    silent_print(f"Warning: unable to compare updater.py contents: {compare_error}")
                    needs_update = True
            if not needs_update:
                return
            
            with open(current_path, 'rb') as src, open(updater_path, 'wb') as dst:
                dst.write(src.read())
            silent_print("Legacy updater.py replaced with current firmware_downloader.py")
        except Exception as e:
            silent_print(f"Warning: could not refresh legacy updater.py: {e}")

    def _schedule_post_update_relaunch(self):
        """Schedule the automatic relaunch after a successful update."""
        # 2025-11-09 18:45 UTC update note: previously the GUI quit without relaunching; now we relaunch automatically.
        QTimer.singleShot(100, self._launch_updated_app)
        QTimer.singleShot(800, QApplication.instance().quit)

    def _launch_updated_app(self):
        """Launch the Innioasis Updater after installing a new release."""
        # 2025-11-09 18:45 UTC legacy behavior reference: manual relaunch by the user after quitting the GUI.
        try:
            system = platform.system()
            if system == "Darwin":
                app_path = Path.home() / "Applications" / "Innioasis Updater.app"
                if not app_path.exists():
                    fallback_path = Path("/Applications/Innioasis Updater.app")
                    if fallback_path.exists():
                        app_path = fallback_path
                if app_path.exists():
                    subprocess.Popen(
                        ["/usr/bin/open", str(app_path)],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL,
                        stdin=subprocess.DEVNULL
                    )
                else:
                    silent_print(f"Innioasis Updater.app not found in Applications folder: {app_path}")
            elif system == "Windows":
                script_path = Path(__file__).resolve()
                python_exe = Path(sys.executable)
                if python_exe.exists() and script_path.exists():
                    popen_kwargs = {
                        "cwd": str(Path.cwd()),
                        "stdout": subprocess.DEVNULL,
                        "stderr": subprocess.DEVNULL,
                        "stdin": subprocess.DEVNULL,
                        "close_fds": True,
                    }
                    creation_flags = 0
                    for flag_name in ("CREATE_NEW_PROCESS_GROUP", "DETACHED_PROCESS", "CREATE_NO_WINDOW"):
                        if hasattr(subprocess, flag_name):
                            creation_flags |= getattr(subprocess, flag_name)
                    if creation_flags:
                        popen_kwargs["creationflags"] = creation_flags
                    subprocess.Popen([str(python_exe), str(script_path)], **popen_kwargs)
                else:
                    silent_print("Unable to relaunch firmware_downloader.py automatically on Windows.")
            else:
                script_path = Path(__file__).resolve()
                subprocess.Popen(
                    [str(sys.executable), str(script_path)],
                    cwd=str(Path.cwd()),
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    stdin=subprocess.DEVNULL,
                    close_fds=True
                )
        except Exception as exc:
            silent_print(f"Failed to relaunch updated application: {exc}")

    def show_tools_dialog(self):
        """Show Toolkit dialog with all tools and utilities"""
        # For Windows users, check if Toolkit directory exists and open it directly
        if platform.system() == "Windows":
            current_dir = Path.cwd()
            toolkit_dir = current_dir / "Toolkit"
            
            if toolkit_dir.exists():
                # Toolkit directory exists, open it directly in File Explorer and return
                subprocess.run(["explorer", str(toolkit_dir)])
                self.status_label.setText("Toolkit folder opened in File Explorer")
                return  # Exit early, no need to show dialog
        
        # Check if Y1 model is selected
        selected_model = self.device_model_combo.currentText()
        is_y1_model = "Y1" in selected_model.upper()
        
        # Show dialog only if:
        # 1. Not on Windows, OR
        # 2. On Windows but Toolkit directory doesn't exist
        dialog = QDialog(self)
        dialog.setWindowTitle("Innioasis Toolkit")
        dialog.setFixedSize(600, 500)
        dialog.setModal(True)
        
        layout = QVBoxLayout(dialog)
        
        # Title
        title_label = QLabel("Innioasis Toolkit")
        title_label.setStyleSheet("font-size: 16px; font-weight: bold; margin: 10px;")
        layout.addWidget(title_label)
        
        # Description
        desc_label = QLabel("Access all Innioasis utilities and tools for your device")
        desc_label.setStyleSheet("color: #666; margin: 5px;")
        layout.addWidget(desc_label)
        
        # Main tools layout
        tools_layout = QVBoxLayout()
        
        # Tools for Innioasis Y1 section (only show if Y1 model is selected)
        if is_y1_model:
            y1_tools_group = QGroupBox("Tools for Innioasis Y1")
            y1_tools_layout = QVBoxLayout(y1_tools_group)
            
            # Y1 Remote Control button - using native styling
            y1_remote_btn = QPushButton("Launch Y1 Remote Control")
            y1_remote_btn.setToolTip("Open Y1 Remote Control application")
            # Use default cursor for native OS feel
            y1_remote_btn.clicked.connect(self.open_y1_remote_control)
            y1_tools_layout.addWidget(y1_remote_btn)
            
            # Theme installation options (only for non-Windows users)
            if platform.system() != "Windows":
                # Original Y1 Menu Themes button
                y1_menu_themes_btn = QPushButton("Original Y1 Menu Themes")
                y1_menu_themes_btn.setToolTip("Open Original Y1 Menu Themes in browser")
                y1_menu_themes_btn.clicked.connect(self.open_original_y1_menu_themes)
                y1_tools_layout.addWidget(y1_menu_themes_btn)
                
                # 240p Rockbox Themes button
                rockbox_240p_themes_btn = QPushButton("240p Rockbox Themes")
                rockbox_240p_themes_btn.setToolTip("Open 240p Rockbox Themes in browser")
                rockbox_240p_themes_btn.clicked.connect(self.open_240p_rockbox_themes)
                y1_tools_layout.addWidget(rockbox_240p_themes_btn)
                
                # 360p Rockbox Themes button
                rockbox_360p_themes_btn = QPushButton("360p Rockbox Themes")
                rockbox_360p_themes_btn.setToolTip("Open 360p Rockbox Themes in browser")
                rockbox_360p_themes_btn.clicked.connect(self.open_360p_rockbox_themes)
                y1_tools_layout.addWidget(rockbox_360p_themes_btn)
            
            tools_layout.addWidget(y1_tools_group)
        
        # Check for Utility Updates button - using native styling
        utility_update_btn = QPushButton("Check for Utility Updates")
        utility_update_btn.setToolTip("Download the latest updater.py script")
        # Use default cursor for native OS feel
        utility_update_btn.clicked.connect(self.check_for_utility_updates)
        tools_layout.addWidget(utility_update_btn)
        
        # Storage Management Tool button (All platforms) - using native styling
        storage_btn = QPushButton("Manage Storage")
        storage_btn.setToolTip("Analyze and clean up unnecessary files in the project directory")
        # Use default cursor for native OS feel
        storage_btn.clicked.connect(self.launch_storage_management_tool)
        tools_layout.addWidget(storage_btn)
        
        # Rockbox Utility button (Windows only) - using native styling
        if platform.system() == "Windows":
            rockbox_utility_btn = QPushButton("Rockbox Utility")
            rockbox_utility_btn.setToolTip("Launch Rockbox Utility for Y1 device management")
            # Use default cursor for native OS feel
            rockbox_utility_btn.clicked.connect(self.launch_rockbox_utility)
            tools_layout.addWidget(rockbox_utility_btn)
        
        # Try New Features button - using native styling
        try_new_features_btn = QPushButton("Try New Features")
        try_new_features_btn.setToolTip("Download and run the latest test version with new features")
        # Use default cursor for native OS feel
        try_new_features_btn.clicked.connect(lambda: self.try_new_features(dialog))
        tools_layout.addWidget(try_new_features_btn)
        
        # Note: "Open Toolkit in Windows Explorer" button removed as it's now redundant
        # The Toolkit folder opens directly when the Toolkit button is clicked (if directory exists)
        
        layout.addLayout(tools_layout)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        close_btn = QPushButton("Close")
        # Use native styling - no custom stylesheet for automatic theme adaptation
        # Use default cursor for native OS feel
        close_btn.clicked.connect(dialog.accept)
        button_layout.addWidget(close_btn)
        
        layout.addLayout(button_layout)
        
        dialog.exec()
    
    def load_whats_new_release_notes(self, browser):
        """Load release notes for the current app version from GitHub"""
        try:
            # Get current app version
            current_version = self.app_version or APP_VERSION
            
            # Get theme-aware text color
            text_color = self._get_text_color_for_theme()
            
            # Show loading message
            loading_html = f"""<html>
            <head>
                <style>
                    body, div, p {{ color: {text_color} !important; }}
                </style>
            </head>
            <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>
                <p style='color: {text_color} !important;'>Loading release notes...</p>
            </body>
            </html>"""
            browser.setHtml(loading_html)
            
            # Fetch release notes in background
            QTimer.singleShot(100, lambda: self._fetch_app_release_notes_async(browser, current_version, text_color))
            
        except Exception as e:
            silent_print(f"Error loading What's New: {e}")
            import traceback
            traceback.print_exc()
            # Show error message
            text_color = self._get_text_color_for_theme()
            error_html = f"""<html>
            <head>
                <style>
                    body, div, p {{ color: {text_color} !important; }}
                </style>
            </head>
            <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>
                <p style='color: {text_color} !important;'>Error loading release notes: {str(e)}</p>
            </body>
            </html>"""
            browser.setHtml(error_html)
    
    def _fetch_app_release_notes_async(self, browser, version, text_color):
        """Fetch release notes asynchronously"""
        try:
            # GitHub repository for the app
            repo_owner = "y1-community"
            repo_name = "Innioasis-Updater"
            
            # Try to find release with matching tag
            # Tags might be "v1.8.2", "1.8.2", or similar
            possible_tags = [f"v{version}", version, f"V{version}"]
            
            release_notes = None
            release_name = None
            
            # Use GitHub API to fetch releases
            api_url = f"https://api.github.com/repos/{repo_owner}/{repo_name}/releases"
            
            try:
                response = requests.get(api_url, timeout=10)
                if response.status_code == 200:
                    releases = response.json()
                    # Find release with matching tag
                    for release in releases:
                        tag = release.get('tag_name', '')
                        if tag in possible_tags or tag.replace('v', '').replace('V', '') == version:
                            release_notes = release.get('body', '')
                            release_name = release.get('name', '') or release.get('tag_name', '')
                            break
            except Exception as e:
                silent_print(f"Error fetching release notes from GitHub: {e}")
            
            # Format release notes similar to firmware release notes
            import html as html_module
            import re
            
            if release_notes and release_name:
                # Escape release name
                safe_release_name = html_module.escape(str(release_name))
                
                notes_html = f"""<html>
                <head>
                    <style>
                        body, div, p, h1, h2, h3, h4, h5, h6, ul, ol, li, span, a {{
                            color: {text_color} !important;
                        }}
                    </style>
                </head>
                <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>"""
                notes_html += f"<h2 style='margin-top: 0; color: {text_color} !important;'>{safe_release_name}</h2>"
                
                # Convert markdown to HTML (same logic as firmware release notes)
                raw_notes_text = str(release_notes)
                # 2025-11-09 23:50 UTC original behavior kept the introductory text that sometimes repeated install instructions.
                # New behavior trims everything before headings like 'What's new', 'Changes', 'New in', or 'Changelog' for cleaner changelog displays.
                strip_keywords = ("what's new", "whats new", "changes", "changelog", "new in")
                raw_lines = raw_notes_text.splitlines()
                start_index = 0
                for idx, raw_line in enumerate(raw_lines):
                    sanitized = raw_line.strip().replace('‚Äô', "'")
                    sanitized = sanitized.lstrip('#*_>-+‚Ä¢ ').strip()
                    sanitized = re.sub(r'^\d+[\.)]\s*', '', sanitized)
                    sanitized_lower = sanitized.lower()
                    if any(sanitized_lower.startswith(keyword) for keyword in strip_keywords):
                        start_index = idx
                        break
                in_list = False
                lines = raw_lines[start_index:]
                converted_lines = []
                
                for line in lines:
                    line_stripped = line.strip()
                    
                    # Check for headers
                    if line_stripped.startswith('### '):
                        text = line_stripped[4:].strip()
                        if not in_list:
                            converted_lines.append(f'<h4 style="color: {text_color} !important;">{text}</h4>')
                        else:
                            converted_lines.append('</ul>')
                            converted_lines.append(f'<h4 style="color: {text_color} !important;">{text}</h4>')
                            in_list = False
                    elif line_stripped.startswith('## '):
                        text = line_stripped[3:].strip()
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        converted_lines.append(f'<h3 style="color: {text_color} !important;">{text}</h3>')
                    elif line_stripped.startswith('# '):
                        text = line_stripped[2:].strip()
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        converted_lines.append(f'<h2 style="color: {text_color} !important;">{text}</h2>')
                    # Check for lists
                    elif line_stripped.startswith('- ') or line_stripped.startswith('* '):
                        if not in_list:
                            converted_lines.append(f'<ul style="color: {text_color} !important;">')
                            in_list = True
                        text = line_stripped[2:].strip()
                        text = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)
                        converted_lines.append(f'<li style="color: {text_color} !important;">{text}</li>')
                    elif line_stripped == '':
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        converted_lines.append('<br>')
                    else:
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        if line_stripped:
                            processed_line = line_stripped
                            processed_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', processed_line)
                            converted_lines.append(f'<span style="color: {text_color} !important;">{processed_line}</span><br>')
                
                if in_list:
                    converted_lines.append('</ul>')
                
                body_html = ''.join(converted_lines)
                if body_html.strip():
                    if not body_html.strip().startswith('<'):
                        body_html = f'<p style="color: {text_color} !important;">{body_html}</p>'
                
                notes_html += body_html
                notes_html += "</body></html>"
                
                browser.setHtml(notes_html)
            else:
                # No release notes found
                notes_html = f"""<html>
                <head>
                    <style>
                        body, div, p {{ color: {text_color} !important; }}
                    </style>
                </head>
                <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>
                    <h2 style='margin-top: 0; color: {text_color} !important;'>Version {version}</h2>
                    <p style='color: {text_color} !important; font-style: italic;'>Release notes not available for this version.</p>
                </body>
                </html>"""
                browser.setHtml(notes_html)
                
        except Exception as e:
            silent_print(f"Error fetching app release notes: {e}")
            import traceback
            traceback.print_exc()
            # Show error message
            error_html = f"""<html>
            <head>
                <style>
                    body, div, p {{ color: {text_color} !important; }}
                </style>
            </head>
            <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>
                <p style='color: {text_color} !important;'>Error loading release notes: {str(e)}</p>
            </body>
            </html>"""
            browser.setHtml(error_html)
    
    def save_settings(self, dialog):
        """Save all settings including installation method and shortcut preferences"""
        # Save installation method settings
        if getattr(self, 'method_combo', None):
            self.installation_method = self.method_combo.currentData()
        # Always use method functionality removed
        # Debug mode is now controlled by keyboard shortcut, not saved in settings
        
        # Automatic updates are now manual by default - no setting to save
        
        # Save shortcut settings (Windows only)
        if platform.system() == "Windows":
            self.desktop_updater_enabled = self.desktop_updater_checkbox.isChecked()
            self.desktop_toolkit_enabled = self.desktop_toolkit_checkbox.isChecked()
            self.startmenu_updater_enabled = self.startmenu_updater_checkbox.isChecked()
            self.startmenu_toolkit_enabled = self.startmenu_toolkit_checkbox.isChecked()
            # auto_cleanup_enabled is always True and not user-configurable
            
            # Check if no shortcuts are selected and warn user
            has_any_shortcuts = (self.desktop_updater_enabled or self.desktop_toolkit_enabled or 
                               self.startmenu_updater_enabled or self.startmenu_toolkit_enabled)
            if not has_any_shortcuts:
                if not self.show_no_shortcuts_warning():
                    return  # Don't save settings if user cancels
            
            # Check if user has only toolkit shortcuts (no direct updater shortcuts) and show helpful dialog
            has_direct_updater_shortcuts = (self.desktop_updater_enabled or self.startmenu_updater_enabled)
            has_toolkit_shortcuts = (self.desktop_toolkit_enabled or self.startmenu_toolkit_enabled)
            
            if has_toolkit_shortcuts and not has_direct_updater_shortcuts:
                # User has toolkit shortcuts but no direct updater shortcuts - show helpful dialog
                self.show_toolkit_only_help_dialog()
            
            # Ensure Skip Update shortcut exists if auto-updates are disabled
            if True:  # Manual updates by default
                if not self.ensure_skip_update_shortcut_exists():
                    silent_print("Warning: Could not ensure Skip Update shortcut exists when saving settings")
            
            # Apply shortcut settings immediately (this will use the updated auto-updates setting)
            self.apply_shortcut_settings()
        
        # Save USB drive path if Smart Drop tab was shown
        if hasattr(self, 'smart_drop_path_display') and self.smart_drop_path_display:
            path_text = self.smart_drop_path_display.text().strip()
            if path_text:
                self.save_usb_drive_path(path_text)
            else:
                self.save_usb_drive_path(None)
        
        # Save to persistent storage
        self.save_installation_preferences()
        
        # Update status message
        self.status_label.setText(f"Installation method set to: {self.installation_method} (one-time use)")
        
        if self.debug_mode:
            self.status_label.setText(self.status_label.text() + " - Debug mode enabled")
        
        if self._current_update_checkbox:
            self.suppress_update_notifications = self._current_update_checkbox.isChecked()

        dialog.accept()
    
    def show_no_shortcuts_warning(self):
        """Show warning dialog when no shortcut options are selected"""
        msg = QMessageBox(self)
        msg.setWindowTitle("No Shortcuts Selected")
        msg.setIcon(QMessageBox.Warning)
        msg.setText("No shortcut options are selected!")
        msg.setInformativeText(
            "If you proceed without creating shortcuts, you will need to manually run:\n\n"
            '"%LocalAppData%\\Innioasis Updater\\pythonw.exe" firmware_downloader.py\n\n'
            "to use Innioasis Updater in the future.\n\n"
            "Are you sure you want to continue without shortcuts?"
        )
        
        # Set Cancel as the default button
        cancel_btn = msg.addButton("Cancel", QMessageBox.RejectRole)
        continue_btn = msg.addButton("Continue Anyway", QMessageBox.AcceptRole)
        msg.setDefaultButton(cancel_btn)
        
        result = msg.exec()
        
        # If user clicked Cancel, don't save settings
        if msg.clickedButton() == cancel_btn:
            return False
        
        return True
    
    def save_installation_preferences(self):
        """Save installation preferences to persistent storage"""
        try:
            preferences = {
                # Don't save installation_method - always defaults to Method 1 on startup
                'debug_mode': getattr(self, 'debug_mode', False),
                'suppress_update_notifications': getattr(self, 'suppress_update_notifications', False)
            }
            
            # Add shortcut preferences (Windows only)
            if platform.system() == "Windows":
                preferences.update({
                    'desktop_updater_enabled': getattr(self, 'desktop_updater_enabled', True),
                    'desktop_toolkit_enabled': getattr(self, 'desktop_toolkit_enabled', False),  # Default: Desktop Updater only
                    'startmenu_updater_enabled': getattr(self, 'startmenu_updater_enabled', True),
                    'startmenu_toolkit_enabled': getattr(self, 'startmenu_toolkit_enabled', True),  # Default: Start Menu Updater + Toolkit
                    'toolkit_help_dialog_shown': getattr(self, '_toolkit_help_dialog_shown', False)
                    # auto_cleanup_enabled is always True and not saved to preferences
                })
            
            # Save to a JSON file in the same directory
            preferences_file = Path("installation_preferences.json")
            import json
            with open(preferences_file, 'w') as f:
                json.dump(preferences, f, indent=2)
                
            silent_print(f"Saved installation preferences: {preferences}")
        except Exception as e:
            silent_print(f"Error saving installation preferences: {e}")
    
    def load_installation_preferences(self):
        """Load installation preferences from persistent storage"""
        try:
            preferences_file = Path("installation_preferences.json")
            if preferences_file.exists():
                import json
                with open(preferences_file, 'r') as f:
                    preferences = json.load(f)
                
                # Always default to Method 1 on startup, regardless of saved preferences
                # Method changes in settings are only temporary for the current session
                if platform.system() == "Windows":
                    self.installation_method = "spflash"  # Always Method 1 on Windows
                else:
                    self.installation_method = "guided"  # Always Method 1 on other platforms
                
                # Load other preferences (but not installation_method)
                if 'debug_mode' in preferences:
                    self.debug_mode = preferences['debug_mode']
                if 'suppress_update_notifications' in preferences:
                    self.suppress_update_notifications = preferences['suppress_update_notifications']
                
                # Load shortcut preferences (Windows only)
                if platform.system() == "Windows":
                    if 'desktop_updater_enabled' in preferences:
                        self.desktop_updater_enabled = preferences['desktop_updater_enabled']
                    if 'desktop_toolkit_enabled' in preferences:
                        self.desktop_toolkit_enabled = preferences['desktop_toolkit_enabled']
                    if 'startmenu_updater_enabled' in preferences:
                        self.startmenu_updater_enabled = preferences['startmenu_updater_enabled']
                    if 'startmenu_toolkit_enabled' in preferences:
                        self.startmenu_toolkit_enabled = preferences['startmenu_toolkit_enabled']
                    if 'toolkit_help_dialog_shown' in preferences:
                        self._toolkit_help_dialog_shown = preferences['toolkit_help_dialog_shown']
                    # auto_cleanup_enabled is always True and not loaded from preferences
                
                # Automatic updates are now manual by default - no preferences to load
                
                silent_print(f"Loaded preferences (method reset to default): {preferences}")
            else:
                silent_print("No saved installation preferences found, detecting existing shortcuts")
                # Detect existing shortcuts and set preferences accordingly for new users
                if platform.system() == "Windows":
                    self.detect_existing_shortcuts_and_set_preferences()
                else:
                    # Non-Windows platforms use defaults - automatic updates are manual by default
                    pass
        except Exception as e:
            silent_print(f"Error loading installation preferences: {e}")
    
    def detect_existing_shortcuts_and_set_preferences(self):
        """Detect existing shortcuts and set preferences accordingly for new users"""
        try:
            silent_print("Detecting existing shortcuts to determine user preferences...")
            
            # Check desktop shortcuts
            desktop_path = Path.home() / "Desktop"
            desktop_updater_exists = (desktop_path / "Innioasis Updater.lnk").exists()
            desktop_toolkit_exists = (desktop_path / "Innioasis Toolkit.lnk").exists()
            
            # Check start menu shortcuts
            start_menu_paths = self.get_all_start_menu_paths()
            startmenu_updater_exists = False
            startmenu_toolkit_exists = False
            
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    if (start_menu_path / "Innioasis Updater.lnk").exists():
                        startmenu_updater_exists = True
                    if (start_menu_path / "Innioasis Toolkit.lnk").exists():
                        startmenu_toolkit_exists = True
                    break  # Only check first available start menu path
            
            # Set preferences based on detected shortcuts
            self.desktop_updater_enabled = desktop_updater_exists
            self.desktop_toolkit_enabled = desktop_toolkit_exists
            self.startmenu_updater_enabled = startmenu_updater_exists
            self.startmenu_toolkit_enabled = startmenu_toolkit_exists
            self._toolkit_help_dialog_shown = False  # New user, haven't shown dialog yet
            
            # Determine auto-updates setting based on shortcut types
            # If any shortcuts exist, check if they're "Skip Update" type
            silent_print(f"Detected shortcuts - Desktop Updater: {desktop_updater_exists}, Desktop Toolkit: {desktop_toolkit_exists}, Start Menu Updater: {startmenu_updater_exists}, Start Menu Toolkit: {startmenu_toolkit_exists}")
            
            # Automatic updates are now manual by default - no need to detect or set auto-updates preferences
            
            # Save the detected preferences so they persist
            self.save_installation_preferences()
            silent_print("Saved detected preferences to file")
            
        except Exception as e:
            silent_print(f"Error detecting existing shortcuts: {e}")
            # Fall back to defaults if detection fails
            self.desktop_updater_enabled = True  # Desktop: Innioasis Updater.lnk
            self.desktop_toolkit_enabled = False  # Desktop: No Toolkit
            self.startmenu_updater_enabled = True  # Start Menu: Innioasis Updater.lnk
            self.startmenu_toolkit_enabled = True  # Start Menu: Innioasis Toolkit.lnk
            # Automatic updates are now manual by default
            self._toolkit_help_dialog_shown = False
    
    def detect_skip_update_shortcuts(self):
        """Detect if existing shortcuts are 'Skip Update' type by checking their targets"""
        try:
            # Check desktop shortcut
            desktop_path = Path.home() / "Desktop"
            desktop_shortcut = desktop_path / "Innioasis Updater.lnk"
            
            if desktop_shortcut.exists():
                # Try to read the shortcut target to see if it points to Skip Update
                # This is a simplified check - in practice, we'd need to parse the .lnk file
                # For now, we'll check if the Skip Update shortcut exists in the expected location
                skip_update_shortcut = Path("Troubleshooting/More Tools and Troubleshooters/Skip Update and Launch.lnk")
                if skip_update_shortcut.exists():
                    # If Skip Update shortcut exists, assume existing shortcuts might be that type
                    # This is a heuristic - in a real implementation, we'd parse the .lnk files
                    return True
            
            # Check start menu shortcuts
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    startmenu_shortcut = start_menu_path / "Innioasis Updater.lnk"
                    if startmenu_shortcut.exists():
                        # Same heuristic as desktop
                        skip_update_shortcut = Path("Troubleshooting/More Tools and Troubleshooters/Skip Update and Launch.lnk")
                        if skip_update_shortcut.exists():
                            return True
                    break
            
            return False
            
        except Exception as e:
            silent_print(f"Error detecting skip update shortcuts: {e}")
            return False
    
    def apply_shortcut_settings(self):
        """Apply shortcut settings based on user preferences"""
        if platform.system() != "Windows":
            return
            
        try:
            # Apply individual desktop shortcut settings
            desktop_updater_enabled = getattr(self, 'desktop_updater_enabled', True)
            desktop_toolkit_enabled = getattr(self, 'desktop_toolkit_enabled', False)
            silent_print(f"Desktop shortcuts - Updater: {desktop_updater_enabled}, Toolkit: {desktop_toolkit_enabled}")
            
            if desktop_updater_enabled:
                self.ensure_desktop_updater_shortcut()
            else:
                self.remove_desktop_updater_shortcut()
            
            if desktop_toolkit_enabled:
                self.ensure_desktop_toolkit_shortcut()
            else:
                self.remove_desktop_toolkit_shortcut()
            
            # Apply individual start menu shortcut settings
            if getattr(self, 'startmenu_updater_enabled', True):
                self.ensure_startmenu_updater_shortcut()
            else:
                self.remove_startmenu_updater_shortcut()
            
            if getattr(self, 'startmenu_toolkit_enabled', True):
                self.ensure_startmenu_toolkit_shortcut()
            else:
                self.remove_startmenu_toolkit_shortcut()
            
            # Check and manage toolkit updater shortcut based on current settings
            self.check_and_manage_toolkit_updater_shortcut()
                
        except Exception as e:
            silent_print(f"Error applying shortcut settings: {e}")
    
    def manual_shortcut_cleanup(self):
        """Manually clean up shortcuts and create current ones - silent operation"""
        if platform.system() != "Windows":
            return
            
        try:
            # Silent cleanup using wildcards
            self.silent_shortcut_cleanup()
            
            # Create current shortcuts if enabled
            if self.desktop_shortcuts_enabled:
                self.ensure_desktop_shortcuts()
            if self.startmenu_shortcuts_enabled:
                self.ensure_startmenu_shortcuts()
                
            silent_print("Shortcut cleanup completed successfully.")
            
        except Exception as e:
            silent_print(f"Error during shortcut cleanup: {e}")
    
    def silent_shortcut_cleanup(self):
        """Silent cleanup of shortcuts using wildcards - no user interaction"""
        if platform.system() != "Windows":
            return
            
        try:
            cleaned_count = 0
            
            # Clean up desktop shortcuts
            desktop_path = Path.home() / "Desktop"
            if desktop_path.exists():
                # Remove shortcuts matching patterns
                patterns = ["*Y1*", "*SP Flash*", "*Innioasis*"]
                for pattern in patterns:
                    for item in desktop_path.glob(pattern):
                        if item.is_file() and item.suffix.lower() == '.lnk':
                            try:
                                item.unlink()
                                cleaned_count += 1
                                silent_print(f"Removed desktop shortcut: {item.name}")
                            except Exception as e:
                                silent_print(f"Error removing {item.name}: {e}")
            
            # Clean up start menu shortcuts
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    # Remove shortcuts matching patterns
                    patterns = ["*Y1*", "*SP Flash*", "*Innioasis*"]
                    for pattern in patterns:
                        for item in start_menu_path.glob(pattern):
                            if item.is_file() and item.suffix.lower() == '.lnk':
                                try:
                                    item.unlink()
                                    cleaned_count += 1
                                    silent_print(f"Removed start menu shortcut: {item.name}")
                                except Exception as e:
                                    silent_print(f"Error removing {item.name}: {e}")
                    
                    # Remove Y1 Helper folder if it exists
                    y1_helper_folder = start_menu_path / "Y1 Helper"
                    if y1_helper_folder.exists() and y1_helper_folder.is_dir():
                        try:
                            shutil.rmtree(y1_helper_folder)
                            cleaned_count += 1
                            silent_print(f"Removed Y1 Helper folder: {y1_helper_folder}")
                        except Exception as e:
                            silent_print(f"Error removing Y1 Helper folder: {e}")
            
            silent_print(f"Silent shortcut cleanup completed: {cleaned_count} items removed")
            
        except Exception as e:
            silent_print(f"Error during silent shortcut cleanup: {e}")
    
    def get_appropriate_shortcut_source(self):
        """Get the appropriate shortcut source based on auto-updates setting"""
        if platform.system() != "Windows":
            return None
            
        current_dir = Path.cwd()
        
        # Check if auto-updates are enabled
        auto_updates_enabled = False  # Manual updates by default
        silent_print(f"Getting shortcut source - Auto-updates enabled: {auto_updates_enabled}")
        
        if auto_updates_enabled:
            # Auto-updates enabled: use regular Innioasis Updater.lnk
            source_shortcut = current_dir / "Innioasis Updater.lnk"
            silent_print(f"Looking for regular shortcut: {source_shortcut}")
        else:
            # Auto-updates disabled: use Skip Update and Launch.lnk
            # Try multiple possible locations for the Skip Update and Launch.lnk file
            possible_paths = [
                current_dir / "Troubleshooting" / "More Tools and Troubleshooters" / "Skip Update and Launch.lnk",
                current_dir / "Troubleshooting" / "More Tools and Troubleshooters" / "Fix PC App and PC App Updates" / "Skip Update and Launch.lnk",
                current_dir / "More Tools and Troubleshooters" / "Skip Update and Launch.lnk"
            ]
            
            source_shortcut = None
            for path in possible_paths:
                if path.exists():
                    source_shortcut = path
                    break
            silent_print(f"Looking for skip-update shortcut: {source_shortcut}")
        
        if source_shortcut:
            exists = source_shortcut.exists()
            silent_print(f"Shortcut source exists: {exists}")
            if exists:
                return source_shortcut
            else:
                silent_print(f"Shortcut source not found at: {source_shortcut}")
        else:
            silent_print("No valid shortcut source path found")
        
        return None

    def ensure_skip_update_shortcut_exists(self):
        """Ensure the Skip Update and Launch.lnk file exists (Windows only)"""
        if platform.system() != "Windows":
            return False
            
        try:
            current_dir = Path.cwd()
            
            # Try to find existing Skip Update and Launch.lnk
            possible_paths = [
                current_dir / "Troubleshooting" / "More Tools and Troubleshooters" / "Skip Update and Launch.lnk",
                current_dir / "Troubleshooting" / "More Tools and Troubleshooters" / "Fix PC App and PC App Updates" / "Skip Update and Launch.lnk",
                current_dir / "More Tools and Troubleshooters" / "Skip Update and Launch.lnk"
            ]
            
            for path in possible_paths:
                if path.exists():
                    silent_print(f"Found existing Skip Update and Launch.lnk at: {path}")
                    return True
            
            # If not found, create it by copying the regular shortcut and modifying it
            regular_shortcut = current_dir / "Innioasis Updater.lnk"
            if not regular_shortcut.exists():
                silent_print("Cannot create Skip Update shortcut: Innioasis Updater.lnk not found")
                return False
            
            # Create the directory structure if it doesn't exist
            target_dir = current_dir / "Troubleshooting" / "More Tools and Troubleshooters"
            target_dir.mkdir(parents=True, exist_ok=True)
            
            # Copy the regular shortcut to create the skip update version
            skip_update_shortcut = target_dir / "Skip Update and Launch.lnk"
            shutil.copy2(regular_shortcut, skip_update_shortcut)
            
            silent_print(f"Created Skip Update and Launch.lnk at: {skip_update_shortcut}")
            
            # Also overwrite the main Innioasis Updater.lnk with the skip update version (manual updates by default)
            main_shortcut = current_dir / "Innioasis Updater.lnk"
            try:
                shutil.copy2(regular_shortcut, main_shortcut)
                silent_print(f"Overwrote main Innioasis Updater.lnk with skip-update type")
            except Exception as e:
                silent_print(f"Error overwriting main Innioasis Updater.lnk: {e}")
            
            return True
            
        except Exception as e:
            silent_print(f"Error ensuring Skip Update shortcut exists: {e}")
            return False

    # Method removed - automatic updates are now manual by default
    # Legacy updater.py method no longer used - app handles updates internally

    def update_driver_dependent_ui(self):
        """Update UI elements that depend on driver status (called after UI loads)"""
        if platform.system() != "Windows" or not hasattr(self, 'driver_buttons_container'):
            return
            
        try:
            # Clear existing buttons
            while self.driver_buttons_layout.count():
                child = self.driver_buttons_layout.takeAt(0)
                if child.widget():
                    child.widget().deleteLater()
            
            # Check driver status (now in background)
            driver_info = self.check_drivers_and_architecture()
            
            if not driver_info['has_mtk_driver'] and not driver_info['has_usbdk_driver']:
                # No drivers: Show "Install MediaTek & UsbDk Drivers" button
                driver_btn = QPushButton("üîß Install MediaTek & UsbDk Drivers")
                # Use default cursor for native OS feel
                driver_btn.clicked.connect(self.open_driver_setup_link)
                self.driver_buttons_layout.addWidget(driver_btn)
                
            elif driver_info['has_mtk_driver'] and not driver_info['has_usbdk_driver']:
                # Only MTK driver: Show "Browse Files" button
                install_zip_btn = QPushButton("üìÅ Browse Files")
                install_zip_btn.clicked.connect(self.browse_files)
                self.driver_buttons_layout.addWidget(install_zip_btn)
                
            else:
                # Both drivers available: Show "Browse Files" button
                install_zip_btn = QPushButton("üìÅ Browse Files")
                install_zip_btn.clicked.connect(self.browse_files)
                self.driver_buttons_layout.addWidget(install_zip_btn)
                    
            silent_print("Driver-dependent UI updated in background")
            
        except Exception as e:
            silent_print(f"Error updating driver-dependent UI: {e}")

    def test_shortcut_replacement(self):
        """Test method to manually trigger shortcut replacement (for debugging)"""
        if platform.system() != "Windows":
            silent_print("Shortcut replacement test only available on Windows")
            return
            
        try:
            silent_print("=== Testing Shortcut Replacement ===")
            
            # Test getting appropriate source
            source = self.get_appropriate_shortcut_source()
            if source:
                silent_print(f"Current source shortcut: {source}")
            else:
                silent_print("No source shortcut found")
            
            # Test desktop shortcut replacement
            desktop_path = Path.home() / "Desktop"
            desktop_shortcut = desktop_path / "Innioasis Updater.lnk"
            silent_print(f"Desktop shortcut exists: {desktop_shortcut.exists()}")
            
            # Test start menu shortcuts
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    start_menu_shortcut = start_menu_path / "Innioasis Updater.lnk"
                    if start_menu_shortcut.exists():
                        silent_print(f"Start menu shortcut exists at: {start_menu_shortcut}")
            
            silent_print("=== End Shortcut Replacement Test ===")
            
        except Exception as e:
            silent_print(f"Error during shortcut replacement test: {e}")
            import traceback
            silent_print(f"Full error traceback: {traceback.format_exc()}")

    def test_shortcut_magic(self):
        """Test the magical shortcut replacement functionality (for debugging)"""
        if platform.system() != "Windows":
            silent_print("Shortcut magic test only available on Windows")
            return
            
        try:
            silent_print("=== Testing Shortcut Magic ===")
            
            # Test current auto-updates setting
            auto_updates_enabled = False  # Manual updates by default
            silent_print(f"Current auto-updates setting: {auto_updates_enabled}")
            
            # Test Skip Update shortcut existence
            skip_exists = self.ensure_skip_update_shortcut_exists()
            silent_print(f"Skip Update shortcut exists: {skip_exists}")
            
            # Test getting appropriate source
            source = self.get_appropriate_shortcut_source()
            if source:
                silent_print(f"Appropriate shortcut source: {source}")
            else:
                silent_print("No appropriate shortcut source found")
            
            # Test desktop shortcut
            desktop_path = Path.home() / "Desktop"
            desktop_shortcut = desktop_path / "Innioasis Updater.lnk"
            silent_print(f"Desktop shortcut exists: {desktop_shortcut.exists()}")
            
            # Test start menu shortcuts
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    start_menu_shortcut = start_menu_path / "Innioasis Updater.lnk"
                    if start_menu_shortcut.exists():
                        silent_print(f"Start menu shortcut exists at: {start_menu_shortcut}")
            
            silent_print("=== End Shortcut Magic Test ===")
            
        except Exception as e:
            silent_print(f"Error during shortcut magic test: {e}")
            import traceback
            silent_print(f"Full error traceback: {traceback.format_exc()}")

    def ensure_desktop_shortcuts(self):
        """Ensure desktop shortcuts exist - uses appropriate shortcut based on auto-updates setting and respects preferences"""
        if platform.system() != "Windows":
            return
            
        try:
            desktop_path = Path.home() / "Desktop"
            if not desktop_path.exists():
                return
            
            # Check desktop Updater preference
            desktop_updater_enabled = getattr(self, 'desktop_updater_enabled', True)
            if desktop_updater_enabled:
                # Get the appropriate shortcut source
                source_shortcut = self.get_appropriate_shortcut_source()
                if source_shortcut:
                    dest_shortcut = desktop_path / "Innioasis Updater.lnk"
                    # Force replacement of existing shortcut
                    if dest_shortcut.exists():
                        try:
                            dest_shortcut.unlink()  # Remove existing shortcut
                            silent_print(f"Removed existing desktop shortcut: Innioasis Updater.lnk")
                        except Exception as e:
                            silent_print(f"Warning: Could not remove existing shortcut: {e}")
                    
                    # Copy the new shortcut
                    shutil.copy2(source_shortcut, dest_shortcut)
                    auto_updates_enabled = False  # Manual updates by default
                    shortcut_type = "regular" if auto_updates_enabled else "skip-update"
                    silent_print(f"Created/updated desktop shortcut: Innioasis Updater.lnk ({shortcut_type})")
                else:
                    silent_print(f"Warning: Appropriate shortcut source not found")
            else:
                # Remove desktop Updater shortcut if preference is disabled
                dest_shortcut = desktop_path / "Innioasis Updater.lnk"
                if dest_shortcut.exists():
                    try:
                        dest_shortcut.unlink()
                        silent_print(f"Removed desktop Updater shortcut (preference disabled)")
                    except Exception as e:
                        silent_print(f"Warning: Could not remove desktop Updater shortcut: {e}")
            
            # Check desktop Toolkit preference
            desktop_toolkit_enabled = getattr(self, 'desktop_toolkit_enabled', False)
            if desktop_toolkit_enabled:
                current_dir = Path.cwd()
                source_toolkit = current_dir / "Innioasis Toolkit.lnk"
                if source_toolkit.exists():
                    dest_toolkit = desktop_path / "Innioasis Toolkit.lnk"
                    # Force replacement of existing shortcut
                    if dest_toolkit.exists():
                        try:
                            dest_toolkit.unlink()
                            silent_print(f"Removed existing desktop shortcut: Innioasis Toolkit.lnk")
                        except Exception as e:
                            silent_print(f"Warning: Could not remove existing shortcut: {e}")
                    
                    # Copy the new shortcut
                    shutil.copy2(source_toolkit, dest_toolkit)
                    silent_print(f"Created/updated desktop shortcut: Innioasis Toolkit.lnk")
                else:
                    silent_print(f"Warning: Innioasis Toolkit.lnk not found in current directory")
            else:
                # Remove desktop Toolkit shortcut if preference is disabled
                dest_toolkit = desktop_path / "Innioasis Toolkit.lnk"
                if dest_toolkit.exists():
                    try:
                        dest_toolkit.unlink()
                        silent_print(f"Removed desktop Toolkit shortcut (preference disabled)")
                    except Exception as e:
                        silent_print(f"Warning: Could not remove desktop Toolkit shortcut: {e}")
                    
        except Exception as e:
            silent_print(f"Error ensuring desktop shortcuts: {e}")
    
    def remove_desktop_shortcuts(self):
        """Remove desktop shortcuts - includes wildcard cleanup for legacy shortcuts"""
        if platform.system() != "Windows":
            return
            
        try:
            desktop_path = Path.home() / "Desktop"
            if not desktop_path.exists():
                return
            
            # Remove current and legacy shortcuts using wildcards
            patterns = ["*Innioasis*", "*Y1*", "*SP Flash*"]
            for pattern in patterns:
                for item in desktop_path.glob(pattern):
                    if item.is_file() and item.suffix.lower() == '.lnk':
                        try:
                            item.unlink()
                            silent_print(f"Removed desktop shortcut: {item.name}")
                        except Exception as e:
                            silent_print(f"Error removing {item.name}: {e}")
                            
        except Exception as e:
            silent_print(f"Error removing desktop shortcuts: {e}")
    
    def ensure_startmenu_shortcuts(self):
        """Ensure start menu shortcuts exist - uses appropriate shortcut based on auto-updates setting and respects preferences"""
        if platform.system() != "Windows":
            return
            
        try:
            start_menu_paths = self.get_all_start_menu_paths()
            current_dir = Path.cwd()
            
            # Check start menu Updater preference
            startmenu_updater_enabled = getattr(self, 'startmenu_updater_enabled', True)
            # Check start menu Toolkit preference
            startmenu_toolkit_enabled = getattr(self, 'startmenu_toolkit_enabled', True)
            
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    # Create Innioasis Updater shortcut using appropriate source
                    if startmenu_updater_enabled:
                        source_shortcut = self.get_appropriate_shortcut_source()
                        if source_shortcut:
                            dest_shortcut = start_menu_path / "Innioasis Updater.lnk"
                            # Force replacement of existing shortcut
                            if dest_shortcut.exists():
                                try:
                                    dest_shortcut.unlink()  # Remove existing shortcut
                                    silent_print(f"Removed existing start menu shortcut: Innioasis Updater.lnk")
                                except Exception as e:
                                    silent_print(f"Warning: Could not remove existing shortcut: {e}")
                            
                            # Copy the new shortcut
                            shutil.copy2(source_shortcut, dest_shortcut)
                            auto_updates_enabled = False  # Manual updates by default
                            shortcut_type = "regular" if auto_updates_enabled else "skip-update"
                            silent_print(f"Created/updated start menu shortcut: Innioasis Updater.lnk ({shortcut_type})")
                        else:
                            silent_print(f"Warning: Appropriate shortcut source not found")
                    else:
                        # Remove start menu Updater shortcut if preference is disabled
                        dest_shortcut = start_menu_path / "Innioasis Updater.lnk"
                        if dest_shortcut.exists():
                            try:
                                dest_shortcut.unlink()
                                silent_print(f"Removed start menu Updater shortcut (preference disabled): {start_menu_path}")
                            except Exception as e:
                                silent_print(f"Warning: Could not remove start menu Updater shortcut: {e}")
                    
                    # Create Innioasis Toolkit shortcut (respects preference)
                    if startmenu_toolkit_enabled:
                        source_toolkit = current_dir / "Innioasis Toolkit.lnk"
                        if source_toolkit.exists():
                            dest_toolkit = start_menu_path / "Innioasis Toolkit.lnk"
                            # Force replacement of existing shortcut
                            if dest_toolkit.exists():
                                try:
                                    dest_toolkit.unlink()
                                    silent_print(f"Removed existing start menu shortcut: Innioasis Toolkit.lnk")
                                except Exception as e:
                                    silent_print(f"Warning: Could not remove existing shortcut: {e}")
                            
                            # Copy the new shortcut
                            shutil.copy2(source_toolkit, dest_toolkit)
                            silent_print(f"Created/updated start menu shortcut: Innioasis Toolkit.lnk")
                        else:
                            silent_print(f"Warning: Innioasis Toolkit.lnk not found in current directory")
                    else:
                        # Remove start menu Toolkit shortcut if preference is disabled
                        dest_toolkit = start_menu_path / "Innioasis Toolkit.lnk"
                        if dest_toolkit.exists():
                            try:
                                dest_toolkit.unlink()
                                silent_print(f"Removed start menu Toolkit shortcut (preference disabled): {start_menu_path}")
                            except Exception as e:
                                silent_print(f"Warning: Could not remove start menu Toolkit shortcut: {e}")
                            
        except Exception as e:
            silent_print(f"Error ensuring start menu shortcuts: {e}")
    
    def remove_startmenu_shortcuts(self):
        """Remove start menu shortcuts - includes wildcard cleanup for legacy shortcuts"""
        if platform.system() != "Windows":
            return
            
        try:
            start_menu_paths = self.get_all_start_menu_paths()
            
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    # Remove current and legacy shortcuts using wildcards
                    patterns = ["*Innioasis*", "*Y1*", "*SP Flash*"]
                    for pattern in patterns:
                        for item in start_menu_path.glob(pattern):
                            if item.is_file() and item.suffix.lower() == '.lnk':
                                try:
                                    item.unlink()
                                    silent_print(f"Removed start menu shortcut: {item.name}")
                                except Exception as e:
                                    silent_print(f"Error removing {item.name}: {e}")
                    
                    # Remove Y1 Helper folder if it exists
                    y1_helper_folder = start_menu_path / "Y1 Helper"
                    if y1_helper_folder.exists() and y1_helper_folder.is_dir():
                        try:
                            shutil.rmtree(y1_helper_folder)
                            silent_print(f"Removed Y1 Helper folder: {y1_helper_folder}")
                        except Exception as e:
                            silent_print(f"Error removing Y1 Helper folder: {e}")
                            
        except Exception as e:
            silent_print(f"Error removing start menu shortcuts: {e}")
    
    def remove_toolkit_shortcuts(self):
        """Remove Innioasis Toolkit shortcuts from start menu"""
        if platform.system() != "Windows":
            return
            
        try:
            start_menu_paths = self.get_all_start_menu_paths()
            
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    # Remove Innioasis Toolkit shortcut
                    toolkit_shortcut = start_menu_path / "Innioasis Toolkit.lnk"
                    if toolkit_shortcut.exists():
                        try:
                            toolkit_shortcut.unlink()
                            silent_print(f"Removed Innioasis Toolkit shortcut: {toolkit_shortcut}")
                        except Exception as e:
                            silent_print(f"Error removing Innioasis Toolkit shortcut: {e}")
                            
        except Exception as e:
            silent_print(f"Error removing toolkit shortcuts: {e}")
    
    def ensure_desktop_updater_shortcut(self):
        """Ensure Innioasis Updater shortcut exists on desktop"""
        if platform.system() != "Windows":
            return
            
        try:
            current_dir = Path.cwd()
            source_shortcut = self.get_appropriate_shortcut_source()
            if not source_shortcut or not source_shortcut.exists():
                silent_print("Innioasis Updater shortcut source not found")
                return
            
            desktop_path = Path.home() / "Desktop"
            dest_shortcut = desktop_path / "Innioasis Updater.lnk"
            
            # Check if shortcut already exists and is up to date
            if dest_shortcut.exists():
                # Compare file modification times to see if update is needed
                source_mtime = source_shortcut.stat().st_mtime
                dest_mtime = dest_shortcut.stat().st_mtime
                if dest_mtime >= source_mtime:
                    silent_print("Desktop Innioasis Updater shortcut is already up to date")
                    return
            
            # Remove existing shortcut first
            if dest_shortcut.exists():
                dest_shortcut.unlink()
            
            shutil.copy2(source_shortcut, dest_shortcut)
            silent_print(f"Created/updated desktop Innioasis Updater shortcut")
            
        except Exception as e:
            silent_print(f"Error ensuring desktop updater shortcut: {e}")
    
    def remove_desktop_updater_shortcut(self):
        """Remove Innioasis Updater shortcut from desktop"""
        if platform.system() != "Windows":
            return
            
        try:
            desktop_path = Path.home() / "Desktop"
            shortcut = desktop_path / "Innioasis Updater.lnk"
            if shortcut.exists():
                shortcut.unlink()
                silent_print(f"Removed desktop Innioasis Updater shortcut")
        except Exception as e:
            silent_print(f"Error removing desktop updater shortcut: {e}")
    
    def ensure_desktop_toolkit_shortcut(self):
        """Ensure Innioasis Toolkit shortcut exists on desktop"""
        if platform.system() != "Windows":
            return
            
        try:
            current_dir = Path.cwd()
            source_shortcut = current_dir / "Innioasis Toolkit.lnk"
            if not source_shortcut.exists():
                silent_print("Innioasis Toolkit.lnk not found in current directory")
                return
            
            desktop_path = Path.home() / "Desktop"
            dest_shortcut = desktop_path / "Innioasis Toolkit.lnk"
            
            # Check if shortcut already exists and is up to date
            if dest_shortcut.exists():
                # Compare file modification times to see if update is needed
                source_mtime = source_shortcut.stat().st_mtime
                dest_mtime = dest_shortcut.stat().st_mtime
                if dest_mtime >= source_mtime:
                    silent_print("Desktop Innioasis Toolkit shortcut is already up to date")
                    return
            
            # Remove existing shortcut first
            if dest_shortcut.exists():
                dest_shortcut.unlink()
            
            shutil.copy2(source_shortcut, dest_shortcut)
            silent_print(f"Created/updated desktop Innioasis Toolkit shortcut")
            
            # Also ensure Innioasis Updater.lnk is in Toolkit directory for app launching
            self.ensure_toolkit_updater_shortcut()
            
        except Exception as e:
            silent_print(f"Error ensuring desktop toolkit shortcut: {e}")
    
    def remove_desktop_toolkit_shortcut(self):
        """Remove Innioasis Toolkit shortcut from desktop"""
        if platform.system() != "Windows":
            return
            
        try:
            desktop_path = Path.home() / "Desktop"
            shortcut = desktop_path / "Innioasis Toolkit.lnk"
            if shortcut.exists():
                shortcut.unlink()
                silent_print(f"Removed desktop Innioasis Toolkit shortcut")
        except Exception as e:
            silent_print(f"Error removing desktop toolkit shortcut: {e}")
    
    def ensure_startmenu_updater_shortcut(self):
        """Ensure Innioasis Updater shortcut exists in start menu"""
        if platform.system() != "Windows":
            return
            
        try:
            current_dir = Path.cwd()
            source_shortcut = self.get_appropriate_shortcut_source()
            if not source_shortcut or not source_shortcut.exists():
                silent_print("Innioasis Updater shortcut source not found")
                return
            
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    dest_shortcut = start_menu_path / "Innioasis Updater.lnk"
                    
                    # Check if shortcut already exists and is up to date
                    if dest_shortcut.exists():
                        # Compare file modification times to see if update is needed
                        source_mtime = source_shortcut.stat().st_mtime
                        dest_mtime = dest_shortcut.stat().st_mtime
                        if dest_mtime >= source_mtime:
                            silent_print("Start menu Innioasis Updater shortcut is already up to date")
                            break  # Skip creation if already up to date
                    
                    # Remove existing shortcut first
                    if dest_shortcut.exists():
                        dest_shortcut.unlink()
                    
                    shutil.copy2(source_shortcut, dest_shortcut)
                    silent_print(f"Created/updated start menu Innioasis Updater shortcut: {start_menu_path}")
                    break  # Only create in first available start menu path
            
        except Exception as e:
            silent_print(f"Error ensuring start menu updater shortcut: {e}")
    
    def remove_startmenu_updater_shortcut(self):
        """Remove Innioasis Updater shortcut from start menu"""
        if platform.system() != "Windows":
            return
            
        try:
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    shortcut = start_menu_path / "Innioasis Updater.lnk"
                    if shortcut.exists():
                        shortcut.unlink()
                        silent_print(f"Removed start menu Innioasis Updater shortcut: {start_menu_path}")
        except Exception as e:
            silent_print(f"Error removing start menu updater shortcut: {e}")
    
    def ensure_startmenu_toolkit_shortcut(self):
        """Ensure Innioasis Toolkit shortcut exists in start menu"""
        if platform.system() != "Windows":
            return
            
        try:
            current_dir = Path.cwd()
            source_shortcut = current_dir / "Innioasis Toolkit.lnk"
            if not source_shortcut.exists():
                silent_print("Innioasis Toolkit.lnk not found in current directory")
                return
            
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    dest_shortcut = start_menu_path / "Innioasis Toolkit.lnk"
                    
                    # Check if shortcut already exists and is up to date
                    if dest_shortcut.exists():
                        # Compare file modification times to see if update is needed
                        source_mtime = source_shortcut.stat().st_mtime
                        dest_mtime = dest_shortcut.stat().st_mtime
                        if dest_mtime >= source_mtime:
                            silent_print("Start menu Innioasis Toolkit shortcut is already up to date")
                            break  # Skip creation if already up to date
                    
                    # Remove existing shortcut first
                    if dest_shortcut.exists():
                        dest_shortcut.unlink()
                    
                    shutil.copy2(source_shortcut, dest_shortcut)
                    silent_print(f"Created/updated start menu Innioasis Toolkit shortcut: {start_menu_path}")
                    break  # Only create in first available start menu path
            
            # Also ensure Innioasis Updater.lnk is in Toolkit directory for app launching
            self.ensure_toolkit_updater_shortcut()
            
        except Exception as e:
            silent_print(f"Error ensuring start menu toolkit shortcut: {e}")
    
    def remove_startmenu_toolkit_shortcut(self):
        """Remove Innioasis Toolkit shortcut from start menu"""
        if platform.system() != "Windows":
            return
            
        try:
            start_menu_paths = self.get_all_start_menu_paths()
            for start_menu_path in start_menu_paths:
                if start_menu_path.exists():
                    shortcut = start_menu_path / "Innioasis Toolkit.lnk"
                    if shortcut.exists():
                        shortcut.unlink()
                        silent_print(f"Removed start menu Innioasis Toolkit shortcut: {start_menu_path}")
        except Exception as e:
            silent_print(f"Error removing start menu toolkit shortcut: {e}")
    
    def ensure_toolkit_updater_shortcut(self):
        """Ensure Innioasis Updater.lnk exists in Toolkit directory for app launching"""
        if platform.system() != "Windows":
            return
            
        try:
            current_dir = Path.cwd()
            toolkit_dir = current_dir / "Toolkit"
            
            # Only proceed if Toolkit directory exists
            if not toolkit_dir.exists():
                silent_print("Toolkit directory not found - skipping updater shortcut placement")
                return
            
            # Get the appropriate source shortcut (handles Skip Update vs regular)
            source_shortcut = self.get_appropriate_shortcut_source()
            if not source_shortcut or not source_shortcut.exists():
                silent_print("Innioasis Updater shortcut source not found for Toolkit directory")
                return
            
            # Place the shortcut in Toolkit directory
            toolkit_updater_shortcut = toolkit_dir / "Innioasis Updater.lnk"
            
            # Remove existing shortcut first
            if toolkit_updater_shortcut.exists():
                toolkit_updater_shortcut.unlink()
            
            shutil.copy2(source_shortcut, toolkit_updater_shortcut)
            silent_print(f"Placed Innioasis Updater.lnk in Toolkit directory for app launching")
            
        except Exception as e:
            silent_print(f"Error ensuring toolkit updater shortcut: {e}")
    
    def remove_toolkit_updater_shortcut(self):
        """Remove Innioasis Updater.lnk from Toolkit directory"""
        if platform.system() != "Windows":
            return
            
        try:
            current_dir = Path.cwd()
            toolkit_dir = current_dir / "Toolkit"
            
            if not toolkit_dir.exists():
                return  # Toolkit directory doesn't exist, nothing to remove
            
            toolkit_updater_shortcut = toolkit_dir / "Innioasis Updater.lnk"
            if toolkit_updater_shortcut.exists():
                toolkit_updater_shortcut.unlink()
                silent_print(f"Removed Innioasis Updater.lnk from Toolkit directory")
            
        except Exception as e:
            silent_print(f"Error removing toolkit updater shortcut: {e}")
    
    def check_and_manage_toolkit_updater_shortcut(self):
        """Check if we need to add/remove updater shortcut from Toolkit directory based on current settings"""
        if platform.system() != "Windows":
            return
            
        try:
            # Check if user has any direct updater shortcuts enabled
            has_direct_updater_shortcuts = (getattr(self, 'desktop_updater_enabled', True) or 
                                          getattr(self, 'startmenu_updater_enabled', True))
            
            # Check if user has any toolkit shortcuts enabled
            has_toolkit_shortcuts = (getattr(self, 'desktop_toolkit_enabled', False) or 
                                   getattr(self, 'startmenu_toolkit_enabled', True))
            
            if has_toolkit_shortcuts and not has_direct_updater_shortcuts:
                # User has toolkit shortcuts but no direct updater shortcuts
                # Ensure updater shortcut is in Toolkit directory (dialog will show on save)
                self.ensure_toolkit_updater_shortcut()
            elif has_direct_updater_shortcuts:
                # User has direct updater shortcuts, remove from Toolkit directory
                self.remove_toolkit_updater_shortcut()
            
        except Exception as e:
            silent_print(f"Error checking and managing toolkit updater shortcut: {e}")
    
    def show_toolkit_only_help_dialog(self):
        """Show helpful dialog for users with only Toolkit shortcuts (one time only)"""
        try:
            # Check if we've already shown this dialog
            if hasattr(self, '_toolkit_help_dialog_shown') and self._toolkit_help_dialog_shown:
                return  # Already shown, don't show again
            
            # Determine which Toolkit shortcuts the user has enabled
            toolkit_locations = []
            if getattr(self, 'desktop_toolkit_enabled', False):
                toolkit_locations.append("Desktop")
            if getattr(self, 'startmenu_toolkit_enabled', True):
                toolkit_locations.append("Start Menu")
            
            location_text = " and ".join(toolkit_locations)
            
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Toolkit Shortcut")
            msg_box.setIcon(QMessageBox.Information)
            msg_box.setText(f"You can launch Updater as normal from Innioasis Toolkit ({location_text}).")
            msg_box.setStandardButtons(QMessageBox.Ok)
            msg_box.exec()
            
            # Mark as shown so it won't appear again
            self._toolkit_help_dialog_shown = True
            
        except Exception as e:
            silent_print(f"Error showing toolkit help dialog: {e}")
    
    def apply_shortcut_settings_on_startup(self):
        """Apply shortcut settings on startup based on user preferences - silent operation"""
        if platform.system() != "Windows":
            return
            
        try:
            # Note: Preferences are already loaded by load_installation_preferences() called earlier
            
            # Ensure the Skip Update shortcut exists if auto-updates are disabled
            if True:  # Manual updates by default
                if not self.ensure_skip_update_shortcut_exists():
                    silent_print("Warning: Could not ensure Skip Update shortcut exists on startup")
            
            # Apply settings silently
            silent_print(f"Applying startup shortcut settings - Desktop Updater: {getattr(self, 'desktop_updater_enabled', 'NOT SET')}, Desktop Toolkit: {getattr(self, 'desktop_toolkit_enabled', 'NOT SET')}, Start Menu Updater: {getattr(self, 'startmenu_updater_enabled', 'NOT SET')}, Start Menu Toolkit: {getattr(self, 'startmenu_toolkit_enabled', 'NOT SET')}")
            self.apply_shortcut_settings()
            
            silent_print("Startup shortcut settings applied successfully.")
            
        except Exception as e:
            silent_print(f"Error applying startup shortcut settings: {e}")
    
    # Old toggle handlers removed - replaced with individual shortcut handlers
    
    def on_desktop_updater_toggled(self, checked):
        """Handle real-time desktop Innioasis Updater shortcut checkbox changes"""
        if platform.system() != "Windows":
            return
            
        try:
            self.desktop_updater_enabled = checked
            
            if checked:
                self.ensure_desktop_updater_shortcut()
                # Remove updater shortcut from Toolkit directory since user now has direct access
                self.remove_toolkit_updater_shortcut()
                silent_print("Desktop Innioasis Updater shortcut enabled and created.")
            else:
                self.remove_desktop_updater_shortcut()
                # Check if we need to add updater shortcut to Toolkit directory
                self.check_and_manage_toolkit_updater_shortcut()
                silent_print("Desktop Innioasis Updater shortcut disabled and removed.")
            
            # Save preferences immediately when checkbox is toggled
            self.save_installation_preferences()
                
        except Exception as e:
            silent_print(f"Error handling desktop updater shortcut toggle: {e}")
    
    def on_desktop_toolkit_toggled(self, checked):
        """Handle real-time desktop Innioasis Toolkit shortcut checkbox changes"""
        if platform.system() != "Windows":
            return
            
        try:
            self.desktop_toolkit_enabled = checked
            
            if checked:
                self.ensure_desktop_toolkit_shortcut()
                silent_print("Desktop Innioasis Toolkit shortcut enabled and created.")
            else:
                self.remove_desktop_toolkit_shortcut()
                silent_print("Desktop Innioasis Toolkit shortcut disabled and removed.")
            
            # Save preferences immediately when checkbox is toggled
            self.save_installation_preferences()
                
        except Exception as e:
            silent_print(f"Error handling desktop toolkit shortcut toggle: {e}")
    
    def on_startmenu_updater_toggled(self, checked):
        """Handle real-time start menu Innioasis Updater shortcut checkbox changes"""
        if platform.system() != "Windows":
            return
            
        try:
            self.startmenu_updater_enabled = checked
            
            if checked:
                self.ensure_startmenu_updater_shortcut()
                # Remove updater shortcut from Toolkit directory since user now has direct access
                self.remove_toolkit_updater_shortcut()
                silent_print("Start menu Innioasis Updater shortcut enabled and created.")
            else:
                self.remove_startmenu_updater_shortcut()
                # Check if we need to add updater shortcut to Toolkit directory
                self.check_and_manage_toolkit_updater_shortcut()
                silent_print("Start menu Innioasis Updater shortcut disabled and removed.")
            
            # Save preferences immediately when checkbox is toggled
            self.save_installation_preferences()
                
        except Exception as e:
            silent_print(f"Error handling start menu updater shortcut toggle: {e}")
    
    def on_startmenu_toolkit_toggled(self, checked):
        """Handle real-time start menu Innioasis Toolkit shortcut checkbox changes"""
        if platform.system() != "Windows":
            return
            
        try:
            self.startmenu_toolkit_enabled = checked
            
            if checked:
                self.ensure_startmenu_toolkit_shortcut()
                silent_print("Start menu Innioasis Toolkit shortcut enabled and created.")
            else:
                self.remove_startmenu_toolkit_shortcut()
                silent_print("Start menu Innioasis Toolkit shortcut disabled and removed.")
            
            # Save preferences immediately when checkbox is toggled
            self.save_installation_preferences()
                
        except Exception as e:
            silent_print(f"Error handling start menu toolkit shortcut toggle: {e}")
    
    def restore_original_installation_method(self):
        """Restore the original installation method if it was temporarily overridden"""
        if hasattr(self, '_original_installation_method'):
            # Only restore if the current method is spflash (Method 3) and we have the original
            if self.installation_method == "spflash" and self._original_installation_method != "spflash":
                # Check if we still only have MTK driver (no UsbDk)
                if platform.system() == "Windows":
                    driver_info = self.check_drivers_and_architecture()
                    if driver_info['has_mtk_driver'] and not driver_info['has_usbdk_driver']:
                        # Still only MTK driver, keep Method 3 for this session
                        silent_print("Keeping Method 3 for this session (only MTK driver available)")
                    else:
                        # UsbDk driver now available, restore original method
                        self.installation_method = self._original_installation_method
                        silent_print(f"Restored original installation method: {self.installation_method}")
                        # Clear the stored original method
                        delattr(self, '_original_installation_method')
            # Use defaults if loading fails
            if platform.system() == "Windows":
                self.installation_method = "spflash"  # Default to Method 1 (Guided) on Windows
            else:
                self.installation_method = "guided"  # Default to Method 1 (Guided) on other platforms
            # Always use method functionality removed

    def populate_device_type_combo(self):
        """Dynamically populate device type combo based on available release tags"""
        self.device_type_combo.clear()

        # Always add Type A and Type B options since we can determine this from release tags
        # Type A: releases without 'type-b' in tag
        # Type B: releases with 'type-b' in tag
        self.device_type_combo.addItem("Type A", "A")
        self.device_type_combo.addItem("Type B", "B")

        # Set default to Type A
        self.device_type_combo.setCurrentText("Type A")

    def populate_device_model_combo(self):
        """Dynamically populate device model combo from manifest data"""
        self.device_model_combo.clear()

        # Get unique device models from packages
        device_models = set()
        for package in self.packages:
            device_model = package.get('device', '')
            if device_model:
                device_models.add(device_model)

        # Add device models to combo (sorted)
        for device_model in sorted(device_models):
            self.device_model_combo.addItem(device_model, device_model)

        # Set default to first available model if any exist
        if len(device_models) > 0:
            first_model = sorted(device_models)[0]
            self.device_model_combo.setCurrentText(first_model)
        
        # Update device type visibility based on selected model
        self.update_device_type_visibility()

    def populate_firmware_combo(self):
        """Populate the software dropdown with package names from manifest"""
        # Block signals during population to prevent network calls on setCurrentIndex
        was_blocked = self.firmware_combo.signalsBlocked()
        self.firmware_combo.blockSignals(True)
        
        self.firmware_combo.clear()

        # Get current filter selections
        selected_model = self.device_model_combo.currentData()

        # Get filtered software names from packages
        software_options = []
        for package in self.packages:
            name = package.get('name', '')
            repo = package.get('repo', '')
            device_model = package.get('device', '')

            # Check device model filter only - type filtering happens at release level
            model_match = not selected_model or device_model == selected_model

            if name and repo and model_match:
                software_options.append((name, repo))

        # Add filtered software options to dropdown (sorted by name)
        for name, repo in sorted(software_options, key=lambda x: x[0]):
            self.firmware_combo.addItem(name, repo)

        # Set default selection to software containing "Original" if available
        default_index = 0  # Default to first item
        for i in range(self.firmware_combo.count()):
            if "original" in self.firmware_combo.itemText(i).lower():
                default_index = i
                break

        self.firmware_combo.setCurrentIndex(default_index)
        
        # Unblock signals after population
        self.firmware_combo.blockSignals(was_blocked)


    def _release_matches_type_filter(self, tag_name, selected_type):
        """Check if a release tag matches the selected device type filter"""
        if not selected_type:
            return True
        
        has_type_b = 'type-b' in tag_name.lower()
        
        if selected_type == 'B':
            # Type B filter: only show releases with 'type-b' in tag
            return has_type_b
        else:
            # Type A filter (or other types): show releases without 'type-b' in tag
            return not has_type_b

    def _should_exclude_release(self, tag_name):
        """Check if a release should be excluded from listings (e.g., contains 'base')"""
        # Exclude releases that contain 'base' in the tag name
        return 'base' in tag_name.lower()

    def update_package_group_title(self, firmware_name):
        """Update the package group title based on selected software"""
        has_gui_update = self.has_update_available() and not self.suppress_update_notifications
        if has_gui_update:
            self.package_group.setTitle("Update Available")
        elif firmware_name:
            self.package_group.setTitle(firmware_name)
        else:
            self.package_group.setTitle("Available System Software")

    def on_firmware_changed(self):
        """Handle software selection change"""
        selected_repo = self.firmware_combo.currentData()

        if selected_repo:
            # Update package list to show releases for selected software
            self.populate_releases_list()
        else:
            # No software selected - show empty list
            self.package_list.clear()
            help_item = QListWidgetItem("Please select a software type to view releases")
            help_item.setFlags(help_item.flags() & ~Qt.ItemIsSelectable)
            self.package_list.addItem(help_item)

    def on_prerelease_filter_changed(self):
        """Handle pre-release filter checkbox change"""
        # Refresh the releases list with the new filter setting
        self.populate_releases_list()

    def is_prerelease_build(self, release):
        """Backward-compatible wrapper around enhanced pre-release detection."""
        return self._is_prerelease_build(release)

    def populate_releases_list(self):
        """Populate the releases list - INSTANT with cache, background refresh for offline mode"""
        self.package_list.clear()

        # Stop any existing progressive worker
        if hasattr(self, 'release_worker') and self.release_worker:
            try:
                old_worker = self.release_worker
                if old_worker.isRunning():
                    # Stop the worker first (non-blocking)
                    old_worker.stop()
                    
                    # Disconnect signals first to prevent issues
                    try:
                        old_worker.release_loaded.disconnect()
                        old_worker.loading_complete.disconnect()
                        old_worker.loading_failed.disconnect()
                    except:
                        pass
                    
                    # Use finished signal to clean up later (non-blocking)
                    if not hasattr(self, '_old_workers'):
                        self._old_workers = []
                    
                    def cleanup_worker():
                        try:
                            if hasattr(self, '_old_workers') and old_worker in self._old_workers:
                                self._old_workers.remove(old_worker)
                            if not old_worker.isRunning():
                                old_worker.deleteLater()
                        except:
                            pass
                    
                    old_worker.finished.connect(cleanup_worker)
                    self._old_workers.append(old_worker)
                
                # Allow new worker creation immediately (don't wait)
                self.release_worker = None
            except Exception as e:
                silent_print(f"Error stopping release worker: {e}")
                try:
                    if hasattr(self, 'release_worker') and self.release_worker:
                        if not self.release_worker.isRunning():
                            self.release_worker.deleteLater()
                except:
                    pass
                self.release_worker = None
        
        # Clear pending releases queue and stop timer when switching repositories
        if hasattr(self, '_pending_releases'):
            self._pending_releases = []
        if hasattr(self, '_release_update_timer') and self._release_update_timer:
            try:
                self._release_update_timer.stop()
            except:
                pass

        selected_repo = self.firmware_combo.currentData()
        if not selected_repo:
            self.package_list.clear()
            self.package_list.addItem("Please select a software type")
            return

        # Get current filters
        selected_type = self.device_type_combo.currentData()
        show_prereleases = self.show_prerelease_checkbox.isChecked()
        
        # Check if we have tokens available (indicates online mode is expected)
        has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
        
        # Check online status (non-blocking, cached check)
        is_online = self.is_online()
        
        # Only show cached releases if we have tokens AND we're actually online
        # This prevents showing cached releases when offline, which could mislead users
        cached_releases = self.github_api.get_cached_releases(selected_repo)
        if cached_releases and has_tokens and is_online:
            # Online mode: show cached releases instantly for fast startup
            silent_print(f"Using {len(cached_releases)} cached releases (INSTANT, ONLINE MODE)")
            # Show cached releases immediately
            self._display_cached_releases(cached_releases, selected_repo, selected_type, show_prereleases, is_online=True)
            # Start background refresh in background (non-blocking)
            QTimer.singleShot(100, lambda: self._start_background_refresh(
                selected_repo,
                selected_type,
                self.show_prerelease_checkbox.isChecked() if hasattr(self, 'show_prerelease_checkbox') else False
            ))
            return

        # Offline mode OR no cache: show offline message
        if not has_tokens or not is_online:
            # No tokens or offline = offline mode - show offline message
            silent_print("Offline mode detected - showing Install from rom.zip prompt")
            self._show_offline_message(has_tokens)
            # Disable download button when offline
            self.download_btn.setEnabled(False)
            # Don't retry - we're intentionally offline
            return
        
        # Has tokens and online but no cache - show offline message while fetching
        self._show_offline_message(has_tokens)
        # Disable download button until releases are loaded
        self.download_btn.setEnabled(False)
        
        # Start background fetch (non-blocking) - don't show loading item, keep offline message
        # The left panel will show automatically when releases are loaded
        self._start_background_refresh(
            selected_repo,
            selected_type,
            self.show_prerelease_checkbox.isChecked() if hasattr(self, 'show_prerelease_checkbox') else False
        )
        
    def _display_cached_releases(self, cached_releases, selected_repo, selected_type, show_prereleases, is_online=True):
        """Display cached releases instantly (online mode only)"""
        try:
            self.releases_loaded_count = 0
            self.all_releases_loaded = []
            
            # Check if any pre-releases exist in cached releases
            has_prereleases = any(self._is_prerelease_build(release) for release in cached_releases)
            
            # Show/hide pre-release checkbox based on availability
            if hasattr(self, 'show_prerelease_checkbox'):
                if has_prereleases:
                    self.show_prerelease_checkbox.setVisible(True)
                else:
                    if self.show_prerelease_checkbox.isChecked():
                        self.show_prerelease_checkbox.blockSignals(True)
                        self.show_prerelease_checkbox.setChecked(False)
                        self.show_prerelease_checkbox.blockSignals(False)
                    self.show_prerelease_checkbox.setVisible(False)
                    show_prereleases = False
            
            # Filter and display cached releases (no limit)
            for release in cached_releases:
                try:
                    tag_name = release.get('tag_name', '')
                    
                    # Skip excluded releases
                    if 'base' in tag_name.lower():
                        continue
                    
                    # Check type filter
                    has_type_b = 'type-b' in tag_name.lower()
                    if selected_type == 'B':
                        if not has_type_b:
                            continue
                    else:
                        if has_type_b:
                            continue
                    
                    # Check pre-release filter
                    if not show_prereleases and self._is_prerelease_build(release):
                        continue
                    
                    # Add to list
                    self._add_release_to_list(release)
                    self.releases_loaded_count += 1
                    self.all_releases_loaded.append(release)
                    # No limit - show all releases
                except Exception as e:
                    silent_print(f"Error processing cached release: {e}")
                    continue
            
            # No "View Older Releases" link needed - no limit on releases
            
            # Select first item
            if self.package_list.count() > 0:
                try:
                    first_item = self.package_list.item(0)
                    if first_item and isinstance(first_item.data(Qt.UserRole), dict) and not first_item.data(Qt.UserRole).get('is_link'):
                        self.package_list.setCurrentRow(0)
                        self.on_release_selected(first_item)
                except Exception as e:
                    silent_print(f"Error selecting first item: {e}")
            
            # Show left panel when releases are available
            if self.releases_loaded_count > 0:
                self._show_left_panel()
            
            # Enable download button only when online
            # This prevents users from attempting downloads when offline
            if is_online:
                self.download_btn.setEnabled(True)
            else:
                self.download_btn.setEnabled(False)
                silent_print("Download button disabled - offline mode")
            
            silent_print(f"Displayed {self.releases_loaded_count} cached releases (ONLINE MODE)")
        except Exception as e:
            silent_print(f"Error in _display_cached_releases: {e}")
            import traceback
            traceback.print_exc()
    
    def _show_initial_offline_state(self):
        """Show offline message as default state on startup (before content loads)"""
        try:
            # Hide left panel by default
            if hasattr(self, 'left_panel'):
                self.left_panel.setVisible(False)
            
            # Check if we have tokens (might be online) - but don't block waiting for network
            has_tokens = False
            try:
                if hasattr(self, 'github_api') and self.github_api:
                    has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
            except:
                pass  # Don't block if tokens aren't loaded yet
            
            # Show offline message
            self._show_offline_message(has_tokens)
        except Exception as e:
            silent_print(f"Error showing initial offline state: {e}")
    
    def _show_offline_message(self, has_tokens):
        """Show offline message and hide left panel when no releases are available"""
        try:
            # Hide left panel
            if hasattr(self, 'left_panel'):
                self.left_panel.setVisible(False)
            
            # Show offline message in release notes area
            if hasattr(self, 'release_notes_browser'):
                # Get theme-aware text color
                text_color = self._get_text_color_for_theme()
                
                # Check if online
                online_message = ""
                if has_tokens:
                    online_message = f"<p style='color: {text_color} !important; margin-top: 10px;'>If you are online, something else may be blocking the connection to the online firmware directory.</p>"
                
                message_html = f"""
                <html>
                <head>
                    <style>
                        body, div, p, strong {{
                            color: {text_color} !important;
                        }}
                    </style>
                </head>
                <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 20px; text-align: center; color: {text_color} !important;'>
                    <p style='font-size: 16px; color: {text_color} !important; margin-bottom: 15px;'>Please select <strong style="color: {text_color} !important;">Browse Files</strong> to begin, or go online to view the latest updates for your player.</p>
                    {online_message}
                </body>
                </html>
                """
                self.release_notes_browser.setHtml(message_html)
            
            # Switch to release notes view
            if hasattr(self, 'image_notes_stack'):
                self.image_notes_stack.setCurrentIndex(1)
                # Update title
                if hasattr(self, 'output_group'):
                    self.output_group.setTitle("Getting Ready:")
        except Exception as e:
            silent_print(f"Error showing offline message: {e}")
    
    def _show_left_panel(self):
        """Show left panel when releases are available"""
        try:
            if hasattr(self, 'left_panel'):
                self.left_panel.setVisible(True)
        except Exception as e:
            silent_print(f"Error showing left panel: {e}")
        
    def _is_prerelease_build(self, release):
        """Backward-compatible hook for new prerelease detection helper."""
        return _release_looks_prerelease(release)

    def _ensure_prerelease_checkbox_available(self):
        """Ensure the pre-release checkbox becomes visible when needed."""
        try:
            if not hasattr(self, 'show_prerelease_checkbox') or self.show_prerelease_checkbox is None:
                return
            if not self.show_prerelease_checkbox.isVisible():
                self.show_prerelease_checkbox.setVisible(True)
        except Exception as exc:
            silent_print(f'Unable to update pre-release checkbox visibility: {exc}')


    def _start_background_refresh(self, selected_repo, selected_type, show_prereleases):
        """Start background refresh of releases (non-blocking)"""
        # Don't reset counters if we already have cached releases displayed
        # Only initialize if not already set
        if not hasattr(self, 'releases_loaded_count'):
            self.releases_loaded_count = 0
        if not hasattr(self, 'all_releases_loaded'):
            self.all_releases_loaded = []
        
        # Create and start progressive release worker (only fetches fresh data)
        # Parent the worker to this window so it gets cleaned up properly
        self.release_worker = ProgressiveReleaseWorker(
            self.github_api, 
            selected_repo, 
            selected_type, 
            show_prereleases
        )
        self.release_worker.setParent(self)  # Parent to main window for proper cleanup
        self.release_worker.release_loaded.connect(self._on_fresh_release_loaded)
        self.release_worker.loading_complete.connect(self.on_releases_loading_complete)
        self.release_worker.loading_failed.connect(self._on_background_refresh_failed)
        
        # Connect finished signal to clean up properly
        worker_ref = self.release_worker  # Capture reference
        def cleanup_worker():
            if hasattr(self, 'release_worker') and self.release_worker == worker_ref:
                try:
                    if not self.release_worker.isRunning():
                        self.release_worker.deleteLater()
                except:
                    pass
        
        self.release_worker.finished.connect(cleanup_worker)
        self.release_worker.start()
        
        silent_print(f"Started background refresh for {selected_repo}")
    
    def _on_fresh_release_loaded(self, release):
        """Handle a fresh release loaded from network - queue for batched UI update"""
        try:
            # Skip if we're currently displaying release notes to avoid conflicts
            if hasattr(self, '_displaying_release_notes') and self._displaying_release_notes:
                return
            
            # Queue the release for batched processing
            if not hasattr(self, '_pending_releases'):
                self._pending_releases = []
            
            self._pending_releases.append(release)
            
            # Start or reset the batch processing timer
            if not hasattr(self, '_release_update_timer') or self._release_update_timer is None:
                self._release_update_timer = QTimer()
                self._release_update_timer.setSingleShot(True)
                self._release_update_timer.timeout.connect(self._process_batched_releases)
            
            # Process releases in batches every 150ms to prevent UI freezing
            if not self._release_update_timer.isActive():
                self._release_update_timer.start(150)
        except Exception as e:
            silent_print(f"Error queuing release: {e}")
    
    def _process_batched_releases(self):
        """Process queued releases in batches to prevent UI freezing"""
        try:
            if not hasattr(self, '_pending_releases') or not self._pending_releases:
                return

            # Defensive check - ensure UI elements exist
            if not hasattr(self, 'package_list') or self.package_list is None:
                self._pending_releases = []
                return
            if not hasattr(self, 'firmware_combo') or self.firmware_combo is None:
                self._pending_releases = []
                return
            
            # Get existing tags to avoid duplicates
            existing_tags = set()
            try:
                list_count = self.package_list.count()
                for i in range(list_count):
                    try:
                        item = self.package_list.item(i)
                        if item and item.data(Qt.UserRole):
                            data = item.data(Qt.UserRole)
                            if isinstance(data, dict) and not data.get('is_link'):
                                existing_tag = data.get('tag_name', '')
                                if existing_tag:
                                    existing_tags.add(existing_tag)
                    except:
                        continue
            except RuntimeError:
                self._pending_releases = []
                return
            
            # Process up to 3 releases at a time to prevent freezing
            batch_size = 3
            processed = 0
            releases_to_add = []
            
            for release in self._pending_releases[:]:
                if processed >= batch_size:
                    break
                
                tag_name = release.get('tag_name', '')
                if not tag_name or tag_name in existing_tags:
                    self._pending_releases.remove(release)
                    continue
                
                releases_to_add.append(release)
                existing_tags.add(tag_name)
                processed += 1
            
            # Remove processed releases from queue
            for release in releases_to_add:
                if release in self._pending_releases:
                    self._pending_releases.remove(release)
            
            # Add releases to UI
            for release in releases_to_add:
                try:
                    self._add_release_to_list(release)
                    self.releases_loaded_count += 1
                    self.all_releases_loaded.append(release)
                except (RuntimeError, AttributeError) as e:
                    silent_print(f"Error adding release to list: {e}")
                    continue
            
            # Show left panel when first release is loaded
            if self.releases_loaded_count > 0 and not self.left_panel.isVisible():
                self._show_left_panel()
            
            # If there are more releases to process, schedule another batch
            if self._pending_releases:
                if self._release_update_timer:
                    self._release_update_timer.start(200)  # Longer delay between batches

            if self.package_list.count() > 0 and not self.package_list.currentItem():
                try:
                    self.package_list.setCurrentRow(0)
                    first_item = self.package_list.item(0)
                    if first_item:
                        self.on_release_selected(first_item)
                except Exception as select_err:
                    silent_print(f"Error selecting first release after batch: {select_err}")
        except Exception as e:
            silent_print(f"Error processing batched releases: {e}")
            import traceback
            traceback.print_exc()
            self._pending_releases = []
    
    def _on_background_refresh_failed(self, error_msg):
        """Handle background refresh failure - silently continue with cached data"""
        silent_print(f"Background refresh failed (using cached data): {error_msg}")
        # Don't show error - just continue with cached releases
    
    def _on_all_releases_loaded(self, releases):
        """Handle releases loaded from a package - queue for batched UI update"""
        try:
            # Queue releases for batched processing
            if not hasattr(self, '_all_releases_pending'):
                self._all_releases_pending = []
            
            # Add software info to each release and queue them
            for release in releases:
                self._all_releases_pending.append(release)
            
            # Start batch processing timer if not already active
            if not hasattr(self, '_all_releases_timer') or self._all_releases_timer is None:
                self._all_releases_timer = QTimer()
                self._all_releases_timer.setSingleShot(True)
                self._all_releases_timer.timeout.connect(self._process_all_releases_batch)
            
            if not self._all_releases_timer.isActive():
                self._all_releases_timer.start(150)  # Process every 150ms
        except Exception as e:
            silent_print(f"Error queuing all releases: {e}")
    
    def _process_all_releases_batch(self):
        """Process queued releases from all packages in batches"""
        try:
            if not hasattr(self, '_all_releases_pending') or not self._all_releases_pending:
                return
            
            # Defensive check - ensure UI elements exist
            if not hasattr(self, 'package_list') or self.package_list is None:
                self._all_releases_pending = []
                return
            
            # Get existing tags to avoid duplicates
            existing_tags = set()
            try:
                list_count = self.package_list.count()
                for i in range(list_count):
                    try:
                        item = self.package_list.item(i)
                        if item and item.data(Qt.UserRole):
                            data = item.data(Qt.UserRole)
                            if isinstance(data, dict) and not data.get('is_link'):
                                existing_tag = data.get('tag_name', '')
                                if existing_tag:
                                    existing_tags.add(existing_tag)
                    except:
                        continue
            except RuntimeError:
                self._all_releases_pending = []
                return
            
            # Process up to 5 releases at a time
            batch_size = 5
            processed = 0
            releases_to_add = []
            
            for release in self._all_releases_pending[:]:
                if processed >= batch_size:
                    break
                
                tag_name = release.get('tag_name', '')
                if not tag_name or tag_name in existing_tags:
                    self._all_releases_pending.remove(release)
                    continue
                
                # For ARM64 users, only show releases with update.zip
                if platform.system() == "Windows":
                    driver_info = self.check_drivers_and_architecture()
                    if driver_info.get('is_arm64', False):
                        # Check if release has update.zip
                        assets = release.get('assets', [])
                        has_update_zip = any(
                            asset.get('name', '').lower() == 'update.zip'
                            for asset in assets
                        )
                        if not has_update_zip:
                            # Skip releases without update.zip for ARM64 users
                            self._all_releases_pending.remove(release)
                            continue
                
                releases_to_add.append(release)
                existing_tags.add(tag_name)
                processed += 1
            
            # Remove processed releases from queue
            for release in releases_to_add:
                if release in self._all_releases_pending:
                    self._all_releases_pending.remove(release)
            
            # Add releases to UI
            for release in releases_to_add:
                try:
                    software_name = release.get('software_name', 'Unknown')
                    display_text = f"{software_name} - {release['tag_name']}"

                    if self._is_prerelease_build(release):
                        self._ensure_prerelease_checkbox_available()

                    item = QListWidgetItem(display_text)
                    item.setData(Qt.UserRole, release)
                    self.package_list.addItem(item)
                except (RuntimeError, AttributeError) as e:
                    silent_print(f"Error adding release to list: {e}")
                continue
                
            # Show left panel when first release is loaded
            if self.package_list.count() > 0 and not self.left_panel.isVisible():
                self._show_left_panel()
            
            # If there are more releases to process, schedule another batch
            if self._all_releases_pending:
                if self._all_releases_timer:
                    self._all_releases_timer.start(200)
        except Exception as e:
            silent_print(f"Error processing all releases batch: {e}")
            import traceback
            traceback.print_exc()
            self._all_releases_pending = []
    
    def _on_all_releases_complete(self, all_releases):
        """Handle completion of loading all releases from all packages"""
        try:
            silent_print(f"All releases loading complete: {len(all_releases)} total releases")
            
            # Defensive check - ensure UI elements exist
            if not hasattr(self, 'package_list') or self.package_list is None:
                return
            
            # Process any remaining releases in the queue
            if hasattr(self, '_all_releases_pending') and self._all_releases_pending:
                QTimer.singleShot(0, self._process_all_releases_batch)
                # Continue processing until queue is empty
                def continue_processing():
                    if hasattr(self, '_all_releases_pending') and self._all_releases_pending:
                        self._process_all_releases_batch()
                        if hasattr(self, '_all_releases_pending') and self._all_releases_pending:
                            QTimer.singleShot(50, continue_processing)
                QTimer.singleShot(50, continue_processing)
            
            # If no releases were loaded, show offline message
            if self.package_list.count() == 0:
                has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
                self._show_offline_message(has_tokens)
                return
            
            # Sort releases by software name (alphabetical), then by date (newest first)
            try:
                # Get all items from list
                items = []
                for i in range(self.package_list.count()):
                    item = self.package_list.item(i)
                    if item and item.data(Qt.UserRole):
                        items.append((item, item.data(Qt.UserRole)))
                
                # Sort by software name, then by date
                def sort_key(item_data):
                    release = item_data[1]
                    software_name = release.get('software_name', '')
                    published_at = release.get('published_at', '')
                    try:
                        from datetime import datetime
                        date_obj = datetime.fromisoformat(published_at.replace('Z', '+00:00'))
                        timestamp = date_obj.timestamp()
                    except:
                        timestamp = 0
                    return (software_name, -timestamp)
                
                items.sort(key=sort_key)
                
                # Clear and re-add sorted items
                self.package_list.clear()
                for item, release in items:
                    software_name = release.get('software_name', 'Unknown')
                    display_text = f"{software_name} - {release['tag_name']}"
                    new_item = QListWidgetItem(display_text)
                    new_item.setData(Qt.UserRole, release)
                    self.package_list.addItem(new_item)
                
            except Exception as e:
                silent_print(f"Error sorting releases: {e}")
            
            # Auto-filter for Fast Update: If only pre-releases have update.zip, auto-set filters
            self._auto_filter_for_fast_update()
            
            # Show left panel if releases are available
            if self.package_list.count() > 0:
                self._show_left_panel()
            
            # Select first item if available
            try:
                if self.package_list.count() > 0:
                    first_item = self.package_list.item(0)
                    if first_item and isinstance(first_item.data(Qt.UserRole), dict) and not first_item.data(Qt.UserRole).get('is_link'):
                        self.package_list.setCurrentRow(0)
                        self.on_release_selected(first_item)
            except (RuntimeError, AttributeError) as e:
                silent_print(f"Error selecting first item: {e}")
        except Exception as e:
            silent_print(f"Error in _on_all_releases_complete: {e}")
            import traceback
            traceback.print_exc()
    
    def _on_all_releases_failed(self, error_msg):
        """Handle failure to load all releases"""
        try:
            silent_print(f"Failed to load all releases: {error_msg}")
            
            # Defensive check - ensure UI elements exist
            if not hasattr(self, 'package_list') or self.package_list is None:
                return
            
            # If no releases were loaded, show offline message
            if self.package_list.count() == 0:
                has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
                self._show_offline_message(has_tokens)
            # If we have some releases, just continue with what we have
        except Exception as e:
            silent_print(f"Error in _on_all_releases_failed: {e}")
    
    def _has_view_older_link(self):
        """Check if 'View Older Releases' link already exists"""
        try:
            if not hasattr(self, 'package_list') or self.package_list is None:
                return False
            for i in range(self.package_list.count()):
                item = self.package_list.item(i)
                if item and item.data(Qt.UserRole):
                    data = item.data(Qt.UserRole)
                    if isinstance(data, dict) and data.get('is_link'):
                        return True
        except (RuntimeError, AttributeError):
            return False
        return False
    
    def _auto_filter_for_fast_update(self):
        """Auto-filter to show pre-releases if only they have update.zip - only on Windows ARM64"""
        try:
            # Only auto-filter on Windows ARM64
            if platform.system() != "Windows":
                return
            
            driver_info = self.check_drivers_and_architecture()
            if not driver_info.get('is_arm64', False):
                return
            
            # Check if we've already auto-filtered (prevent infinite loops)
            if hasattr(self, '_auto_filtered_for_fast_update') and self._auto_filtered_for_fast_update:
                return
            
            # Check currently selected software first, then all software
            selected_repo = self.firmware_combo.currentData()
            repos_to_check = []
            
            if selected_repo:
                # Check selected software first
                repos_to_check.append(selected_repo)
            
            # Also check all other software
            for package in self.packages:
                repo = package.get('repo', '')
                if repo and repo not in repos_to_check:
                    repos_to_check.append(repo)
            
            # Check all releases to see if regular builds have update.zip
            has_regular_with_update_zip = False
            has_prerelease_with_update_zip = False
            prerelease_software = set()
            
            # Get all releases from packages
            for repo in repos_to_check:
                if not repo:
                    continue
                
                try:
                    releases = self.github_api.get_all_releases(repo)
                    if releases:
                        for release in releases:
                            # Check if release has update.zip
                            assets = release.get('assets', [])
                            has_update_zip = any(
                                asset.get('name', '').lower() == 'update.zip'
                                for asset in assets
                            )
                            
                            if has_update_zip:
                                if self._is_prerelease_build(release):
                                    has_prerelease_with_update_zip = True
                                    prerelease_software.add(repo)
                                else:
                                    has_regular_with_update_zip = True
                except Exception as e:
                    silent_print(f"Error checking releases for {repo}: {e}")
                    continue
            
            # If only pre-releases have update.zip, auto-set filters
            if not has_regular_with_update_zip and has_prerelease_with_update_zip and prerelease_software:
                # Find software that has pre-releases with update.zip
                # Prefer currently selected software if it has pre-releases with update.zip
                target_repo = None
                if selected_repo and selected_repo in prerelease_software:
                    target_repo = selected_repo
                else:
                    # Try to find matching software in combo
                    for repo in prerelease_software:
                        for i in range(self.firmware_combo.count()):
                            if self.firmware_combo.itemData(i) == repo:
                                target_repo = repo
                                break
                        if target_repo:
                            break
                    
                    # If no exact match, use first available
                    if not target_repo and prerelease_software:
                        target_repo = list(prerelease_software)[0]
                
                if target_repo:
                    # Set software filter if not already set
                    if selected_repo != target_repo:
                        for i in range(self.firmware_combo.count()):
                            if self.firmware_combo.itemData(i) == target_repo:
                                self.firmware_combo.blockSignals(True)
                                self.firmware_combo.setCurrentIndex(i)
                                self.firmware_combo.blockSignals(False)
                                break
                    
                    # Enable pre-release checkbox if not already enabled
                    if hasattr(self, 'show_prerelease_checkbox'):
                        if not self.show_prerelease_checkbox.isChecked():
                            self.show_prerelease_checkbox.blockSignals(True)
                            self.show_prerelease_checkbox.setChecked(True)
                            self.show_prerelease_checkbox.setVisible(True)
                            self.show_prerelease_checkbox.blockSignals(False)
                            
                            # Mark as auto-filtered to prevent loops
                            self._auto_filtered_for_fast_update = True
                            
                            # Refresh releases list with new filters
                            self.populate_releases_list()
                            
                            silent_print(f"Auto-filtered to show pre-releases with update.zip for {target_repo}")
        except Exception as e:
            silent_print(f"Error in auto-filter for Fast Update: {e}")
            import traceback
            traceback.print_exc()

    def on_releases_loading_complete(self, all_releases):
        """Handle completion of loading all releases"""
        try:
            silent_print(f"Progressive loading complete: {len(all_releases)} total, {self.releases_loaded_count} displayed")
            
            # Defensive check - ensure UI elements exist
            if not hasattr(self, 'package_list') or self.package_list is None:
                return
            
            # Remove loading placeholder if still there
            try:
                if self.package_list.count() > 0:
                    first_item = self.package_list.item(0)
                    if first_item and first_item.text() == "Loading releases...":
                        self.package_list.takeItem(0)
            except (RuntimeError, AttributeError):
                pass
            
            # No "View Older Releases" link needed - no limit on releases
            
            # Process any remaining releases in the queue
            if hasattr(self, '_pending_releases') and self._pending_releases:
                # Process remaining releases immediately
                QTimer.singleShot(0, self._process_batched_releases)
                # Continue processing until queue is empty
                def continue_processing():
                    if hasattr(self, '_pending_releases') and self._pending_releases:
                        self._process_batched_releases()
                        if hasattr(self, '_pending_releases') and self._pending_releases:
                            QTimer.singleShot(50, continue_processing)
                QTimer.singleShot(50, continue_processing)
            
            # If no releases were loaded, show offline message
            if self.releases_loaded_count == 0:
                # Check if we have tokens (might be online)
                has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
                self._show_offline_message(has_tokens)
                # Disable download button when offline
                self.download_btn.setEnabled(False)
                return
            
            # Check online status before enabling download button
            is_online = self.is_online()
            
            # Auto-filter for Fast Update: If only pre-releases have update.zip, auto-set filters
            self._auto_filter_for_fast_update()
            
            # Show left panel if releases are available
            self._show_left_panel()
            
            # Enable download button only when online
            # This prevents users from attempting downloads when offline
            if is_online:
                self.download_btn.setEnabled(True)
            else:
                self.download_btn.setEnabled(False)
                silent_print("Download button disabled - offline mode")
            
            # Select first item if available
            try:
                if self.package_list.count() > 0:
                    first_item = self.package_list.item(0)
                    if first_item and isinstance(first_item.data(Qt.UserRole), dict) and not first_item.data(Qt.UserRole).get('is_link'):
                        self.package_list.setCurrentRow(0)
                        self.on_release_selected(first_item)
            except (RuntimeError, AttributeError) as e:
                silent_print(f"Error selecting first item: {e}")
        except Exception as e:
            silent_print(f"Error in on_releases_loading_complete: {e}")
            import traceback
            traceback.print_exc()

    def on_releases_loading_failed(self, error_msg):
        """Handle failure to load releases - only show error if no cached data"""
        silent_print(f"Progressive loading failed: {error_msg}")
        # Only show error if list is empty (no cached data was shown)
        if self.package_list.count() == 0 or (self.package_list.count() == 1 and self.package_list.item(0).text() == "Loading releases..."):
            self.package_list.clear()
            self.package_list.addItem("Unable To Load Releases")
        # If we have cached releases, silently continue using them

    def _add_release_to_list(self, release):
        """Add a single release to the list with detailed information"""
        try:
            tag_name = release.get('tag_name', '')
            selected_repo = self.firmware_combo.currentData()
            
            if not selected_repo:
                silent_print("No repo selected, cannot add release")
                return

            # Find the package info for this release to get software name from manifest
            package_info = None
            for package in self.packages:
                if package.get('repo') == selected_repo:
                    package_info = package
                    break

            # Get software name from manifest, fallback to repo name
            software_name = package_info.get('name', selected_repo) if package_info else selected_repo

            # Parse version designations
            version_info = parse_version_designations(release.get('tag_name', ''))
            
            # Get display version (either version number or published date)
            published_date = release.get('published_at', '')
            display_version = get_display_version(version_info, published_date)
            
            # Use display version as the main title
            display_text = f"{display_version}\n"
            
            # Add software name
            software_name = package_info.get('name', 'Unknown') if package_info else 'Unknown'
            display_text += f"Software: {software_name}\n"
            
            # Add designations as formatted text
            if version_info.get('designations'):
                designations_text = format_designations_text(version_info['designations'])
                display_text += f"{designations_text}\n"

            # Only show published date if we're using version number as title
            if len(version_info.get('clean_version', '')) <= 8 and published_date:
                try:
                    from datetime import datetime
                    date_obj = datetime.fromisoformat(published_date.replace('Z', '+00:00'))
                    display_text += f"Released: {format_fancy_date(date_obj)}\n"
                except:
                    display_text += f"Released: {published_date}\n"

            # Add software name and repo name to release info for button text logic
            release_with_software = release.copy()
            release_with_software['software_name'] = software_name
            release_with_software['repo_name'] = selected_repo

            if self._is_prerelease_build(release_with_software):
                self._ensure_prerelease_checkbox_available()

            item = QListWidgetItem(display_text)
            item.setData(Qt.UserRole, release_with_software)
            self.package_list.addItem(item)

            silent_print(f"Added release to UI: {tag_name}")
        except Exception as e:
            silent_print(f"Error in _add_release_to_list: {e}")
            import traceback
            traceback.print_exc()

    def _add_view_older_link(self):
        """Add 'View Older Releases' link if not already present"""
        # Check if link already exists
        for i in range(self.package_list.count()):
            item = self.package_list.item(i)
            if item and item.data(Qt.UserRole):
                data = item.data(Qt.UserRole)
                if isinstance(data, dict) and data.get('is_link'):
                    return  # Link already exists
        
        # Add separator for visual clarity
        separator_item = QListWidgetItem("")
        separator_item.setFlags(separator_item.flags() & ~Qt.ItemIsSelectable)
        self.package_list.addItem(separator_item)
        
        # Add clickable link item
        link_item = QListWidgetItem("üìã View Older Releases Online")
        link_item.setData(Qt.UserRole, {'is_link': True, 'url': 'https://innioasis.app/firmware.html'})
        link_item.setToolTip("View complete release history online (showing 10 most recent)")
        self.package_list.addItem(link_item)

    def retry_releases_after_tokens_loaded(self):
        """Retry loading releases after tokens have been loaded in background"""
        # Check if tokens are now available
        has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
        if has_tokens:
            silent_print("Tokens are now available, retrying release loading...")
            self.populate_releases_list()
        else:
            silent_print("Tokens still not available, will retry again...")
            # Retry again after another 1.5 seconds
            QTimer.singleShot(1500, self.retry_releases_after_tokens_loaded)

    def handle_releases_timeout(self):
        """Handle timeout when loading releases"""
        self.package_list.clear()
        self.package_list.addItem("Unable To Load Releases")
        # Don't update status label - keep it as "Ready" for firmware installation status only
        silent_print("Timeout loading releases")

    def populate_all_releases_list(self):
        """Populate the package list with releases from all available software"""
        self.package_list.clear()

        # Get all software options that match current filters
        selected_type = self.device_type_combo.currentData()
        selected_model = self.device_model_combo.currentData()

        all_releases = []
        failed_repos = []

        for package in self.packages:
            name = package.get('name', '')
            repo = package.get('repo', '')
            device_model = package.get('device', '')

            # Check device model filter
            model_match = not selected_model or device_model == selected_model

            if name and repo and model_match:
                # Get releases for this software with retry
                releases = self.github_api.retry_with_delay(self.github_api.get_all_releases, repo)
                if releases and len(releases) > 0:
                    for release in releases:
                        # Filter releases based on tag name and selected type
                        tag_name = release.get('tag_name', '')
                        
                        # Skip releases that should be excluded (e.g., contains 'base')
                        if self._should_exclude_release(tag_name):
                            continue
                            
                        if self._release_matches_type_filter(tag_name, selected_type):
                            # For ARM64 users, only show releases with update.zip
                            if platform.system() == "Windows":
                                driver_info = self.check_drivers_and_architecture()
                                if driver_info.get('is_arm64', False):
                                    # Check if release has update.zip
                                    assets = release.get('assets', [])
                                    has_update_zip = any(
                                        asset.get('name', '').lower() == 'update.zip'
                                        for asset in assets
                                    )
                                    if not has_update_zip:
                                        # Skip releases without update.zip for ARM64 users
                                        continue
                            
                            # Add software name and repo name to the release info for identification
                            release_with_software = release.copy()
                            release_with_software['software_name'] = name
                            release_with_software['repo_name'] = repo
                            all_releases.append(release_with_software)
                else:
                    failed_repos.append(repo)

        # Sort releases by software name (alphabetical), then by date (newest first within each software)
        # Use a custom sorting key that sorts alphabetically by software name, then by date (newest first)
        def sort_key(release):
            software_name = release.get('software_name', '')
            published_at = release.get('published_at', '')
            # Convert date string to a comparable format for sorting (newest first)
            try:
                from datetime import datetime
                date_obj = datetime.fromisoformat(published_at.replace('Z', '+00:00'))
                timestamp = date_obj.timestamp()
            except:
                timestamp = 0
            # Return a tuple: (software_name, -timestamp) where negative timestamp ensures newest first
            return (software_name, -timestamp)

        all_releases.sort(key=sort_key)

        # Show error message if no releases were found
        if not all_releases and failed_repos:
            # Don't update status label - keep it as "Ready" for firmware installation status only
            silent_print(f"Failed to load releases from repositories: {failed_repos}")
            
            # Add helpful message to the list
            help_item = QListWidgetItem("‚ö†Ô∏è No releases found\n\nThis could be due to:\n‚Ä¢ GitHub API rate limiting\n‚Ä¢ Network connectivity issues\n‚Ä¢ Repository access restrictions\n\nTry using 'Browse Files' button instead")
            help_item.setFlags(help_item.flags() & ~Qt.ItemIsSelectable)  # Make it non-selectable
            help_item.setData(Qt.UserRole, None)  # No release data
            self.package_list.addItem(help_item)
            
            # Also update status to be more helpful
            self.status_label.setText("GitHub API unavailable - use 'Browse Files' button")
        elif all_releases:
            # Don't update status label - keep it as "Ready" for firmware installation status only
            silent_print(f"Loaded {len(all_releases)} releases successfully")

        for release in all_releases:
            # Find the package info for this release to get device type and model
            package_info = None
            for package in self.packages:
                if package.get('name') == release['software_name']:
                    package_info = package
                    break

            # Parse version designations
            version_info = parse_version_designations(release['tag_name'])
            
            # Get display version (either version number or published date)
            published_date = release.get('published_at', '')
            display_version = get_display_version(version_info, published_date)
            
            # Use display version as the main title
            display_text = f"{display_version}\n"
            
            # Add software name
            software_name = package_info.get('name', 'Unknown') if package_info else 'Unknown'
            display_text += f"Software: {software_name}\n"
            
            # Add designations as formatted text
            if version_info['designations']:
                designations_text = format_designations_text(version_info['designations'])
                display_text += f"{designations_text}\n"

            # Only show published date if we're using version number as title
            if len(version_info['clean_version']) <= 8 and published_date:
                try:
                    from datetime import datetime
                    date_obj = datetime.fromisoformat(published_date.replace('Z', '+00:00'))
                    display_text += f"Released: {format_fancy_date(date_obj)}\n"
                except:
                    display_text += f"Released: {published_date}\n"

            # Device type is now determined from release tags, not manifest
            # No need to show device type from manifest since it's been removed

            # Show device model if "All Models" is selected
            if not self.device_model_combo.currentData() and package_info:
                device_model = package_info.get('device', '')
                if device_model:
                    display_text += f"Model: {device_model}\n"

            item = QListWidgetItem(display_text)
            item.setData(Qt.UserRole, release)
            self.package_list.addItem(item)

        # Automatically select the first item for improved discoverability
        if self.package_list.count() > 0:
            self.package_list.setCurrentRow(0)
            self.package_list.setFocus()  # Give focus to the list for blue highlight
            self.download_btn.setEnabled(True)
            # Update button text for the first selected item
            first_item = self.package_list.item(0)
            self.update_download_button_text(first_item)

    def show_context_menu(self, position):
        """Show context menu for right-click on firmware items"""
        item = self.package_list.itemAt(position)
        
        # Get the firmware data from the item (if any)
        firmware_data = None
        if item is not None:
            firmware_data = item.data(Qt.UserRole)

        from PySide6.QtWidgets import QMenu

        context_menu = QMenu(self)
        
        # Add "View Releases" option (only if we have firmware data with repo_name)
        view_releases_action = None
        if firmware_data and firmware_data.get('repo_name'):
            view_releases_action = context_menu.addAction("View Releases")
        
        # Add "Firmware Directory" option (always available)
        firmware_directory_action = context_menu.addAction("Firmware Directory")
        
        # Add separator before delete options (only if we have firmware data)
        if firmware_data:
            context_menu.addSeparator()
            delete_action = context_menu.addAction("Delete Local Zip File")
        else:
            delete_action = None
        
        # Add separator and "Delete All Cached Zips" option (always available)
        context_menu.addSeparator()
        delete_all_action = context_menu.addAction("Delete All Cached Zips")
        
        # Add separator and "Manage Storage" option (always available)
        context_menu.addSeparator()
        manage_storage_action = context_menu.addAction("Manage Storage")

        action = context_menu.exec(self.package_list.mapToGlobal(position))

        if action == view_releases_action and firmware_data:
            # Open GitHub releases page for this software
            repo_name = firmware_data.get('repo_name', '')
            if repo_name:
                github_url = f"https://github.com/{repo_name}/releases"
                webbrowser.open(github_url)
                self.status_label.setText(f"Opened releases page for {repo_name}")
        
        elif action == firmware_directory_action:
            # Open Innioasis firmware directory webpage
            webbrowser.open("https://innioasis.app/firmware.html")
            self.status_label.setText("Opened Innioasis Firmware Directory")
        
        elif action == delete_action and firmware_data:
            # Extract repo_name and version from the firmware data
            repo_name = firmware_data.get('repo_name', '')
            version = firmware_data.get('version', '')

            if repo_name and version:
                if delete_zip_file(repo_name, version):
                    QMessageBox.information(self, "Success", f"Deleted zip file for {repo_name} version {version}")
                else:
                    QMessageBox.information(self, "Info", f"No local zip file found for {repo_name} version {version}")
        
        elif action == delete_all_action:
            # Delete all cached zip files
            self.delete_all_cached_zips()
        
        elif action == manage_storage_action:
            # Launch storage management tool
            self.launch_storage_management_tool()

    def delete_all_cached_zips(self):
        """Delete all cached zip files and show confirmation"""
        try:
            # Confirm deletion
            reply = QMessageBox.question(
                self,
                "Delete All Cached Zips",
                "Are you sure you want to delete all cached zip files?\n\nThis will free up disk space but require re-downloading any firmware you want to install.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            
            if reply == QMessageBox.Yes:
                deleted_count = delete_all_cached_zips()
                if deleted_count > 0:
                    QMessageBox.information(
                        self,
                        "Success",
                        f"Successfully deleted {deleted_count} cached zip file(s)."
                    )
                else:
                    QMessageBox.information(
                        self,
                        "Info",
                        "No cached zip files found to delete."
                    )
        except Exception as e:
            QMessageBox.warning(
                self,
                "Error",
                f"Error deleting cached zip files: {e}"
            )

    def populate_all_releases_list_progressive(self):
        """Populate the releases list progressively for all software using worker thread"""
        self.package_list.clear()

        # Stop any existing all releases worker
        if hasattr(self, 'all_releases_worker') and self.all_releases_worker:
            try:
                old_worker = self.all_releases_worker
                if old_worker.isRunning():
                    old_worker.stop()
                    # Disconnect signals first
                    try:
                        old_worker.releases_loaded.disconnect()
                        old_worker.loading_complete.disconnect()
                        old_worker.loading_failed.disconnect()
                    except:
                        pass
                    # Let it clean up asynchronously (non-blocking)
                    def cleanup_worker():
                        try:
                            if not old_worker.isRunning():
                                old_worker.deleteLater()
                        except:
                            pass
                    old_worker.finished.connect(cleanup_worker)
                else:
                    old_worker.deleteLater()
            except Exception as e:
                silent_print(f"Error stopping all releases worker: {e}")
            self.all_releases_worker = None
        
        # Initialize tracking variables
        if not hasattr(self, '_all_releases_pending'):
            self._all_releases_pending = []
        self._all_releases_pending = []
        
        # Show offline message immediately (default state)
        has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
        self._show_offline_message(has_tokens)
        
        # Create and start worker thread
        if not self.packages:
            self._show_offline_message(has_tokens)
            return

        self.all_releases_worker = AllReleasesWorker(self.github_api, self.packages)
        self.all_releases_worker.setParent(self)  # Parent to main window for proper cleanup
        
        # Connect signals with QueuedConnection for thread safety
        self.all_releases_worker.releases_loaded.connect(
            self._on_all_releases_loaded, 
            Qt.ConnectionType.QueuedConnection
        )
        self.all_releases_worker.loading_complete.connect(
            self._on_all_releases_complete, 
            Qt.ConnectionType.QueuedConnection
        )
        self.all_releases_worker.loading_failed.connect(
            self._on_all_releases_failed, 
            Qt.ConnectionType.QueuedConnection
        )
        
        # Connect finished signal to clean up properly
        worker_ref = self.all_releases_worker
        def cleanup_worker():
            if hasattr(self, 'all_releases_worker') and self.all_releases_worker == worker_ref:
                try:
                    if not self.all_releases_worker.isRunning():
                        self.all_releases_worker.deleteLater()
                except:
                    pass
        
        self.all_releases_worker.finished.connect(cleanup_worker)
        self.all_releases_worker.start()
        
        silent_print("Started loading all releases in background thread")

    def update_download_button_text(self, item):
        """Update install button text based on selected item"""
        # Button text is always "Install / Restore" - no need to change it
        pass
    
    def _get_text_color_for_theme(self):
        """Get appropriate text color based on current theme (matches update banner colors)"""
        try:
            # Check if we're in dark mode using Qt's palette
            palette = self.palette()
            bg_color = palette.color(palette.ColorRole.Window)
            # If background is dark (brightness < 128), use white text, otherwise dark text
            is_dark = bg_color.lightness() < 128
            # Use same colors as update banner for consistency
            return "#F5F9FF" if is_dark else "#0C1B33"
        except:
            # Fallback: try to get theme from theme monitor
            try:
                if hasattr(self, 'theme_monitor') and self.theme_monitor:
                    current_theme = self.theme_monitor._get_current_theme()
                    return "#F5F9FF" if current_theme == "dark" else "#0C1B33"
            except:
                pass
            # Default to dark text (light mode)
            return "#0C1B33"

    def on_release_selected(self, item):
        """Handle release selection from the list"""
        # Check if this is the "View Older Releases" link
        if item and item.data(Qt.UserRole):
            data = item.data(Qt.UserRole)
            if isinstance(data, dict) and data.get('is_link'):
                # Open the URL in browser
                url = data.get('url', 'https://innioasis.app/firmware.html')
                webbrowser.open(url)
                return  # Don't enable download button for links
        
        self.download_btn.setEnabled(True)
        self.update_download_button_text(item)
        
        # Show release notes in the image display area
        if item and item.data(Qt.UserRole):
            release_info = item.data(Qt.UserRole)
            
            # Get release notes/body
            release_body = release_info.get('body', '')
            release_name = release_info.get('name', '')
            tag_name = release_info.get('tag_name', '')
            
            # Format release notes for display
            try:
                if release_body or release_name:
                    # Create HTML content for release notes
                    import html as html_module
                    import re
                    
                    # Escape release name and tag name
                    safe_release_name = html_module.escape(str(release_name or tag_name))
                    
                    # Get theme-aware text color
                    text_color = self._get_text_color_for_theme()
                    
                    notes_html = f"""<html>
                    <head>
                        <style>
                            body, div, p, h1, h2, h3, h4, h5, h6, ul, ol, li, span, a {{
                                color: {text_color} !important;
                            }}
                        </style>
                    </head>
                    <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>"""
                    notes_html += f"<h2 style='margin-top: 0; color: {text_color} !important;'>{safe_release_name}</h2>"
                    
                    if release_body:
                        # Simple markdown to HTML conversion
                        body_html = str(release_body)
                        
                        # Escape HTML first to prevent XSS
                        body_html = html_module.escape(body_html)
                        
                        # Convert markdown to HTML (simplified, safe approach)
                        lines = body_html.split('\n')
                        
                        # Find "Instructions"/"how"/"usage"/"using"/"manual" line and "Change"/"What's New" line
                        instructions_index = -1
                        change_index = -1
                        
                        for i, line in enumerate(lines):
                            line_stripped = line.strip()
                            # Remove markdown formatting (###, ##, #)
                            cleaned_line = re.sub(r'^#+\s*', '', line_stripped, flags=re.IGNORECASE)
                            cleaned_lower = cleaned_line.lower()
                            
                            # Check for instructions keywords
                            if instructions_index == -1 and any(cleaned_lower.startswith(keyword) for keyword in ['instructions', 'how', 'usage', 'using', 'manual']):
                                instructions_index = i
                            
                            # Check for Change/What's New
                            if change_index == -1 and (cleaned_lower.startswith('change') or cleaned_lower.startswith("what's new")):
                                change_index = i
                        
                        # Determine which lines to include
                        # If instructions line exists before Change line, include instructions section + content after Change line
                        if instructions_index != -1 and change_index != -1 and instructions_index < change_index:
                            # Include instructions line and content up to (but not including) Change line
                            # Then include content after Change line
                            before_change = lines[instructions_index:change_index]
                            after_change = lines[change_index + 1:]
                            lines = before_change + after_change
                        elif instructions_index != -1 and change_index != -1:
                            # Change line comes before instructions - start after Change line
                            lines = lines[change_index + 1:]
                        elif instructions_index != -1:
                            # Only instructions line found - include from instructions onwards
                            lines = lines[instructions_index:]
                        elif change_index != -1:
                            # Only Change line found - start after it
                            lines = lines[change_index + 1:]
                        # If neither found, keep all lines (lines = lines)
                        
                        # Check if device is fast update enabled (rooted and has update.sh)
                        is_fast_update_enabled = self.is_device_fast_update_enabled()
                        
                        # Replace "See README.md for more information" with detailed text if both conditions are met
                        # Skip this if device is already fast update enabled
                        if not is_fast_update_enabled:
                            release_body_lower = release_body.lower() if release_body else ''
                            if 'update functionality' in release_body_lower:
                                # Check if any line contains "See README.md for more information"
                                for i, line in enumerate(lines):
                                    line_stripped = line.strip()
                                    # Check for "See README.md" pattern (case-insensitive)
                                    if 'see readme.md' in line_stripped.lower() or 'see readme' in line_stripped.lower():
                                        if 'for more information' in line_stripped.lower() or 'more information' in line_stripped.lower():
                                            # Replace this line with the new text (split into multiple lines for better spacing)
                                            # Split into paragraphs for better readability, using markdown bold syntax
                                            replacement_text = [
                                                "Users can download update.zip files and place them on their device to update their player without needing to keep it plugged into a computer.",
                                                "",
                                                "These ‚ö°Ô∏è **Fast Updates** can be sent to your device from Innioasis Updater or downloaded directly from the web.",
                                                "",
                                                "In order to use ‚ö°Ô∏è **Fast Update** for the first time, you'll need to have first installed a ‚ö°Ô∏è **Fast Update** enabled update, using your computer."
                                            ]
                                            # Replace the single line with multiple lines
                                            lines[i:i+1] = replacement_text
                                        break
                        else:
                            # Device is fast update enabled - remove README.md line entirely
                            lines = [line for line in lines if not (('see readme.md' in line.lower() or 'see readme' in line.lower()) and ('for more information' in line.lower() or 'more information' in line.lower()))]
                        
                        converted_lines = []
                        in_list = False
                        
                        for line in lines:
                            line_stripped = line.strip()
                            
                            # Check for headers (must be at start of line)
                            if line_stripped.startswith('### '):
                                text = line_stripped[4:].strip()
                                if not in_list:
                                    converted_lines.append(f'<h4 style="color: {text_color} !important;">{text}</h4>')
                                else:
                                    converted_lines.append('</ul>')
                                    converted_lines.append(f'<h4 style="color: {text_color} !important;">{text}</h4>')
                                    in_list = False
                            elif line_stripped.startswith('## '):
                                text = line_stripped[3:].strip()
                                if in_list:
                                    converted_lines.append('</ul>')
                                    in_list = False
                                converted_lines.append(f'<h3 style="color: {text_color} !important;">{text}</h3>')
                            elif line_stripped.startswith('# '):
                                text = line_stripped[2:].strip()
                                if in_list:
                                    converted_lines.append('</ul>')
                                    in_list = False
                                converted_lines.append(f'<h2 style="color: {text_color} !important;">{text}</h2>')
                            # Check for lists
                            elif line_stripped.startswith('- ') or line_stripped.startswith('* '):
                                if not in_list:
                                    converted_lines.append(f'<ul style="color: {text_color} !important;">')
                                    in_list = True
                                text = line_stripped[2:].strip()
                                # Convert markdown bold (**text**) to HTML bold in list items
                                text = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)
                                converted_lines.append(f'<li style="color: {text_color} !important;">{text}</li>')
                            elif line_stripped == '':
                                # Empty line - close list if open
                                if in_list:
                                    converted_lines.append('</ul>')
                                    in_list = False
                                converted_lines.append('<br>')
                            else:
                                # Regular text - process markdown bold (**text**)
                                if in_list:
                                    converted_lines.append('</ul>')
                                    in_list = False
                                if line_stripped:
                                    # Convert markdown bold (**text**) to HTML bold
                                    processed_line = line_stripped
                                    # Replace **text** with <strong>text</strong>
                                    processed_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', processed_line)
                                    converted_lines.append(f'<span style="color: {text_color} !important;">{processed_line}</span><br>')
                        
                        # Close any open list
                        if in_list:
                            converted_lines.append('</ul>')
                        
                        # Join and wrap in paragraph
                        body_html = ''.join(converted_lines)
                        if body_html.strip():
                            # Wrap in paragraph, but preserve existing HTML tags
                            if not body_html.strip().startswith('<'):
                                body_html = f'<p style="color: {text_color} !important;">{body_html}</p>'
                        
                        notes_html += body_html
                    else:
                        notes_html += f"""<p style='color: {text_color} !important; margin-bottom: 10px;'>Fix update script</p>
                        <p style='color: {text_color} !important; margin-bottom: 10px;'>Bug fixes, performance and stability improvements.</p>
                        <p style='color: {text_color} !important; font-style: italic; font-size: 0.9em;'>(Release notes could not be loaded for this version)</p>"""
                    
                    notes_html += "</body></html>"
                    
                    # Set release notes and switch to notes view
                    # Set a flag to prevent concurrent UI updates from worker thread
                    self._displaying_release_notes = True
                    try:
                        # Set HTML directly with proper error handling
                        if hasattr(self, 'release_notes_browser') and self.release_notes_browser is not None:
                            try:
                                self.release_notes_browser.setHtml(notes_html)
                            except Exception as e:
                                silent_print(f"Error setting HTML in browser: {e}")
                                import traceback
                                traceback.print_exc()
                                raise
                        
                        if hasattr(self, 'image_notes_stack') and self.image_notes_stack is not None:
                            try:
                                self.image_notes_stack.setCurrentIndex(1)  # Switch to release notes (page 1)
                                # Update title to "About this update:" when showing release notes
                                if hasattr(self, 'output_group'):
                                    self.output_group.setTitle("About this update:")
                            except Exception as e:
                                silent_print(f"Error switching to notes view: {e}")
                                import traceback
                                traceback.print_exc()
                                # Fallback to image view
                                self.image_notes_stack.setCurrentIndex(0)
                                raise
                    except Exception as e:
                        silent_print(f"Error setting release notes: {e}")
                        import traceback
                        traceback.print_exc()
                        # Fallback to image view
                        if hasattr(self, 'image_notes_stack'):
                            try:
                                self.image_notes_stack.setCurrentIndex(0)
                            except:
                                pass
                    finally:
                        self._displaying_release_notes = False
                else:
                    # No release notes - show image instead
                    if hasattr(self, 'image_notes_stack'):
                        self.image_notes_stack.setCurrentIndex(0)  # Switch to image (page 0)
            except Exception as e:
                silent_print(f"Error formatting release notes: {e}")
                import traceback
                traceback.print_exc()
                # Fallback to image view on error
                if hasattr(self, 'image_notes_stack'):
                    self.image_notes_stack.setCurrentIndex(0)
            
            assets = release_info.get('assets', [])
            
            silent_print(f"Release has {len(assets)} assets")
            
            # Check if update.zip exists in assets
            has_update_zip = any(
                asset.get('name', '').lower() == 'update.zip'
                for asset in assets
            )
            
            if has_update_zip:
                silent_print("Found update.zip in release - showing Send to Y1 button")
                if hasattr(self, 'send_update_btn'):
                    self.send_update_btn.setVisible(True)
                    # Only enable if device is rooted and has update script
                    # Check device status - this will be updated by check_adb_and_update_script
                    # For now, disable it - it will be enabled by check_adb_and_update_script if conditions are met
                    self.send_update_btn.setEnabled(False)
                # Store update.zip URL for later use
                update_asset = next(
                    (asset for asset in assets if asset.get('name', '').lower() == 'update.zip'),
                    None
                )
                if update_asset:
                    self.current_update_zip_url = update_asset.get('browser_download_url')
                    silent_print(f"Update.zip URL: {self.current_update_zip_url}")
                    # Trigger ADB check to update button state
                    if hasattr(self, 'check_adb_and_update_script'):
                        QTimer.singleShot(100, self.check_adb_and_update_script)
            else:
                silent_print("No update.zip found in release - hiding Send to Y1 button")
                if hasattr(self, 'send_update_btn'):
                    self.send_update_btn.setVisible(False)
                    self.send_update_btn.setEnabled(False)
                self.current_update_zip_url = None
        else:
            # No release selected - show image
            if hasattr(self, 'image_notes_stack'):
                self.image_notes_stack.setCurrentIndex(0)  # Switch to image
            
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setVisible(False)
                self.send_update_btn.setEnabled(False)
            self.current_update_zip_url = None

    def run_mtk_command_guided(self):
        """Run the MTK flash command with image display for guided installation"""
        try:
            # Check driver availability for Windows users
            if platform.system() == "Windows":
                driver_info = self.check_drivers_and_architecture()
                
                if driver_info['is_arm64']:
                    silent_print("ARM64 Windows requested guided MTK install; operation skipped.")
                    self.status_label.setText("Install / Restore is unavailable on Windows ARM64.")
                    return
                    
                elif not driver_info['can_install_firmware'] and not driver_info.get('has_mtk_driver') and not driver_info.get('has_usbdk_driver'):
                    # Show warning but don't block - allow fallback methods
                    result = QMessageBox.information(
                        self,
                        "No Specific Drivers Detected",
                        "No specific drivers detected. The application will attempt installation using fallback methods.\n\n"
                        "If installation fails, consider installing drivers for better compatibility.\n\n"
                        "Click OK to continue with fallback methods or Cancel to install drivers.",
                        QMessageBox.Ok | QMessageBox.Cancel,
                        QMessageBox.Ok
                    )
                    if result == QMessageBox.Cancel:
                        self.open_driver_setup_link()
                        return
                    # Continue with fallback methods if OK is clicked
            
            # Check if required files exist
            required_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
            missing_files = []
            for file in required_files:
                if not Path(file).exists():
                    missing_files.append(file)

            if missing_files:
                QMessageBox.warning(self, "Error", f"Missing required files: {', '.join(missing_files)}")
                return

            # Confirm with user
            reply = QMessageBox.question(
                self,
                "Get Ready",
                "Before continuing, please:\n\n"
                "1. Power off your Y1\n"
                "   (You can use a pin or paperclip to press the reset button if needed)\n\n"
                "2. Disconnect the USB cable from your Y1 (if connected)\n\n"
                "Then click OK and follow the next instructions.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Cancel
            )

            if reply == QMessageBox.Cancel:
                return

            # Clean up libusb state before starting new MTK operation (Windows only)
            if platform.system() == "Windows":
                self.cleanup_libusb_state()

            # Create installation marker to track progress
            create_installation_marker()

            # Load and display the presteps image first, initsteps will be shown when mtk.py emits first empty line
            self.load_presteps_image()
            
            # Hide left panel for Method 1 installation to focus user attention on instructions
            self.hide_left_panel()

            # Start MTK worker
            if not self.mtk_worker or not self.mtk_worker.isRunning():
                # Create debug window if debug mode is enabled
                debug_window = None
                if getattr(self, 'debug_mode', False):
                    debug_window = DebugOutputWindow(self)
                    debug_window.show()
                
                self.mtk_worker = MTKWorker(debug_mode=getattr(self, 'debug_mode', False), debug_window=debug_window)
                # Use update_status instead of direct status_label.setText for proper status handling
                self.mtk_worker.status_updated.connect(self.update_status)
                self.mtk_worker.show_installing_image.connect(self.load_installing_image)
                self.mtk_worker.show_reconnect_image.connect(self.load_handshake_error_image)
                self.mtk_worker.show_presteps_image.connect(self.load_presteps_image)
                self.mtk_worker.show_please_wait_image.connect(self.load_please_wait_image)
                self.mtk_worker.show_initsteps_image.connect(self.load_initsteps_image)
                self.mtk_worker.show_instructions_image.connect(self.load_initsteps_image)
                self.mtk_worker.show_try_again_dialog.connect(self.show_try_again_dialog)
                self.mtk_worker.mtk_completed.connect(self.handle_mtk_completion)
                self.mtk_worker.handshake_failed.connect(self.handle_handshake_failure)
                self.mtk_worker.errno2_detected.connect(self.handle_errno2_error)
                self.mtk_worker.usb_io_error_detected.connect(self.on_usb_io_error_detected)
                self.mtk_worker.backend_error_detected.connect(self.handle_backend_error)
                self.mtk_worker.keyboard_interrupt_detected.connect(self.handle_keyboard_interrupt)
                self.mtk_worker.disable_update_button.connect(self.disable_update_button)
                self.mtk_worker.enable_update_button.connect(self.enable_update_button)
                self.mtk_worker.start()
                
                self.status_label.setText("Starting MTK installation...")
                silent_print("MTK worker started")
            else:
                silent_print("MTK worker already running")

            # Disable download button during MTK operation
            self.download_btn.setEnabled(False)
            self.settings_btn.setEnabled(False)
                
        except Exception as e:
            silent_print(f"Error starting MTK command: {e}")
            self.status_label.setText(f"Error starting MTK command: {e}")



    def on_mtk_completed(self, success, message):
        """Handle MTK command completion"""
        # Stop the MTK worker to prevent it from continuing to run
        if self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()  # Wait for the worker to finish
            self.mtk_worker = None

        if success:
            self.status_label.setText("Install completed successfully")
            # Remove installation marker on successful completion
            remove_installation_marker()
            # Clean up firmware files after successful installation
            cleanup_firmware_files()
            # Load and display installed.png for 30 seconds
            self.load_installed_image()
            # Restore left panel after successful installation
            self.show_left_panel()

            # Cancel any existing revert timer to prevent conflicts
            if hasattr(self, '_revert_timer') and self._revert_timer:
                self._revert_timer.stop()
                self._revert_timer = None

            # Set timer to revert to startup state after 30 seconds
            self._revert_timer = QTimer()
            self._revert_timer.timeout.connect(self.revert_to_startup_state)
            self._revert_timer.setSingleShot(True)
            self._revert_timer.start(30000)
        else:
            self.status_label.setText(f"MTK command failed: {message}")
            # On Windows: First show process_ended.png image briefly, then show install error dialog
            self.load_process_ended_image()
            # Restore left panel after failed installation
            self.show_left_panel()
            
            # Use a timer to show the dialog after a short delay so user sees the process_ended image
            QTimer.singleShot(2000, self.show_install_error_dialog)
            return  # Don't continue with the revert timer since user will choose action

        # Re-enable download button
        self.download_btn.setEnabled(True)
        # Re-enable settings button
        self.settings_btn.setEnabled(True)

    def disable_update_button(self):
        """Disable the update button during MTK installation"""
            # Disable buttons during operation - but don't reference update_btn_right
            # (update buttons removed - only banner is shown)
        # Also disable settings button during operations
        self.settings_btn.setEnabled(False)
        if hasattr(self, 'toolkit_btn'):
            self.toolkit_btn.setEnabled(False)

    def enable_update_button(self):
        """Enable the update button when returning to ready state"""
            # Re-enable buttons after operation - but don't reference update_btn_right
            # (update buttons removed - only banner is shown)
        # Also enable settings button when operations are complete
        self.settings_btn.setEnabled(True)
        if hasattr(self, 'toolkit_btn'):
            self.toolkit_btn.setEnabled(True)

    def hide_inappropriate_buttons_for_spflash(self):
        """Hide buttons that are inappropriate for SP Flash Tool methods"""
        try:
            # Hide download button (SP Flash Tool uses its own ROM files)
            if hasattr(self, 'download_btn'):
                self.download_btn.setVisible(False)
            
            # Hide update button (not relevant during SP Flash Tool installation)
            # Hide update UI during installation - but don't reference update_btn_right
            # (update buttons removed - only banner is shown)
            
            # Hide install from zip button if it exists
            # Note: This button is created dynamically, so we need to find it
            self.hide_install_zip_button()
            
            silent_print("Hidden inappropriate buttons for SP Flash Tool method")
        except Exception as e:
            silent_print(f"Error hiding buttons for SP Flash Tool: {e}")

    def show_appropriate_buttons_for_spflash(self):
        """Show buttons that are appropriate for SP Flash Tool methods"""
        try:
            # Show download button (for future use)
            if hasattr(self, 'download_btn'):
                self.download_btn.setVisible(True)
            
            # Re-check for updates and show button if newer version available
            if hasattr(self, 'update_btn_right'):
                QTimer.singleShot(500, self.check_for_updates_and_show_button)
            
            # Show install from zip button if it exists
            self.show_install_zip_button()
            
            silent_print("Shown appropriate buttons for SP Flash Tool method")
        except Exception as e:
            silent_print(f"Error showing buttons for SP Flash Tool: {e}")

    def hide_install_zip_button(self):
        """Hide the install from zip button if it exists"""
        try:
            # Find the install from zip button in the layout
            if hasattr(self, 'central_widget'):
                self.find_and_hide_button(self.central_widget, "üìÅ Browse Files")
        except Exception as e:
            silent_print(f"Error hiding install zip button: {e}")

    def show_install_zip_button(self):
        """Show the install from zip button if it exists"""
        try:
            # Find the install from zip button in the layout
            if hasattr(self, 'central_widget'):
                self.find_and_show_button(self.central_widget, "üìÅ Browse Files")
        except Exception as e:
            silent_print(f"Error showing install zip button: {e}")

    def find_and_hide_button(self, widget, button_text):
        """Recursively find and hide a button by its text"""
        try:
            if isinstance(widget, QPushButton) and widget.text() == button_text:
                widget.setVisible(False)
                return True
            
            # Search in child widgets
            for child in widget.findChildren(QPushButton):
                if child.text() == button_text:
                    child.setVisible(False)
                    return True
            return False
        except Exception as e:
            silent_print(f"Error finding and hiding button: {e}")
            return False

    def find_and_show_button(self, widget, button_text):
        """Recursively find and show a button by its text"""
        try:
            if isinstance(widget, QPushButton) and widget.text() == button_text:
                widget.setVisible(True)
                return True
            
            # Search in child widgets
            for child in widget.findChildren(QPushButton):
                if child.text() == button_text:
                    child.setVisible(True)
                    return True
            return False
        except Exception as e:
            silent_print(f"Error finding and showing button: {e}")
            return False

    def on_handshake_failed(self):
        """Handle handshake failed error from MTKWorker"""
        # Stop the MTK worker to prevent it from continuing to run
        if self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()  # Wait for the worker to finish
            self.mtk_worker = None

        # Show the "try again" screen (initsteps image) for the relevant system
        self.load_initsteps_image()

        # Cancel any existing revert timer to prevent conflicts
        if hasattr(self, '_revert_timer') and self._revert_timer:
            self._revert_timer.stop()
            self._revert_timer = None

        # Set timer to revert to startup state after 30 seconds (shorter timeout for better UX)
        self._revert_timer = QTimer()
        self._revert_timer.timeout.connect(self.revert_to_startup_state)
        self._revert_timer.setSingleShot(True)
        self._revert_timer.start(30000)

        # Show user-friendly message asking to unplug and try again
        self.status_label.setText("Please unplug your Y1 and try again")

        # Re-enable buttons for retry
        self.download_btn.setEnabled(True)  # Re-enable download button
        self.settings_btn.setEnabled(True)  # Re-enable settings button
        
        # Set up automatic restart after showing initsteps
        QTimer.singleShot(5000, self.restart_firmware_install)

    def restart_firmware_install(self):
        """Restart the firmware installation process from where the command is run"""
        try:
            # Show initsteps image for the relevant system
            self.load_initsteps_image()
            
            # Update status to indicate restart
            self.status_label.setText("Restarting firmware installation...")
            
            # Create and start a new MTK worker
            debug_window = None
            if getattr(self, 'debug_mode', False):
                debug_window = DebugOutputWindow(self)
                debug_window.show()
            
            self.mtk_worker = MTKWorker(debug_mode=getattr(self, 'debug_mode', False), debug_window=debug_window)
            self.mtk_worker.status_updated.connect(self.update_status)
            self.mtk_worker.show_installing_image.connect(self.load_installing_image)
            self.mtk_worker.show_reconnect_image.connect(self.load_handshake_error_image)
            self.mtk_worker.show_presteps_image.connect(self.load_presteps_image)
            self.mtk_worker.show_please_wait_image.connect(self.load_please_wait_image)
            self.mtk_worker.show_initsteps_image.connect(self.load_initsteps_image)
            self.mtk_worker.mtk_completed.connect(self.handle_mtk_completion)
            self.mtk_worker.handshake_failed.connect(self.handle_handshake_failure)
            self.mtk_worker.errno2_detected.connect(self.handle_errno2_error)
            self.mtk_worker.backend_error_detected.connect(self.handle_backend_error)
            self.mtk_worker.keyboard_interrupt_detected.connect(self.handle_keyboard_interrupt)
            self.mtk_worker.disable_update_button.connect(self.disable_update_button)
            self.mtk_worker.enable_update_button.connect(self.enable_update_button)
            self.mtk_worker.start()
            
        except Exception as e:
            silent_print(f"Error restarting firmware install: {e}")
            self.status_label.setText("Error restarting installation - please try manually")

    def on_errno2_detected(self):
        """Handle errno2 error from MTKWorker"""
        # Stop the MTK worker to prevent it from continuing to run
        if self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()  # Wait for the worker to finish
            self.mtk_worker = None

        reply = self.show_custom_message_box(
            "question",
            "Errno2 Error - Reinstall Required",
            "An errno2 error was detected, which indicates the Innioasis Updater application needs to be reinstalled.\n\n"
            "Please reinstall the Innioasis Updater application to resolve this issue.\n\n"
            "Click OK to open the download page in your browser.",
            QMessageBox.Ok | QMessageBox.Cancel,
            QMessageBox.Ok
        )

        if reply == QMessageBox.Ok:
            # Open the GitHub releases page in the default browser
            import webbrowser
            releases_url = "https://github.com/y1-community/Innioasis-Updater/releases/latest"
            webbrowser.open(releases_url)
            self.status_label.setText("GitHub releases page opened - please reinstall Innioasis Updater")
        else:
            self.status_label.setText("Errno2 error - please reinstall Innioasis Updater")

        self.download_btn.setEnabled(True)  # Re-enable download button
        self.settings_btn.setEnabled(True)  # Re-enable settings button

    def on_usb_io_error_detected(self):
        """Handle USB IO error from MTKWorker (USBError(5) - ROM incompatible with Method 1)"""
        # Only show dialog once per session
        if hasattr(self, '_rom_incompatible_dialog_shown') and self._rom_incompatible_dialog_shown:
            return
        
        # Mark dialog as shown
        self._rom_incompatible_dialog_shown = True
        
        # Stop the MTK worker to prevent it from continuing to run
        if self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()  # Wait for the worker to finish
            self.mtk_worker = None

        # Show process_ended.png and dialog
        self.load_process_ended_image()
        
        # Use a timer to show the comprehensive dialog after a short delay so user sees the process_ended image
        QTimer.singleShot(2000, self.show_install_error_dialog)

    def ensure_mtk_process_terminated(self):
        """Ensure MTK process is properly terminated before starting new installation"""
        try:
            # Stop any running MTK worker
            if hasattr(self, 'mtk_worker') and self.mtk_worker:
                self.mtk_worker.stop()
                self.mtk_worker.wait()
                self.mtk_worker = None
                silent_print("MTK worker terminated")
            
            # Additional cleanup for any remaining processes
            if platform.system() == "Windows":
                # Kill any remaining mtk.py processes on Windows
                try:
                    subprocess.run(['taskkill', '/f', '/im', 'python.exe', '/fi', 'WINDOWTITLE eq mtk.py*'], 
                                  capture_output=True, timeout=5)
                except:
                    pass
        except Exception as e:
            silent_print(f"Error terminating MTK process: {e}")


    def on_backend_error_detected(self):
        """Handle backend error from MTKWorker"""
        # Stop the MTK worker to prevent it from continuing to run
        if self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()  # Wait for the worker to finish
            self.mtk_worker = None

        reply = QMessageBox.question(
            self,
            "Backend Error - libusb Backend Issue",
            "A libusb backend error was detected, which indicates a system-level USB backend issue.\n\n"
            "This is typically caused by:\n"
            "‚Ä¢ Missing or incompatible libusb backend\n"
            "‚Ä¢ System USB driver conflicts\n"
            "‚Ä¢ Incompatible macOS version\n\n"
            "To resolve this issue:\n"
            "1. Install or update libusb: brew install libusb\n"
            "2. If using Homebrew, try: brew reinstall libusb\n"
            "3. Restart your system\n"
            "4. Try the firmware installation again\n\n"
            "Click OK to open Homebrew installation instructions in your browser.",
            QMessageBox.Ok | QMessageBox.Cancel,
            QMessageBox.Ok
        )

        if reply == QMessageBox.Ok:
            # Open the Homebrew installation page in the default browser
            import webbrowser
            homebrew_url = "https://brew.sh/"
            webbrowser.open(homebrew_url)
            self.status_label.setText("Homebrew page opened - please install libusb and restart")
        else:
            self.status_label.setText("Backend error - please install libusb and restart")

        self.download_btn.setEnabled(True)  # Re-enable download button
        self.settings_btn.setEnabled(True)  # Re-enable settings button

    def on_keyboard_interrupt_detected(self):
        """Handle keyboard interrupt from MTKWorker"""
        # Stop the MTK worker to prevent it from continuing to run
        if self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()  # Wait for the worker to finish
            self.mtk_worker = None

        # Check if this was a Method 2 or 3 installation - if so, don't show troubleshooting
        current_method = getattr(self, 'installation_method', 'guided')
        if current_method in ["mtkclient", "spflash"]:
            # Method 2 or 3 failure - just show process_ended.png and return to ready state
            self.load_process_ended_image()
            self.status_label.setText("Method installation failed - returning to ready state")
            # Return to ready state after showing the image briefly
            QTimer.singleShot(3000, self.revert_to_startup_state)
            return

        # Method 1 failure - show process_ended.png briefly, then show troubleshooting dialog
        self.load_process_ended_image()
        
        # Use a timer to show the dialog after a short delay so user sees the process_ended image
        QTimer.singleShot(2000, self.show_install_error_dialog)
        return  # Don't continue with the revert timer since user will choose action

    def show_presteps_image(self):
        """Show the presteps image"""
        self.load_presteps_image()

    def set_image_with_aspect_ratio(self, pixmap):
        """Set image while maintaining aspect ratio"""
        if pixmap.isNull():
            return

        # Get the label size
        label_size = self.image_label.size()
        if label_size.width() <= 0 or label_size.height() <= 0:
            # Use minimum size if label not properly sized yet
            label_size = QSize(400, 300)

        # Scale image to fit the label while maintaining aspect ratio
        scaled_pixmap = pixmap.scaled(
            label_size,
            Qt.KeepAspectRatio,
            Qt.SmoothTransformation
        )

        # Set the scaled pixmap
        self.image_label.setPixmap(scaled_pixmap)

        # Don't use setScaledContents to maintain aspect ratio
        self.image_label.setScaledContents(False)

        # Store current pixmap for resize events
        self._current_pixmap = pixmap

    def resizeEvent(self, event):
        """Handle window resize to maintain image aspect ratio"""
        super().resizeEvent(event)
        # Re-scale current image if one is loaded
        if hasattr(self, '_current_pixmap') and self._current_pixmap:
            self.set_image_with_aspect_ratio(self._current_pixmap)

    def download_image_from_web(self, image_path):
        """Download an image from the website as a fallback - DISABLED"""
        # Feature disabled to prevent startup delays from dead URLs
        return False

    def load_image_with_web_fallback(self, image_path):
        """Load an image - web fallback disabled"""
        try:
            local_path = Path(image_path)
            
            # Only try to load from local file
            if local_path.exists():
                pixmap = QPixmap(image_path)
                if not pixmap.isNull():
                    return pixmap
            
            return None
            
        except Exception as e:
            silent_print(f"Error loading image: {e}")
            return None

    def ensure_image_exists(self, image_path):
        """Check if image exists locally - web downloading disabled"""
        try:
            local_path = Path(image_path)
            
            # If file exists and is valid, return True
            if local_path.exists():
                # Test if it's a valid image
                test_pixmap = QPixmap(image_path)
                if not test_pixmap.isNull():
                    return True
            
            # Web downloading disabled - just return False if not found locally
            return False
            
        except Exception as e:
            silent_print(f"Error checking image exists: {e}")
            return False

    def preload_critical_images(self):
        """Preload critical images to ensure they're available when needed"""
        try:
            # List of critical images that should be available
            critical_images = [
                "mtkclient/gui/images/presteps.png",
                "mtkclient/gui/images/initsteps.png",
                "mtkclient/gui/images/installing.png",
                "mtkclient/gui/images/installed.png",
                "mtkclient/gui/images/process_ended.png",
                "mtkclient/gui/images/method2.png",
                "mtkclient/gui/images/method3.png",
                "mtkclient/gui/images/handshake_err.png"
            ]
            
            # Add platform-specific variants
            system = platform.system()
            if system == "Windows":
                critical_images.extend([
                    "mtkclient/gui/images/presteps_win.png",
                    "mtkclient/gui/images/initsteps_win.png",
                    "mtkclient/gui/images/method2_win.png",
                    "mtkclient/gui/images/method3_win.png",
                    "mtkclient/gui/images/handshake_err_win.png",
                    "mtkclient/gui/images/arm64windows.png",
                    "mtkclient/gui/images/driverswindows.png"
                ])
            elif system == "Darwin":
                critical_images.extend([
                    "mtkclient/gui/images/presteps_mac.png",
                    "mtkclient/gui/images/initsteps_mac.png",
                    "mtkclient/gui/images/method2_mac.png",
                    "mtkclient/gui/images/method3_mac.png",
                    "mtkclient/gui/images/handshake_err_mac.png"
                ])
            elif system == "Linux":
                critical_images.extend([
                    "mtkclient/gui/images/presteps_linux.png",
                    "mtkclient/gui/images/initsteps_linux.png",
                    "mtkclient/gui/images/method2_linux.png",
                    "mtkclient/gui/images/method3_linux.png",
                    "mtkclient/gui/images/handshake_err_linux.png"
                ])
            
            # Ensure each critical image exists
            for image_path in critical_images:
                self.ensure_image_exists(image_path)
                
            silent_print("Critical images preloaded successfully")
            
        except Exception as e:
            silent_print(f"Error preloading critical images: {e}")

    def get_platform_image_path(self, base_name):
        """Constructs a path to a platform-specific image, with a fallback to a generic one."""
        system = platform.system()
        if system == "Windows":
            # Check driver status and architecture for Windows
            driver_info = self.check_drivers_and_architecture()
            
            if driver_info['is_arm64']:
                # ARM64 Windows: Use arm64windows.png for presteps
                if base_name == "presteps":
                    arm64_path = Path("mtkclient/gui/images/arm64windows.png")
                    if arm64_path.exists():
                        return str(arm64_path)
                suffix = "_win"
            elif not driver_info['has_mtk_driver'] and not driver_info['has_usbdk_driver']:
                # No drivers: Use driverswindows.png for presteps
                if base_name == "presteps":
                    drivers_path = Path("mtkclient/gui/images/driverswindows.png")
                    if drivers_path.exists():
                        return str(drivers_path)
                suffix = "_win"
            else:
                # Users with at least MTK driver (including Method 3 only mode) show presteps.png as usual
                suffix = "_win"
        elif system == "Darwin":
            suffix = "_mac"
        elif system == "Linux":
            suffix = "_linux"
        else:
            suffix = ""

        base_path = Path("mtkclient/gui/images")

        # Try platform-specific path first
        if suffix:
            platform_specific_path = base_path / f"{base_name}{suffix}.png"
            if platform_specific_path.exists():
                return str(platform_specific_path)
            else:
                # Try to download from web if local file doesn't exist
                web_path = f"mtkclient/gui/images/{base_name}{suffix}.png"
                if self.download_image_from_web(web_path):
                    return str(platform_specific_path)

        # Fallback to generic path
        generic_path = base_path / f"{base_name}.png"
        if generic_path.exists():
            return str(generic_path)
        else:
            # Try to download from web if local file doesn't exist
            web_path = f"mtkclient/gui/images/{base_name}.png"
            if self.download_image_from_web(web_path):
                return str(generic_path)
        
        # If all else fails, return the generic path (will be handled by caller)
        return str(generic_path)

    def load_presteps_image(self):
        """Load presteps image with lazy loading and platform fallback."""
        if not hasattr(self, '_presteps_pixmap'):
            try:
                image_path = self.get_platform_image_path("presteps")
                self._presteps_pixmap = QPixmap(image_path)
                if self._presteps_pixmap.isNull():
                    silent_print(f"Failed to load image from {image_path}")
                    return
            except Exception as e:
                silent_print(f"Error loading presteps image: {e}")
                return

        self._current_pixmap = self._presteps_pixmap
        self.set_image_with_aspect_ratio(self._presteps_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()
        # Flash border to highlight the new image
        self.flash_image_border()
    
    def show_paperclip_message(self):
        """Show message asking user to get paperclip/pin ready during download/extraction"""
        try:
            # Switch to image view
            if hasattr(self, 'image_notes_stack') and self.image_notes_stack:
                self.image_notes_stack.setCurrentIndex(0)  # Switch to image view (page 0)
            
            # Update title to "Getting Ready:"
            if hasattr(self, 'output_group'):
                self.output_group.setTitle("Getting Ready:")
            
            # Show presteps image
            self.load_presteps_image()
            
            # Update status message only if it doesn't already contain download/extraction status
            if hasattr(self, 'status_label'):
                current_status = self.status_label.text().lower()
                if "downloading" not in current_status and "extracting" not in current_status and "please get" not in current_status:
                    self.status_label.setText("Please get a paperclip or pin ready while your firmware downloads and extracts...")
        except Exception as e:
            silent_print(f"Error showing paperclip message: {e}")
    
    def _switch_to_image_view(self):
        """Switch stacked widget to image view (page 0)"""
        if hasattr(self, 'image_notes_stack'):
            self.image_notes_stack.setCurrentIndex(0)
            # Update title back to "Getting Ready:" when showing images
            if hasattr(self, 'output_group'):
                self.output_group.setTitle("Getting Ready:")

    def load_please_wait_image(self):
        """Load please_wait image with lazy loading and platform fallback."""
        if not hasattr(self, '_please_wait_pixmap'):
            try:
                image_path = self.get_platform_image_path("please_wait")
                self._please_wait_pixmap = QPixmap(image_path)
                if self._please_wait_pixmap.isNull():
                    silent_print(f"Failed to load image from {image_path}")
                    return
            except Exception as e:
                silent_print(f"Error loading please_wait image: {e}")
                return

        self._current_pixmap = self._please_wait_pixmap
        self.set_image_with_aspect_ratio(self._please_wait_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()
        # Flash border to highlight the new image
        self.flash_image_border()

    def load_initsteps_image(self):
        """Load initsteps image with lazy loading and platform fallback."""
        if not hasattr(self, '_initsteps_pixmap'):
            try:
                image_path = self.get_platform_image_path("initsteps")
                self._initsteps_pixmap = QPixmap(image_path)
                if self._initsteps_pixmap.isNull():
                    silent_print(f"Failed to load image from {image_path}")
                    return
            except Exception as e:
                silent_print(f"Error loading initsteps image: {e}")
                return

        self._current_pixmap = self._initsteps_pixmap
        self.set_image_with_aspect_ratio(self._initsteps_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()
        # Flash border to highlight the new image
        self.flash_image_border()

    def load_installing_image(self):
        """Load installing image with lazy loading and web fallback"""
        if not hasattr(self, '_installing_pixmap'):
            try:
                image_path = "mtkclient/gui/images/installing.png"
                local_path = Path(image_path)
                
                # Try to load from local file first
                if local_path.exists():
                    self._installing_pixmap = QPixmap(image_path)
                else:
                    # Try to download from web if local file doesn't exist
                    if self.download_image_from_web(image_path):
                        self._installing_pixmap = QPixmap(image_path)
                    else:
                        silent_print("Failed to load installing.png from local and web")
                        return
                
                if self._installing_pixmap.isNull():
                    silent_print("Failed to load installing.png")
                    return
            except Exception as e:
                silent_print(f"Error loading installing image: {e}")
                return

        self._current_pixmap = self._installing_pixmap
        self.set_image_with_aspect_ratio(self._installing_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()

    def load_installed_image(self):
        """Load installed image with lazy loading and web fallback"""
        if not hasattr(self, '_installed_pixmap'):
            try:
                image_path = "mtkclient/gui/images/installed.png"
                local_path = Path(image_path)
                
                # Try to load from local file first
                if local_path.exists():
                    self._installed_pixmap = QPixmap(image_path)
                else:
                    # Try to download from web if local file doesn't exist
                    if self.download_image_from_web(image_path):
                        self._installed_pixmap = QPixmap(image_path)
                    else:
                        silent_print("Failed to load installed.png from local and web")
                        return
                
                if self._installed_pixmap.isNull():
                    silent_print("Failed to load installed.png")
                    return
            except Exception as e:
                silent_print(f"Error loading installed image: {e}")
                return

        self._current_pixmap = self._installed_pixmap
        self.set_image_with_aspect_ratio(self._installed_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()

    def load_handshake_error_image(self):
        """Load handshake error image with lazy loading and platform fallback."""
        if not hasattr(self, '_handshake_error_pixmap'):
            try:
                image_path = self.get_platform_image_path("handshake_err")
                self._handshake_error_pixmap = QPixmap(image_path)
                if self._handshake_error_pixmap.isNull():
                    silent_print(f"Failed to load image from {image_path}")
                    return
            except Exception as e:
                silent_print(f"Error loading handshake error image: {e}")
                return

        self._current_pixmap = self._handshake_error_pixmap
        self.set_image_with_aspect_ratio(self._handshake_error_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()

    def load_process_ended_image(self):
        """Load process ended image with lazy loading and web fallback"""
        if not hasattr(self, '_process_ended_pixmap'):
            try:
                image_path = "mtkclient/gui/images/process_ended.png"
                local_path = Path(image_path)
                
                # Try to load from local file first
                if local_path.exists():
                    self._process_ended_pixmap = QPixmap(image_path)
                else:
                    # Try to download from web if local file doesn't exist
                    if self.download_image_from_web(image_path):
                        self._process_ended_pixmap = QPixmap(image_path)
                    else:
                        silent_print("Failed to load process_ended.png from local and web")
                        return
                
                if self._process_ended_pixmap.isNull():
                    silent_print("Failed to load process_ended.png")
                    return
            except Exception as e:
                silent_print(f"Error loading process ended image: {e}")
                return

        self._current_pixmap = self._process_ended_pixmap
        self.set_image_with_aspect_ratio(self._process_ended_pixmap)
        # Switch to image view (page 0) when showing installation images
        self._switch_to_image_view()

    def load_method2_image(self):
        """Load method2 image with lazy loading and platform fallback."""
        if not hasattr(self, '_method2_pixmap'):
            try:
                image_path = self.get_platform_image_path("method2")
                self._method2_pixmap = QPixmap(image_path)
                if self._method2_pixmap.isNull():
                    silent_print(f"Failed to load image from {image_path}")
                    return
            except Exception as e:
                silent_print(f"Error loading method2 image: {e}")
                return

        self._current_pixmap = self._method2_pixmap
        self.set_image_with_aspect_ratio(self._method2_pixmap)

    def load_method3_image(self):
        """Load method3 image with lazy loading and platform fallback."""
        if not hasattr(self, '_method3_pixmap'):
            try:
                image_path = self.get_platform_image_path("method3")
                self._method3_pixmap = QPixmap(image_path)
                if self._method3_pixmap.isNull():
                    silent_print(f"Failed to load image from {image_path}")
                    return
            except Exception as e:
                silent_print(f"Error loading method3 image: {e}")
                return

        self._current_pixmap = self._method3_pixmap
        self.set_image_with_aspect_ratio(self._method3_pixmap)

    def open_coffee_link(self):
        """Open the Buy Us Coffee link in the default browser"""
        import webbrowser
        webbrowser.open("https://ko-fi.com/teamslide")

    def open_reddit_link(self):
        """Open the r/innioasis subreddit in the default browser"""
        import webbrowser
        webbrowser.open("https://reddit.com/r/innioasis")

    def load_about_content(self):
        """Load about content from local file only - remote loading DISABLED to prevent hang"""
        # Remote loading disabled to prevent settings dialog hang from dead URL
        
        # Try local file first
        try:
            local_about_file = Path("about")
            if local_about_file.exists():
                content = local_about_file.read_text(encoding='utf-8').strip()
                logging.info("Loaded about content from local file")
                return content
        except Exception as e:
            logging.warning(f"Failed to load about content from local file: {e}")
        
        # Final fallback to hardcoded content
        logging.info("Using fallback about content")
        return """
        <div style="text-align: center; font-size: 9px; line-height: 1.4;">
        <p><strong>Thanks to:</strong></p>
        <p><strong>Team Slide:</strong><br/>
        Melody (u/wa-a-melyn) and Leonardo (u/allstar)</p>
        <p>Bklerler for developing MTKClient<br/>
        <a href="https://github.com/bkerler" style="color: #007AFF; text-decoration: none;">@bkerler</a> ‚Ä¢ 
        <a href="https://github.com/bkerler/mtkclient" style="color: #007AFF; text-decoration: none;">MTKClient</a></p>
        <p><a href="https://cursor.com" style="color: #007AFF; text-decoration: none;">Cursor.com</a></p>
        <p><a href="https://github.com/NoahDomingues" style="color: #007AFF; text-decoration: none;">NoahDomingues</a> for 
        <a href="https://github.com/NoahDomingues/Android-IMG-Editor" style="color: #007AFF; text-decoration: none;">Android-IMG-Editor</a></p>
        <p>Innioasis for adopting Updater as the official firmware installer</p>
        </div>
        """

    def setup_credits_scrolling(self, scroll_area, credits_label, credits_text):
        """Set up iPod-style horizontal auto-scrolling for credits"""
        # Calculate the actual rendered width of the HTML content
        doc = QTextDocument()
        doc.setHtml(credits_text)
        doc.setTextWidth(1000)  # Set a large width to get full content width
        content_width = doc.idealWidth()
        
        # Get the available width in the scroll area
        available_width = scroll_area.width() - 20  # Account for margins
        
        # Only set up scrolling if content is wider than available space
        if content_width <= available_width:
            return  # No scrolling needed
        
        # Animation properties
        self.credits_scroll_position = 0
        self.credits_scroll_speed = 1
        self.credits_pause_duration = 2000  # 2 seconds pause at each end
        self.credits_pause_timer = 0
        self.credits_scrolling_right = True
        self.credits_scroll_area = scroll_area
        self.credits_max_scroll = content_width - available_width
        
        # Start the animation timer
        self.credits_timer = QTimer()
        self.credits_timer.timeout.connect(self._animate_credits_scroll)
        self.credits_timer.start(50)  # Update every 50ms

    def _animate_credits_scroll(self):
        """Animate the credits horizontal scrolling"""
        if not hasattr(self, 'credits_scroll_area'):
            return
            
        # Handle pausing at ends
        if self.credits_pause_timer > 0:
            self.credits_pause_timer -= 50
            return
        
        # Update scroll position
        if self.credits_scrolling_right:
            self.credits_scroll_position += self.credits_scroll_speed
            if self.credits_scroll_position >= self.credits_max_scroll:
                self.credits_scroll_position = self.credits_max_scroll
                self.credits_scrolling_right = False
                self.credits_pause_timer = self.credits_pause_duration
        else:
            self.credits_scroll_position -= self.credits_scroll_speed
            if self.credits_scroll_position <= 0:
                self.credits_scroll_position = 0
                self.credits_scrolling_right = True
                self.credits_pause_timer = self.credits_pause_duration
        
        # Update the scroll bar position
        self.credits_scroll_area.horizontalScrollBar().setValue(int(self.credits_scroll_position))

    def setup_credits_line_display(self, credits_label, credits_label_container):
        """Set up line-by-line display with fade transitions"""
        # Start with version line (from firmware_downloader.py, not remote)
        clean_lines = [f"Version {APP_VERSION}"]
        
        # Load credits content from remote or local file
        credits_text = self.load_about_content()
        
        # Parse HTML content into individual lines preserving order
        import re
        # Remove div tags but keep content
        clean_text = re.sub(r'</?div[^>]*>', '', credits_text)
        
        # Split by paragraph tags to get individual paragraphs
        paragraphs = re.split(r'</?p>', clean_text)
        
        # Process each paragraph
        for paragraph in paragraphs:
            paragraph = paragraph.strip()
            if paragraph:
                # Remove extra whitespace but preserve single spaces
                paragraph = re.sub(r'\s+', ' ', paragraph).strip()
                # Remove HTML line breaks and ensure single line
                paragraph = re.sub(r'<br\s*/?>', ' ', paragraph)
                paragraph = re.sub(r'</?p>', '', paragraph)
                # Check if it's not just HTML tags
                if paragraph and not re.match(r'^<[^>]*>$', paragraph):
                    clean_lines.append(paragraph)
        
        # Store lines for animation
        self.credits_lines = clean_lines
        self.current_line_index = 0
        self.credits_label = credits_label
        
        # Debug: log the parsed lines
        logging.info(f"Parsed credits lines: {self.credits_lines}")
        self.credits_container = credits_label_container
        
        # Set up fade animations
        self.fade_out_animation = QPropertyAnimation(credits_label, b"windowOpacity")
        self.fade_out_animation.setDuration(500)
        self.fade_out_animation.setStartValue(1.0)
        self.fade_out_animation.setEndValue(0.0)
        self.fade_out_animation.setEasingCurve(QEasingCurve.OutQuad)
        
        self.fade_in_animation = QPropertyAnimation(credits_label, b"windowOpacity")
        self.fade_in_animation.setDuration(500)
        self.fade_in_animation.setStartValue(0.0)
        self.fade_in_animation.setEndValue(1.0)
        self.fade_in_animation.setEasingCurve(QEasingCurve.InQuad)
        
        # Connect animations
        self.fade_out_animation.finished.connect(self.show_next_line)
        self.fade_in_animation.finished.connect(self.start_line_timer)
        
        # Start the display
        if self.credits_lines:
            self.show_current_line()
            self.start_line_timer()

    def show_current_line(self):
        """Display the current line with horizontal scrolling if needed"""
        if not hasattr(self, 'credits_lines') or not self.credits_lines:
            return
            
        current_line = self.credits_lines[self.current_line_index]
        self.credits_label.setText(current_line)
        
        # Check if line needs horizontal scrolling
        doc = QTextDocument()
        doc.setHtml(current_line)
        doc.setTextWidth(1000)
        content_width = doc.idealWidth()
        available_width = self.credits_container.width() - 20
        
        if content_width > available_width:
            # Set up horizontal scrolling for this line
            self.setup_line_scrolling(current_line, content_width, available_width)
        else:
            # Stop any existing scrolling
            if hasattr(self, 'line_scroll_timer'):
                self.line_scroll_timer.stop()

    def setup_line_scrolling(self, line_text, content_width, available_width):
        """Set up horizontal scrolling for a single line"""
        # Animation properties for this line
        self.line_scroll_position = 0
        self.line_scroll_speed = 1
        self.line_pause_duration = 1500  # 1.5 seconds pause at each end
        self.line_pause_timer = 0
        self.line_scrolling_right = True
        self.line_max_scroll = content_width - available_width
        
        # Start the line scrolling timer
        if hasattr(self, 'line_scroll_timer'):
            self.line_scroll_timer.stop()
        
        self.line_scroll_timer = QTimer()
        self.line_scroll_timer.timeout.connect(self._animate_line_scroll)
        self.line_scroll_timer.start(50)  # Update every 50ms

    def _animate_line_scroll(self):
        """Animate horizontal scrolling for the current line"""
        if not hasattr(self, 'line_scroll_timer'):
            return
            
        # Handle pausing at ends
        if self.line_pause_timer > 0:
            self.line_pause_timer -= 50
            return
        
        # Update scroll position
        if self.line_scrolling_right:
            self.line_scroll_position += self.line_scroll_speed
            if self.line_scroll_position >= self.line_max_scroll:
                self.line_scroll_position = self.line_max_scroll
                self.line_scrolling_right = False
                self.line_pause_timer = self.line_pause_duration
        else:
            self.line_scroll_position -= self.line_scroll_speed
            if self.line_scroll_position <= 0:
                self.line_scroll_position = 0
                self.line_scrolling_right = True
                self.line_pause_timer = self.line_pause_duration
        
            # Update the label position to create scrolling effect
            if hasattr(self, 'credits_label'):
                current_x = 5 - int(self.line_scroll_position)
                self.credits_label.setGeometry(current_x, 5, self.credits_container.width() - 10, 40)

    def show_next_line(self):
        """Show the next line after fade out"""
        if not hasattr(self, 'credits_lines') or not self.credits_lines:
            return
            
        # Move to next line
        self.current_line_index = (self.current_line_index + 1) % len(self.credits_lines)
        self.show_current_line()
        
        # Fade in the new line
        self.fade_in_animation.start()

    def start_line_timer(self):
        """Start timer to show next line after delay"""
        if not hasattr(self, 'credits_lines') or not self.credits_lines:
            return
            
        # Show each line for 3 seconds
        self.line_display_timer = QTimer()
        self.line_display_timer.timeout.connect(self.fade_out_animation.start)
        self.line_display_timer.setSingleShot(True)
        self.line_display_timer.start(3000)

    def is_online(self):
        """Check if we have an active internet connection (non-blocking check)"""
        try:
            import socket
            # Try to connect to a reliable DNS server (Google's public DNS)
            # Use a short timeout to avoid blocking
            socket.setdefaulttimeout(1)
            socket.create_connection(("8.8.8.8", 53), timeout=1)
            return True
        except (socket.error, OSError):
            # Also try GitHub (actual service we use)
            try:
                socket.create_connection(("github.com", 443), timeout=1)
                return True
            except (socket.error, OSError):
                return False
        finally:
            # Reset timeout
            socket.setdefaulttimeout(None)

    def detect_dark_mode(self):
        """Detect if the system is in dark mode"""
        try:
            if platform.system() == "Darwin":  # macOS
                import subprocess
                result = subprocess.run(['defaults', 'read', '-g', 'AppleInterfaceStyle'], 
                                      capture_output=True, text=True, timeout=5)
                is_dark = result.stdout.strip() == 'Dark'
                return is_dark
            elif platform.system() == "Windows":
                import winreg
                with winreg.OpenKey(winreg.HKEY_CURRENT_USER, 
                                  r"Software\Microsoft\Windows\CurrentVersion\Themes\Personalize") as key:
                    value, _ = winreg.QueryValueEx(key, "AppsUseLightTheme")
                    is_dark = value == 0
                    return is_dark
            else:  # Linux
                # Try to detect dark mode from environment variables
                import os
                is_dark = os.environ.get('GTK_THEME', '').endswith(':dark') or \
                         os.environ.get('COLORFGBG', '').endswith(';0')
                return is_dark
        except Exception as e:
            # Fallback to light mode if detection fails
            return False

    def get_theme_colors(self):
        """Get appropriate colors based on system theme"""
        if self.is_dark_mode:
            colors = {
                'button_bg': '#2d2d2d',
                'button_text': '#cccccc',
                'button_border': '#555555',
                'button_hover_bg': '#3d3d3d',
                'button_hover_border': '#666666',
                'button_pressed_bg': '#1d1d1d',
                'button_pressed_border': '#444444',
                'text_bg': '#2b2b2b',
                'text_color': '#cccccc',
                'text_border': '#555555',
                'tab_bg': '#2d2d2d',
                'tab_text': '#cccccc',
                'tab_border': '#555555',
                'tab_selected_bg': '#2b2b2b',
                'tab_hover_bg': '#3d3d3d'
            }
            return colors
        else:
            colors = {
                'button_bg': '#f0f0f0',
                'button_text': '#000000',
                'button_border': '#c0c0c0',
                'button_hover_bg': '#e0e0e0',
                'button_hover_border': '#a0a0a0',
                'button_pressed_bg': '#d0d0d0',
                'button_pressed_border': '#808080',
                'text_bg': '#ffffff',
                'text_color': '#000000',
                'text_border': '#c0c0c0',
                'tab_bg': '#f0f0f0',
                'tab_text': '#000000',
                'tab_border': '#c0c0c0',
                'tab_selected_bg': '#ffffff',
                'tab_hover_bg': '#e0e0e0'
            }
            return colors

    # Theme change detection methods removed - native widgets handle this automatically

    def closeEvent(self, event):
        """Handle application close event"""
        # Stop update check timer
        if hasattr(self, '_update_check_timer') and self._update_check_timer:
            try:
                self._update_check_timer.stop()
                self._update_check_timer = None
            except:
                pass
        
        # Stop other timers to prevent crashes
        timers_to_stop = [
            '_priming_timer', '_release_update_timer', '_all_releases_timer',
            'credits_timer', 'line_scroll_timer', 'line_display_timer',
            'adb_check_timer', 'adb_blink_timer', '_revert_timer'
        ]
        for timer_name in timers_to_stop:
            if hasattr(self, timer_name):
                timer = getattr(self, timer_name)
                if timer and hasattr(timer, 'stop'):
                    try:
                        timer.stop()
                    except:
                        pass
        
        # Mark that GUI is closing to prevent worker threads from accessing it
        self._gui_closing = True
        
        # Stop any running workers
        if hasattr(self, 'download_worker') and self.download_worker:
            self.download_worker.stop()
            self.download_worker.wait()
        
        if hasattr(self, 'mtk_worker') and self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()
        
        # Stop release worker
        if hasattr(self, 'release_worker') and self.release_worker:
            try:
                if self.release_worker.isRunning():
                    # Disconnect signals first
                    try:
                        self.release_worker.release_loaded.disconnect()
                        self.release_worker.loading_complete.disconnect()
                        self.release_worker.loading_failed.disconnect()
                    except:
                        pass
                    self.release_worker.stop()
                    if not self.release_worker.wait(5000):  # Wait up to 5 seconds
                        # Thread didn't finish - terminate it
                        self.release_worker.terminate()
                        self.release_worker.wait(2000)
                # Use deleteLater for proper cleanup
                self.release_worker.deleteLater()
            except:
                pass
            self.release_worker = None
        
        # Stop data loader worker
        if hasattr(self, 'data_loader_worker') and self.data_loader_worker:
            try:
                if self.data_loader_worker.isRunning():
                    # Disconnect signals first
                    try:
                        self.data_loader_worker.data_loaded.disconnect()
                        self.data_loader_worker.loading_failed.disconnect()
                    except:
                        pass
                    self.data_loader_worker.stop()
                    if not self.data_loader_worker.wait(2000):  # Wait up to 2 seconds
                        # Thread didn't finish - terminate it
                        self.data_loader_worker.terminate()
                        self.data_loader_worker.wait(1000)
                # Use deleteLater for proper cleanup
                self.data_loader_worker.deleteLater()
            except:
                pass
            self.data_loader_worker = None
        
        # Stop token loader worker
        if hasattr(self, 'token_loader_worker') and self.token_loader_worker:
            try:
                if self.token_loader_worker.isRunning():
                    # Disconnect signals first
                    try:
                        self.token_loader_worker.tokens_loaded.disconnect()
                        self.token_loader_worker.loading_failed.disconnect()
                    except:
                        pass
                    self.token_loader_worker.stop()
                    if not self.token_loader_worker.wait(2000):  # Wait up to 2 seconds
                        # Thread didn't finish - terminate it
                        self.token_loader_worker.terminate()
                        self.token_loader_worker.wait(1000)
                # Use deleteLater for proper cleanup
                self.token_loader_worker.deleteLater()
            except:
                pass
            self.token_loader_worker = None
        
        # Stop all releases worker
        if hasattr(self, 'all_releases_worker') and self.all_releases_worker:
            try:
                if self.all_releases_worker.isRunning():
                    # Disconnect signals first
                    try:
                        self.all_releases_worker.releases_loaded.disconnect()
                        self.all_releases_worker.loading_complete.disconnect()
                        self.all_releases_worker.loading_failed.disconnect()
                    except:
                        pass
                    self.all_releases_worker.stop()
                    if not self.all_releases_worker.wait(5000):  # Wait up to 5 seconds
                        # Thread didn't finish - terminate it
                        self.all_releases_worker.terminate()
                        self.all_releases_worker.wait(2000)
                # Use deleteLater for proper cleanup
                self.all_releases_worker.deleteLater()
            except:
                pass
            self.all_releases_worker = None
        
        # Clean up old workers
        if hasattr(self, '_old_workers'):
            for old_worker in self._old_workers:
                try:
                    if old_worker.isRunning():
                        old_worker.stop()
                        if not old_worker.wait(2000):
                            old_worker.terminate()
                            old_worker.wait(1000)
                    old_worker.deleteLater()
                except:
                    pass
            self._old_workers = []
        
        # Stop theme monitoring
        if hasattr(self, 'theme_monitor') and self.theme_monitor:
            self.theme_monitor.stop_monitoring()
        
        # Stop ADB check timer
        if hasattr(self, 'adb_check_timer') and self.adb_check_timer:
            self.adb_check_timer.stop()
        
        # Stop ADB blink timer
        if hasattr(self, 'adb_blink_timer') and self.adb_blink_timer:
            self.adb_blink_timer.stop()
        
        # Stop ADB update script worker
        if hasattr(self, 'adb_update_script_worker') and self.adb_update_script_worker:
            try:
                if self.adb_update_script_worker.isRunning():
                    # Disconnect signals first
                    try:
                        self.adb_update_script_worker.status_update.disconnect()
                        self.adb_update_script_worker.download_progress.disconnect()
                        self.adb_update_script_worker.completed.disconnect()
                    except:
                        pass
                    self.adb_update_script_worker.stop()
                    if not self.adb_update_script_worker.wait(2000):  # Wait up to 2 seconds
                        # Thread didn't finish - terminate it
                        self.adb_update_script_worker.terminate()
                        self.adb_update_script_worker.wait(1000)
                # Use deleteLater for proper cleanup
                self.adb_update_script_worker.deleteLater()
            except:
                pass
            self.adb_update_script_worker = None
        
        event.accept()

    def open_discord_link(self):
        """Help with common issues"""
        import webbrowser
        webbrowser.open("https://innioasis.app/Troubleshooting")

    def open_about_tab(self):
        """Open Settings dialog to About tab"""
# 2025-11-09 22:10:00 UTC - original: About button used a lambda inside init_ui; this helper keeps parity while enabling dynamic label changes.
        self.show_settings_dialog("about")

    def open_driver_setup_link(self):
        """Show driver setup dialog and open the installation guide"""
        driver_info = self.check_drivers_and_architecture()
        
        # Determine which drivers are missing
        missing_drivers = []
        if not driver_info['has_mtk_driver']:
            missing_drivers.append("MediaTek SP Flash Tool Driver")
        if not driver_info['has_usbdk_driver']:
            missing_drivers.append("UsbDk Driver")
        
        if missing_drivers:
            # Show dialog asking user to install specific drivers
            driver_names = " and ".join(missing_drivers)
            msg_box = QMessageBox(self)
            msg_box.setWindowTitle("Driver Setup Required")
            msg_box.setIcon(QMessageBox.Information)
            msg_box.setText(f"To use all features of Innioasis Updater, you'll need to install:")
            msg_box.setInformativeText(f"‚Ä¢ {driver_names}\n\nWould you like help setting these up?")
            msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
            msg_box.setDefaultButton(QMessageBox.Yes)
            
            if msg_box.exec() == QMessageBox.Yes:
                # Open the installation guide
                import webbrowser
                webbrowser.open("https://innioasis.app/installguide.html")
        else:
            # Fallback to direct link
            import webbrowser
            webbrowser.open("https://innioasis.app/installguide.html")


    def open_arm64_info(self, event):
        """ARM64 info helper retained for compatibility (no UI shown)."""
        silent_print("ARM64 info requested; installation UI remains Fast Update only.")

    def browse_files(self):
        """Browse and select files or folders to process via Smart Drop with a single, simple dialog."""
        from PySide6.QtWidgets import QFileDialog, QAbstractItemView, QListView, QTreeView
        
        dialog = QFileDialog(
            self,
            "Smart Drop: Select themes, songs, files, folders, rom/update files, updates, apps, etc"
        )
        dialog.setFileMode(QFileDialog.FileMode.ExistingFiles)
        dialog.setOption(QFileDialog.Option.DontUseNativeDialog, True)
        dialog.setOption(QFileDialog.Option.ReadOnly, False)
        dialog.setLabelText(QFileDialog.DialogLabel.Accept, "Send to Y1")
        dialog.setLabelText(QFileDialog.DialogLabel.Reject, "Cancel")
        dialog.setNameFilter("All Files (*)")
        
        # Ensure multi-selection is enabled in both list and tree views
        for view in dialog.findChildren(QListView):
            view.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        for view in dialog.findChildren(QTreeView):
            view.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        
        if not dialog.exec():
            return
        
        selected_paths = dialog.selectedFiles()
        if not selected_paths:
            return
        
        silent_print(f"Browse Files: Processing {len(selected_paths)} item(s) via Smart Drop")
        self.handle_smart_drop_payload(selected_paths)
    
    def _check_storage_space(self, required_gb=6):
        """Check if there's enough free storage space
        
        Args:
            required_gb: Minimum required free space in GB (default: 6GB)
            
        Returns:
            tuple: (has_enough_space: bool, available_gb: float, error_message: str or None)
        """
        try:
            # Get current working directory to check its disk
            current_path = Path.cwd()
            
            # Get disk usage for the current directory's drive/partition
            usage = shutil.disk_usage(current_path)
            
            # Calculate available space in GB
            available_bytes = usage.free
            available_gb = available_bytes / (1024 ** 3)  # Convert to GB
            
            # Check if enough space is available
            has_enough_space = available_gb >= required_gb
            
            if not has_enough_space:
                error_message = (
                    f"Insufficient storage space.\n\n"
                    f"Required: {required_gb} GB\n"
                    f"Available: {available_gb:.2f} GB\n\n"
                    f"Please free up at least {required_gb - available_gb:.2f} GB of space "
                    f"before proceeding with firmware installation."
                )
            else:
                error_message = None
            
            return has_enough_space, available_gb, error_message
            
        except Exception as e:
            silent_print(f"Error checking storage space: {e}")
            # If we can't check, allow the operation to proceed (fail gracefully)
            return True, 0.0, None
    
    def install_from_zip(self, zip_path=None):
        """Install firmware from a local zip file
        
        Args:
            zip_path: Optional path to zip file. If None, opens file dialog.
        """
        from PySide6.QtWidgets import QFileDialog, QMessageBox
        
        # Check driver availability for Windows users
        if platform.system() == "Windows":
            driver_info = self.check_drivers_and_architecture()
            
            if driver_info['is_arm64']:
                silent_print("ARM64 Windows attempted Install from zip; operation skipped.")
                self.status_label.setText("Install / Restore is unavailable on Windows ARM64.")
                return
                
            elif not driver_info['can_install_firmware'] and not driver_info.get('has_mtk_driver') and not driver_info.get('has_usbdk_driver'):
                # Show warning but don't block - allow fallback methods
                result = QMessageBox.information(
                    self,
                    "No Specific Drivers Detected",
                    "No specific drivers detected. The application will attempt installation using fallback methods.\n\n"
                    "If installation fails, consider installing drivers for better compatibility.\n\n"
                    "Click OK to continue with fallback methods or Cancel to install drivers.",
                    QMessageBox.Ok | QMessageBox.Cancel,
                    QMessageBox.Ok
                )
                if result == QMessageBox.Cancel:
                    self.open_driver_setup_link()
                    return
                # Continue with fallback methods if OK is clicked
        
        # If zip_path not provided, open file dialog to select zip file
        if zip_path is None:
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Select Firmware ZIP File",
                "",
                "ZIP Files (*.zip)"
            )
            
            if not file_path:
                return
            
            zip_path = Path(file_path)
        else:
            zip_path = Path(zip_path)
        
        if not zip_path.exists():
            QMessageBox.warning(self, "Error", "Selected file does not exist.")
            return
        
        # Check if the file is named "update.zip" (case-insensitive)
        if zip_path.name.lower() == "update.zip":
            # This is a Fast Update - skip storage check (Fast Updates don't require 6GB)
            # Show warning that this is a quick update file
            reply = QMessageBox.warning(
                self,
                "Quick Update File Detected",
                "‚ö†Ô∏è The file you selected is named 'update.zip', which is a quick update file.\n\n"
                "This file must be copied to your Y1 player in USB Storage mode.\n\n"
                "The application will now treat this as a Fast Update operation:\n"
                "1. You'll be prompted to prepare your Y1\n"
                "2. You'll be asked to select your Y1 drive or .rockbox folder\n"
                "3. The update.zip will be copied to the correct location\n"
                "4. You can then use the Firmware Update option on your Y1\n\n"
                "Click OK to proceed with Fast Update, or Cancel to select a different file.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                return
            
            # Show the same preparation dialog as Fast Update button
            silent_print("Showing Fast Update preparation dialog")
            reply = QMessageBox.question(
                self,
                "Fast Update - USB Mode",
                "üì± Please prepare your Y1:\n\n"
                "1. Power on your Y1\n"
                "2. Connect it to your computer via USB\n"
                "3. Make sure your Y1 is in USB Storage mode\n"
                "   (Your computer should see it as a USB drive)\n\n"
                "Click OK when your Y1 is connected and ready.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                silent_print("User cancelled at preparation dialog")
                return
            
            # Handle as Fast Update - copy to Y1
            # Ask user to select Y1 drive or .rockbox folder
            folder_path = QFileDialog.getExistingDirectory(
                self,
                "Select Y1 USB Drive or .rockbox Folder",
                "",
                QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
            )
            
            if not folder_path:
                return
            
            # Copy update.zip to the selected folder
            try:
                destination = Path(folder_path) / "update.zip"
                
                self.status_label.setText("Copying update.zip to Y1...")
                self.progress_bar.setVisible(True)
                self.progress_bar.setValue(50)
                
                shutil.copy2(zip_path, destination)
                
                self.progress_bar.setValue(100)
                self.status_label.setText("update.zip copied successfully!")
                
                # Try to run the update script via ADB after USB transfer
                script_success = self.run_update_script_via_adb()
                
                if script_success:
                    QMessageBox.information(
                        self,
                        "Update Complete",
                        "‚úÖ update.zip has been copied to your Y1.\n\n"
                        "‚úÖ Update script executed successfully via ADB.\n\n"
                        "Your Y1 will restart and apply the update automatically."
                    )
                else:
                    QMessageBox.information(
                        self,
                        "Update Copied Successfully",
                        "‚úÖ update.zip has been copied to your Y1.\n\n"
                        "Next steps:\n"
                        "1. Safely disconnect your Y1 from your computer\n"
                        "2. On your Y1, go to Main Menu > System\n"
                        "3. Select Firmware Update\n"
                        "4. The update will install automatically"
                    )
                
                self.progress_bar.setVisible(False)
                return
            except Exception as e:
                self.progress_bar.setVisible(False)
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to copy update.zip:\n{str(e)}"
                )
                self.status_label.setText("Error copying update.zip")
            return
            
        # Check storage space before processing rom.zip (full firmware install requires 6GB)
        has_enough_space, available_gb, error_message = self._check_storage_space(required_gb=6)
        if not has_enough_space:
            QMessageBox.warning(
                self,
                "Insufficient Storage Space",
                error_message
            )
            self.status_label.setText(f"Insufficient storage space ({available_gb:.2f} GB available, 6 GB required)")
            return
            
        # Process the zip file with progress bar and status updates like download process
        self.status_label.setText("Processing zip file...")
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)
        
        try:
            # Simulate progress for zip processing
            self.progress_bar.setValue(25)
            self.status_label.setText("Extracting zip file...")
            
            # Extract the zip file
            extracted_files = []
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                extracted_files = safe_extractall(zip_ref, ".", zip_path.name)
            
            # Log extracted files for cleanup
            log_extracted_files(extracted_files)
            
            self.progress_bar.setValue(75)
            self.status_label.setText("Checking required files...")
            
            # Check if required files exist
            required_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
            missing_files = []
            for file in required_files:
                if not Path(file).exists():
                    missing_files.append(file)
            
            if missing_files:
                self.progress_bar.setVisible(False)
                error_msg = f"Missing required files: {', '.join(missing_files)}\n\n"
                error_msg += "The zip file must contain:\n"
                error_msg += "- lk.bin\n"
                error_msg += "- boot.img\n"
                error_msg += "- recovery.img\n"
                error_msg += "- system.img\n"
                error_msg += "- userdata.img\n\n"
                error_msg += "Please ensure your zip file contains all required firmware files."
                
                QMessageBox.warning(self, "Missing Files", error_msg)
                self.status_label.setText("Zip file missing required firmware files.")
                return
            
            self.progress_bar.setValue(100)
            self.status_label.setText("Extraction completed. Files ready for installation.")
            
            # Handle installation based on selected method
            self.status_label.setText("Starting installation in 3 seconds...")
            QTimer.singleShot(3000, self.handle_installation_method)
            
        except Exception as e:
            self.progress_bar.setVisible(False)
            error_msg = f"Error processing zip file: {str(e)}"
            QMessageBox.critical(self, "Error", error_msg)
            self.status_label.setText("Error processing zip file.")
            silent_print(f"Zip processing error: {e}")
        
        finally:
            # Hide progress bar after processing
            QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
    
    def send_update_to_y1(self):
        """Download and send update.zip to Y1 device using ADB or USB"""
        silent_print("Fast Update button clicked")
        
        if not hasattr(self, 'current_update_zip_url') or not self.current_update_zip_url:
            silent_print("ERROR: No update.zip URL available")
            QMessageBox.warning(self, "Error", "No update.zip URL available for this release")
            return
        
        silent_print(f"Update.zip URL: {self.current_update_zip_url}")
        
        # Check if USB storage mode is detected - if so, repeatedly prompt user to turn it off
        # Fast Update cannot proceed with USB Storage Mode active because update.sh cannot access update.zip
        # on the Y1 itself when USB Storage Mode is active (PC can access it, but Y1 cannot)
        while True:
            usb_drive = self._detect_usb_storage_drive()
            if not usb_drive:
                # USB Storage Mode is off - proceed
                silent_print("USB Storage Mode is off - proceeding with Fast Update")
                break
            
            # USB Storage Mode detected - prompt user to turn it off
            reply = QMessageBox.question(
                self,
                "USB Storage Mode Detected",
                "Fast Update requires ADB access and cannot proceed while USB Storage Mode is active.\n\n"
                "Please turn off USB Storage mode, then click OK.\n\n"
                f"Detected Y1 drive: {usb_drive}",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                silent_print("User cancelled Fast Update - USB Storage Mode active")
                return
            
            # Check again after user clicked OK - if still active, prompt again
            # This creates a loop that continues until USB Storage Mode is actually turned off
            QApplication.processEvents()
            time.sleep(0.5)  # Brief pause to allow detection to update
        
        # Try ADB method first
        if self.try_adb_fast_update():
            return
        
        # Fall back - ADB not available
        silent_print("ADB not available for Fast Update - informing user of alternatives")
        QMessageBox.warning(
            self,
            "Fast Update Requires ADB",
            "Fast Update requires an ADB connection, but ADB is not available.\n\n"
            "To install your Y1's software update, you have two options:\n\n"
            "1. Select a Fast Install enabled firmware from the available software list "
            "and do a clean install by selecting \"Install / Restore\"\n\n"
            "2. Use a full-sized rom.zip file to continue installing your Y1's software update\n\n"
            "Fast Update (update.zip) requires ADB to push files and run scripts automatically."
        )
        self.status_label.setText("Fast Update requires ADB connection")
    
    def try_adb_fast_update(self):
        """Try to perform fast update using ADB - uses worker thread to prevent GUI hangs"""
        try:
            if not self._ensure_adb_idle("a Fast Update"):
                return False
            
            # Find ADB executable
            adb_path = self.find_adb_executable()
            if not adb_path:
                silent_print("ADB not found - falling back to USB mode")
                return False
            
            # Prepare environment with proper PATH for macOS
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Start worker thread to check ADB availability (prevents GUI hang)
            self.adb_fast_update_check_worker = ADBFastUpdateCheckWorker(adb_path, env, self.current_update_zip_url)
            self.adb_fast_update_check_worker.check_complete.connect(self._on_adb_fast_update_check_complete)
            self.adb_fast_update_check_worker.start()
            
            # Show status while checking
            self.status_label.setText("Checking ADB connection...")
            return True
            
        except Exception as e:
            silent_print(f"Error starting ADB fast update check: {e}")
            return False
            
    def _on_adb_fast_update_check_complete(self, success, selected_device, env, usb_storage_available):
        """Handle completion of ADB fast update availability check"""
        try:
            if not success:
                silent_print("ADB fast update check failed - falling back to USB mode")
                self._fallback_to_usb_mode()
                return
            
            # Check for USB Storage Mode - Fast Update cannot proceed if it's active
            # because update.sh cannot access update.zip on the Y1 itself when USB Storage Mode is active
            while True:
                usb_drive = self._detect_usb_storage_drive()
                if not usb_drive:
                    # USB Storage Mode is off - proceed
                    silent_print("USB Storage Mode is off - proceeding with Fast Update")
                    break
                
                # USB Storage Mode detected - prompt user to turn it off
                reply = QMessageBox.question(
                    self,
                    "USB Storage Mode Detected",
                    "Fast Update requires ADB access and cannot proceed while USB Storage Mode is active.\n\n"
                    "Please turn off USB Storage mode, then click OK.\n\n"
                    f"Detected Y1 drive: {usb_drive}",
                    QMessageBox.Ok | QMessageBox.Cancel,
                    QMessageBox.Ok
                )
                
                if reply == QMessageBox.Cancel:
                    silent_print("User cancelled ADB update - USB Storage Mode active")
                    self._fallback_to_usb_mode()
                    return
                
                # Check again after user clicked OK - if still active, prompt again
                QApplication.processEvents()
                time.sleep(0.5)  # Brief pause to allow detection to update
            
            # Show ADB mode dialog
            reply = QMessageBox.question(
                self,
                "Fast Update - ADB Mode",
                "‚ö° Automatic Update Available!\n\n"
                "Your Y1 supports automatic updates via ADB.\n\n"
                "The update will:\n"
                "1. Download update.zip\n"
                "2. Push it to /sdcard/.rockbox/update.zip\n"
                "3. Run the update script automatically\n"
                "4. Your Y1 will restart when done\n\n"
                "Make sure your Y1 is connected and click OK to proceed.",
                QMessageBox.Ok | QMessageBox.Cancel,
                QMessageBox.Ok
            )
            
            if reply == QMessageBox.Cancel:
                silent_print("User cancelled ADB update - falling back to USB mode")
                self._fallback_to_usb_mode()
                return
            
            # Start ADB update process in worker thread
            adb_path = self.find_adb_executable()
            self.adb_operation_in_progress = True
            self.fast_update_worker = FastUpdateWorker(adb_path, self.current_update_zip_url, env, selected_device)
            self.fast_update_worker.status_update.connect(self.update_status)
            self.fast_update_worker.progress_update.connect(self.update_progress)
            self.fast_update_worker.completed.connect(self.on_update_send_completed)
            
            # Show progress
            self.status_label.setText("Starting Fast Update via ADB...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setValue(0)
            
            # Disable buttons during operation
            self.download_btn.setEnabled(False)
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(False)
            
            silent_print(f"Starting FastUpdateWorker thread with device: {selected_device}")
            self.fast_update_worker.start()
            
        except Exception as e:
            silent_print(f"Error handling ADB fast update check result: {e}")
            self._fallback_to_usb_mode()
    
    def _ensure_connection_for_operation(self, operation_name="this operation"):
        """Ensure ADB connection or USB drive is available, prompting user to connect if needed
        
        Args:
            operation_name: Description of the operation (e.g., "install themes", "transfer files")
            
        Returns:
            tuple: (has_connection: bool, connection_type: str or None, usb_drive: str or None)
                - has_connection: True if ADB or USB drive is available
                - connection_type: "usb_storage", "adb", or None
                - usb_drive: USB drive path if available, None otherwise
        """
        # First check for existing connections
        usb_drive = self._detect_usb_storage_drive()
        if usb_drive:
            return True, "usb_storage", usb_drive
        
        # Check for ADB connection
        snapshot = self.get_cached_adb_status()
        adb_status = snapshot.get('status', 'no_adb')
        has_adb = adb_status != 'no_adb'
        if has_adb:
            return True, "adb", None
        
        # No connection available - prompt user to connect via USB storage mode
        reply = QMessageBox.question(
            self,
            "Connection Required",
            f"To {operation_name}, your Y1 needs to be connected.\n\n"
            "Please:\n"
            "1. Turn on your Y1\n"
            "2. Connect it to your computer via USB\n"
            "3. Enable USB Storage Mode on your Y1\n"
            "   (Your computer should see it as a USB drive)\n\n"
            "Click OK when your Y1 is connected and ready, or Cancel to abort.",
            QMessageBox.Ok | QMessageBox.Cancel,
            QMessageBox.Ok
        )
        
        if reply == QMessageBox.Cancel:
            return False, None, None
        
        # Wait for USB or ADB detection (poll up to 30 seconds)
        self.status_label.setText("Waiting for Y1 USB drive...")
        QApplication.processEvents()
        
        max_attempts = 60  # 30 seconds (0.5 second intervals)
        start_time = time.monotonic()
        for attempt in range(max_attempts):
            usb_drive = self._detect_usb_storage_drive()
            if usb_drive:
                # Prefer ADB if it appears within the first ~4 seconds after dialog confirmation
                elapsed = time.monotonic() - start_time
                if elapsed <= 4.0:
                    adb_path = self.find_adb_executable()
                    if adb_path:
                        env = self._build_adb_environment()
                        status, device_id, _, _ = self.get_unified_adb_status(
                            adb_path, env, blocking=True, force_refresh=True
                        )
                        if status != 'no_adb':
                            self.status_label.setText("ADB connection detected")
                            return True, "adb", None
                self.status_label.setText(f"Y1 USB drive detected: {usb_drive}")
                return True, "usb_storage", usb_drive
            
            # Check for ADB connection as well (in case user connected via ADB instead)
            # Force refresh ADB status to detect new connections
            adb_path = self.find_adb_executable()
            if adb_path:
                env = self._build_adb_environment()
                status, device_id, _, _ = self.get_unified_adb_status(adb_path, env, blocking=True, force_refresh=True)
                if status != 'no_adb':
                    self.status_label.setText("ADB connection detected")
                    return True, "adb", None
            
            # Wait a bit before checking again (non-blocking)
            time.sleep(0.5)
            QApplication.processEvents()
        
        # Timeout - no connection detected
        QMessageBox.warning(
            self,
            "Connection Not Detected",
            "Y1 USB drive was not detected after waiting.\n\n"
            "Please ensure:\n"
            "‚Ä¢ Your Y1 is powered on\n"
            "‚Ä¢ USB Storage Mode is enabled\n"
            "‚Ä¢ The USB cable is properly connected\n\n"
            "You can try again once your Y1 is connected."
        )
        self.status_label.setText("Connection not detected")
        return False, None, None
    
    def _detect_usb_storage_drive(self):
        """Detect USB storage drive by looking for Y1-specific folders with confidence scoring"""
        # First check saved path
        if self.saved_usb_drive_path:
            saved_path = Path(self.saved_usb_drive_path)
            if saved_path.exists():
                confidence = self._score_y1_drive_confidence(saved_path)
                if confidence >= 2:  # At least 2 folders present
                    silent_print(f"Using saved USB storage drive: {self.saved_usb_drive_path} (confidence: {confidence}/5)")
                    return str(self.saved_usb_drive_path)
        
        # Then try auto-detection with confidence scoring
        best_match = None
        best_confidence = 0
        
        try:
            try:
                import psutil
                # Get all mounted filesystems
                partitions = psutil.disk_partitions()
                for partition in partitions:
                    try:
                        mountpoint = Path(partition.mountpoint)
                        if not mountpoint.exists() or not mountpoint.is_dir():
                            continue
                        
                        confidence = self._score_y1_drive_confidence(mountpoint)
                        if confidence > best_confidence:
                            best_confidence = confidence
                            best_match = mountpoint
                    except (PermissionError, OSError):
                        continue
            except ImportError:
                pass  # psutil not available, fall through to fallback method
            
            # Fallback: check common mount points
            common_paths = []
            if platform.system() == "Darwin":
                common_paths = ["/Volumes"]
            elif platform.system() == "Windows":
                import string
                common_paths = [f"{d}:\\" for d in string.ascii_uppercase]
            elif platform.system() == "Linux":
                common_paths = ["/media", "/mnt"]
            
            for base_path in common_paths:
                base = Path(base_path)
                if not base.exists():
                    continue
                try:
                    for item in base.iterdir():
                        if not item.is_dir():
                            continue
                        confidence = self._score_y1_drive_confidence(item)
                        if confidence > best_confidence:
                            best_confidence = confidence
                            best_match = item
                except (PermissionError, OSError):
                    continue
            
            if best_match and best_confidence >= 2:  # Require at least 2 folders for confidence
                silent_print(f"Found USB storage drive: {best_match} (confidence: {best_confidence}/5)")
                # Auto-save detected path
                self.save_usb_drive_path(str(best_match))
                return str(best_match)
        
        except Exception as e:
            silent_print(f"Error detecting USB storage drive: {e}")
        
        return None
    
    def _score_y1_drive_confidence(self, drive_path):
        """Score confidence that a drive is a Y1 device based on folder presence (0-5)"""
        try:
            drive = Path(drive_path)
            if not drive.exists() or not drive.is_dir():
                return 0
            
            # Check for Y1-specific folders
            folders_to_check = {
                "Android": drive / "Android",
                "Music": drive / "Music",
                "Pictures": drive / "Pictures",
                ".rockbox": drive / ".rockbox",
                "Themes": drive / "Themes"
            }
            
            confidence = 0
            for folder_name, folder_path in folders_to_check.items():
                if folder_path.exists() and folder_path.is_dir():
                    confidence += 1
                    silent_print(f"Found Y1 folder '{folder_name}' on drive: {drive_path}")
            
            return confidence
        except Exception as e:
            silent_print(f"Error scoring drive confidence: {e}")
            return 0
    
    def _perform_usb_storage_fast_update(self, usb_drive_path):
        """Perform fast update using USB storage mode (silently)"""
        try:
            usb_path = Path(usb_drive_path)
            rockbox_path = usb_path / ".rockbox"
            
            # Ensure .rockbox folder exists
            if not rockbox_path.exists():
                rockbox_path.mkdir(parents=True, exist_ok=True)
            
            # Start worker to download and place update.zip
            self.update_worker = UpdateZipSenderWorker(self.current_update_zip_url, str(rockbox_path))
            self.update_worker.status_updated.connect(self.update_status)
            self.update_worker.progress_updated.connect(self.update_progress)
            self.update_worker.send_completed.connect(self.on_update_send_completed)
            
            # Show progress
            self.status_label.setText("Downloading update.zip...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setValue(0)
            
            # Disable buttons during operation
            self.download_btn.setEnabled(False)
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(False)
            
            silent_print("Starting UpdateZipSenderWorker thread for USB storage mode...")
            self.update_worker.start()
        except Exception as e:
            silent_print(f"Error performing USB storage fast update: {e}")
            self._fallback_to_usb_mode()
    
    def _fallback_to_usb_mode(self):
        """Fall back to USB storage mode for update - but inform user about alternatives"""
        silent_print("ADB not available for Fast Update - informing user of alternatives")
        QMessageBox.warning(
            self,
            "Fast Update Requires ADB",
            "Fast Update requires an ADB connection, but ADB is not available.\n\n"
            "To install your Y1's software update, you have two options:\n\n"
            "1. Select a Fast Install enabled firmware from the available software list "
            "and do a clean install by selecting \"Install / Restore\"\n\n"
            "2. Use a full-sized rom.zip file to continue installing your Y1's software update\n\n"
            "Fast Update (update.zip) requires ADB to push files and run scripts automatically."
        )
        self.status_label.setText("Fast Update requires ADB connection")
    
    def is_device_fast_update_enabled(self):
        """Check if device is fast update enabled (rooted ADB device connected by any means - USB, Wi-Fi, or both)"""
        try:
            # Find ADB executable
            adb_path = self.find_adb_executable()
            if not adb_path:
                return False
            
            # Prepare environment with proper PATH for macOS
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Check if device is connected via ADB (any connection type - USB, Wi-Fi, or both)
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Parse device list and prefer USB device (0123456789ABCDEF) when both are available
            target_device_id = "0123456789ABCDEF"
            devices = []
            usb_device = None
            wireless_device = None
            
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    devices.append(device_id)
                    # Prefer USB device when both are available
                    if device_id == target_device_id:
                        usb_device = device_id
                    elif ':' in device_id and wireless_device is None:
                        wireless_device = device_id
            
            if not devices:
                return False
            
            # Select device: prefer USB when both are available, otherwise use any available device
            selected_device = usb_device if usb_device else (wireless_device if wireless_device else devices[0])
            
            # Check if device is rooted (using selected device)
            root_check_result = subprocess.run(
                [str(adb_path), '-s', selected_device, 'shell', 'su', '-c', 'id'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            device_is_rooted = (root_check_result.returncode == 0 and 'uid=0' in root_check_result.stdout)
            
            # Fast Update is enabled if device is rooted (script can be installed automatically)
            return device_is_rooted
            
        except Exception as e:
            silent_print(f"Error checking fast update enabled status: {e}")
            return False
    
    def find_adb_executable(self):
        """Find ADB executable in assets or system PATH - prioritizes ./assets/adb.exe on Windows"""
        # Check assets folder first (use absolute path based on script location)
        current_dir = Path.cwd()
        if platform.system() == "Windows":
            assets_adb = current_dir / "assets" / "adb.exe"
        else:
            assets_adb = current_dir / "assets" / "adb"
        
        silent_print(f"Checking for ADB at: {assets_adb}")
        if assets_adb.exists() and assets_adb.is_file():
            silent_print(f"Found ADB in assets: {assets_adb}")
            return assets_adb
        
        # Check system PATH only if not found in assets
        import shutil
        system_adb = shutil.which("adb")
        if system_adb:
            silent_print(f"Found ADB in system PATH: {system_adb}")
            return Path(system_adb)
        
        # On macOS, check common Homebrew locations if not in PATH
        # This is important because GUI apps launched from Finder may not have full PATH
        if platform.system() == "Darwin":
            homebrew_paths = [
                Path("/opt/homebrew/bin/adb"),  # Apple Silicon Macs
                Path("/usr/local/bin/adb"),     # Intel Macs
                Path.home() / "homebrew" / "bin" / "adb",  # Alternative Homebrew location
            ]
            for brew_adb in homebrew_paths:
                if brew_adb.exists() and brew_adb.is_file():
                    silent_print(f"Found ADB at Homebrew location: {brew_adb}")
                    return brew_adb
        
        silent_print("ADB not found in assets or system PATH")
        return None
    
    def detect_and_resolve_device_hostname(self, adb_path, device_id, env):
        """Detect hostname from device over USB and resolve to IP address locally"""
        try:
            import socket
            
            # Get hostname from device
            hostname = self.get_device_hostname(adb_path, device_id, env)
            if not hostname:
                silent_print("Could not detect device hostname")
                return None
            
            silent_print(f"Detected device hostname: {hostname}")
            
            # Try to resolve hostname to IP address locally
            try:
                ip_address = socket.gethostbyname(hostname)
                silent_print(f"Resolved hostname {hostname} to IP: {ip_address}")
                return ip_address
            except socket.gaierror:
                # Hostname resolution failed - this is normal if device is not on local network
                silent_print(f"Could not resolve hostname {hostname} to IP address (device may not be on local network)")
                return None
            except Exception as e:
                silent_print(f"Error resolving hostname: {e}")
                return None
        except Exception as e:
            silent_print(f"Error detecting/resolving device hostname: {e}")
            return None
    
    def get_device_hostname(self, adb_path, device_id, env):
        """Get IP-resolvable hostname of connected ADB device - does NOT modify device hostname"""
        try:
            import socket
            
            # First, get the device's configured hostname (previous method)
            hostname_cmd = [str(adb_path)]
            if device_id:
                hostname_cmd.extend(['-s', device_id])
            hostname_cmd.extend(['shell', 'getprop', 'net.hostname'])
            
            result = subprocess.run(
                hostname_cmd,
                capture_output=True,
                text=True,
                timeout=3,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if result.returncode == 0:
                hostname = result.stdout.strip()
                if hostname and hostname.strip():
                    hostname = hostname.strip()
                    # Try to resolve the hostname to an IP address using OS-specific methods
                    # This works with mDNS/Bonjour on macOS, Avahi on Linux, and standard DNS on Windows
                    try:
                        ip_address = socket.gethostbyname(hostname)
                        silent_print(f"Successfully resolved hostname '{hostname}' to IP: {ip_address}")
                        return hostname
                    except socket.gaierror:
                        # Hostname cannot be resolved - try to get Android default format as fallback
                        silent_print(f"Hostname '{hostname}' cannot be resolved to IP, trying Android default format...")
            
            # Fallback: Try to get Android default hostname format (android-XXXXX) from MAC address
            # This format is automatically registered with mDNS/Bonjour and works reliably
            for interface in ['wlan0', 'eth0']:
                mac_cmd = [str(adb_path)]
                if device_id:
                    mac_cmd.extend(['-s', device_id])
                mac_cmd.extend(['shell', 'cat', f'/sys/class/net/{interface}/address'])
                
                result = subprocess.run(
                    mac_cmd,
                    capture_output=True,
                    text=True,
                    timeout=3,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                
                if result.returncode == 0:
                    mac_address = result.stdout.strip().lower()
                    if mac_address and len(mac_address) == 17:  # Valid MAC format (XX:XX:XX:XX:XX:XX)
                        # Generate Android default hostname format: android-<first 8 chars of MAC without colons>
                        mac_clean = mac_address.replace(':', '')
                        android_hostname = f"android-{mac_clean[:8]}"
                        # Try to resolve this hostname too
                        try:
                            ip_address = socket.gethostbyname(android_hostname)
                            silent_print(f"Successfully resolved Android default hostname '{android_hostname}' to IP: {ip_address}")
                            return android_hostname
                        except socket.gaierror:
                            silent_print(f"Android default hostname '{android_hostname}' cannot be resolved yet (may need time for mDNS registration)")
                            # Still return it as it should work once mDNS is registered
                            return android_hostname
            
            # Final fallback: return device ID or connection type
            if device_id and ':' in device_id:
                # Wireless connection - check if it's already in android-XXXXX format
                host_part = device_id.split(':')[0]
                if host_part.startswith('android-'):
                    return host_part
                # Otherwise return IP address
                return host_part
            elif device_id:
                # USB connection - return device ID
                return device_id
            
            return None
        except Exception as e:
            silent_print(f"Error getting device hostname: {e}")
            return None
    
    def load_wireless_adb_ip(self):
        """Load saved wireless ADB IP address from config file"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
                if config.has_option('WirelessADB', 'ip_address'):
                    return config.get('WirelessADB', 'ip_address')
        except Exception as e:
            silent_print(f"Error loading wireless ADB IP: {e}")
        return None
    
    def save_wireless_adb_ip(self, ip_address):
        """Save wireless ADB IP address to config file"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
            if not config.has_section('WirelessADB'):
                config.add_section('WirelessADB')
            config.set('WirelessADB', 'ip_address', ip_address)
            with open(config_file, 'w') as f:
                config.write(f)
            silent_print(f"Saved wireless ADB IP: {ip_address}")
        except Exception as e:
            silent_print(f"Error saving wireless ADB IP: {e}")
    
    def save_wireless_adb_hostname(self, hostname):
        """Save wireless ADB hostname to config file (for future IP resolution)"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
            if not config.has_section('WirelessADB'):
                config.add_section('WirelessADB')
            config.set('WirelessADB', 'hostname', hostname)
            with open(config_file, 'w') as f:
                config.write(f)
            silent_print(f"Saved wireless ADB hostname: {hostname}")
        except Exception as e:
            silent_print(f"Error saving wireless ADB hostname: {e}")
    
    def load_wireless_adb_hostname(self):
        """Load saved wireless ADB hostname from config file"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
                if config.has_option('WirelessADB', 'hostname'):
                    return config.get('WirelessADB', 'hostname')
        except Exception as e:
            silent_print(f"Error loading wireless ADB hostname: {e}")
        return None
    
    def load_dual_connection_dialog_shown(self):
        """Load flag indicating if dual connection dialog has been shown once"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
                if config.has_option('WirelessADB', 'dual_connection_dialog_shown'):
                    return config.getboolean('WirelessADB', 'dual_connection_dialog_shown')
        except Exception as e:
            silent_print(f"Error loading dual connection dialog flag: {e}")
        return False
    
    def save_dual_connection_dialog_shown(self, shown=True):
        """Save flag indicating dual connection dialog has been shown once"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
            if not config.has_section('WirelessADB'):
                config.add_section('WirelessADB')
            config.set('WirelessADB', 'dual_connection_dialog_shown', str(shown))
            with open(config_file, 'w') as f:
                config.write(f)
            silent_print(f"Saved dual connection dialog flag: {shown}")
        except Exception as e:
            silent_print(f"Error saving dual connection dialog flag: {e}")
    
    def forget_wireless_adb_device(self):
        """Clear saved wireless ADB hostname and IP address from config file"""
        try:
            config = configparser.ConfigParser()
            config_file = Path("wireless_adb.ini")
            if config_file.exists():
                config.read(config_file)
                if config.has_section('WirelessADB'):
                    # Remove hostname and IP address options
                    if config.has_option('WirelessADB', 'hostname'):
                        config.remove_option('WirelessADB', 'hostname')
                    if config.has_option('WirelessADB', 'ip_address'):
                        config.remove_option('WirelessADB', 'ip_address')
                    
                    # If section is now empty, remove it
                    if not config.options('WirelessADB'):
                        config.remove_section('WirelessADB')
                    
                    # Write back to file
                    with open(config_file, 'w') as f:
                        config.write(f)
                    silent_print("Cleared saved wireless ADB hostname and IP address")
        except Exception as e:
            silent_print(f"Error forgetting wireless ADB device: {e}")
    
    def _auto_detect_and_connect_wireless(self, adb_path, env, dialog=None):
        """Auto-detect hostname/IP from USB ADB and connect wirelessly"""
        try:
            import platform
            
            # Check if USB device is connected
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            target_device_id = "0123456789ABCDEF"
            usb_device_id = None
            
            # Find USB-connected device
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    # USB devices don't have ':' in their ID (wireless devices have IP:port)
                    if ':' not in device_id and device_id == target_device_id:
                        usb_device_id = device_id
                        break
            
            if not usb_device_id:
                QMessageBox.warning(
                    self,
                    "USB Device Not Found",
                    "No USB ADB device is connected.\n\n"
                    "Please connect your Y1 via USB and ensure USB debugging is enabled."
                )
                return
            
            # Detect hostname and resolve to IP
            ip_address = self.detect_and_resolve_device_hostname(adb_path, usb_device_id, env)
            
            if not ip_address:
                QMessageBox.warning(
                    self,
                    "Auto-Detection Failed",
                    "Could not automatically detect the device's IP address.\n\n"
                    "This may mean:\n"
                    "‚Ä¢ ADB Wi-Fi Reborn is not installed or configured on your device\n"
                    "‚Ä¢ The device is not connected to the same Wi-Fi network\n"
                    "‚Ä¢ The device's hostname cannot be resolved on your local network\n\n"
                    "Please manually enter the device's IP address or hostname."
                )
                return
            
            # Update the input field with detected IP
            if hasattr(self, 'wireless_ip_input'):
                self.wireless_ip_input.setText(ip_address)
            
            # Connect using detected IP
            self.connect_wireless_adb(ip_address, dialog)
            
        except Exception as e:
            silent_print(f"Error in auto-detect: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(
                self,
                "Auto-Detection Error",
                f"Error during auto-detection: {str(e)}\n\n"
                "Please manually enter the device's IP address or hostname."
            )
    
    def connect_wireless_adb(self, ip_address, dialog=None):
        """Connect to device via wireless ADB"""
        # Find ADB executable
        adb_path = self.find_adb_executable()
        if not adb_path:
            QMessageBox.warning(self, "ADB Not Found", "ADB executable not found. Please ensure ADB is installed.")
            return
        
        import os
        import platform
        env = os.environ.copy()
        if platform.system() == "Darwin":
            homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
            current_path = env.get("PATH", "")
            for brew_path in homebrew_paths:
                if brew_path not in current_path:
                    env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
        
        # Require IP address or hostname
        if not ip_address or not ip_address.strip():
            # Try to use saved hostname if available
            saved_hostname = self.load_wireless_adb_hostname()
            if saved_hostname:
                silent_print(f"Using saved hostname for connection: {saved_hostname}")
                # Try to resolve hostname to IP
                try:
                    import socket
                    ip_address = socket.gethostbyname(saved_hostname)
                    silent_print(f"Resolved saved hostname {saved_hostname} to IP: {ip_address}")
                except socket.gaierror:
                    # If resolution fails, try using hostname directly
                    ip_address = saved_hostname
                    silent_print(f"Could not resolve hostname, using hostname directly: {saved_hostname}")
            else:
                QMessageBox.warning(
                    self,
                    "No Address Provided",
                    "Please enter an IP address or hostname, or click Connect to auto-detect from USB ADB."
                )
                return
        
        ip_address = ip_address.strip()
        connection_target = ip_address
        
        # Try to connect using the target (IP or hostname)
        try:
            # Add port if not present
            if ':' not in connection_target:
                connection_target = f"{connection_target}:5555"
            
            connect_result = subprocess.run(
                [str(adb_path), 'connect', connection_target],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if connect_result.returncode == 0 and 'connected' in connect_result.stdout.lower():
                # Connection successful - immediately update status for better performance
                if dialog:
                    dialog.accept()
                
                # Immediately check for dual connection (USB + Wi-Fi) and warn user
                result = subprocess.run(
                    [str(adb_path), 'devices'],
                    capture_output=True,
                    text=True,
                    timeout=5,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                
                target_device_id = "0123456789ABCDEF"
                usb_connected = False
                y1_wifi_devices = []
                
                for line in result.stdout.split('\n'):
                    if '\tdevice' in line:
                        device_id = line.split('\t')[0]
                        if device_id == target_device_id:
                            usb_connected = True
                        elif ':' in device_id and self._is_y1_device_id(adb_path, device_id, env):
                            y1_wifi_devices.append(device_id)
                        elif ':' in device_id:
                            silent_print(f"Ignoring non-Y1 wireless device: {device_id}")

                if not y1_wifi_devices:
                    # Give the device a moment to finish connecting before assuming failure
                    import time as _time
                    for _ in range(3):
                        _time.sleep(0.35)
                        QApplication.processEvents()
                        retry_result = subprocess.run(
                            [str(adb_path), 'devices'],
                            capture_output=True,
                            text=True,
                            timeout=5,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                        retry_devices = []
                        y1_wifi_devices = []
                        usb_connected = False
                        for line in retry_result.stdout.split('\n'):
                            if '\tdevice' not in line:
                                continue
                            device_id = line.split('\t')[0]
                            retry_devices.append(device_id)
                            if device_id == target_device_id:
                                usb_connected = True
                            elif ':' in device_id and self._is_y1_device_id(adb_path, device_id, env):
                                y1_wifi_devices.append(device_id)
                        if y1_wifi_devices:
                            break
                
                if not y1_wifi_devices:
                    # Disconnect to avoid leaving foreign devices connected
                    disconnect_host = connection_target.split(':')[0]
                    try:
                        subprocess.run(
                            [str(adb_path), 'disconnect', disconnect_host],
                            capture_output=True,
                            text=True,
                            timeout=5,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                    except Exception as e:
                        silent_print(f"Error disconnecting non-Y1 wireless target {disconnect_host}: {e}")
                    QMessageBox.warning(
                        self,
                        "Wireless Device Not Detected",
                        "Could not confirm an Innioasis Y1 at this address. "
                        "Make sure your Y1 is powered on with Wireless ADB enabled, then try again."
                    )
                    return

                wifi_connected = len(y1_wifi_devices) > 0
                
                # Silently prefer USB when both USB and Wi-Fi are connected (no dialog needed)
                if usb_connected and wifi_connected:
                    # Set preference to prefer USB when dual connection is active
                    self.prefer_usb_for_transfers = True
                    # Show dialog only once (first time user sees dual connection)
                    if not self._dual_connection_dialog_shown:
                        self._dual_connection_dialog_shown = True
                        self.save_dual_connection_dialog_shown(True)
                        QMessageBox.warning(
                            self,
                            "Dual Connection Detected",
                            "Your Y1 is connected via both USB and Wi-Fi ADB.\n\n"
                            "The app will automatically use USB for ADB tasks when both connections are available (USB is more reliable).\n\n"
                            "You don't need the USB cable connected - you can disconnect it and use Wi-Fi only. All ADB features will work over Wi-Fi."
                        )
                
                # Persist the confirmed Y1 wireless host information
                host_part = y1_wifi_devices[0].split(':')[0]
                self.save_wireless_adb_ip(host_part)
                if any(c.isalpha() for c in host_part):
                    self.save_wireless_adb_hostname(host_part)
                if hasattr(self, 'wireless_ip_input'):
                    self.wireless_ip_input.setText(host_part)
                
                # Immediately trigger ADB status update to refresh status light
                # Use a short delay to ensure connection is fully established
                QTimer.singleShot(500, self.start_adb_check_worker)
                
                # Also check if we should show disconnect USB dialog (with delay to prevent stale indicator state on Windows)
                QTimer.singleShot(2000, lambda: self._check_and_notify_after_auto_connect(adb_path, env))
                return
            else:
                # Connection failed
                error_msg = connect_result.stderr or connect_result.stdout or "Unknown error"
                QMessageBox.warning(
                    self, 
                    "Connection Failed", 
                    f"Failed to connect to device:\n\n"
                    f"Address: {connection_target}\n"
                    f"Error: {error_msg}\n\n"
                    f"If using a hostname, ensure:\n"
                    f"‚Ä¢ ADB Wi-Fi Reborn is installed and configured\n"
                    f"‚Ä¢ The device is on the same Wi-Fi network\n"
                    f"‚Ä¢ The hostname can be resolved on your local network"
                )
                return
        except Exception as e:
            QMessageBox.warning(self, "Connection Error", f"Error connecting to device: {str(e)}")
            return
    
    
    def _try_auto_connect_wireless(self, adb_path, env):
        """Try to automatically connect wirelessly by detecting hostname/IP from USB ADB"""
        try:
            # Only try if not already connected wirelessly
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Check if already connected wirelessly
            target_device_id = "0123456789ABCDEF"
            wireless_connected = False
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    if ':' in device_id and device_id != target_device_id and self._is_y1_device_id(adb_path, device_id, env):
                        wireless_connected = True
                        break
            
            # If not connected wirelessly, try auto-detecting and connecting
            if not wireless_connected:
                # Find USB device
                usb_device_id = None
                for line in result.stdout.split('\n'):
                    if '\tdevice' in line:
                        device_id = line.split('\t')[0]
                        if ':' not in device_id and device_id == target_device_id:
                            usb_device_id = device_id
                            break
                
                if usb_device_id:
                    # Get hostname first (preferred over IP for stability)
                    device_hostname = self.get_device_hostname(adb_path, usb_device_id, env)
                    
                    # Try to connect using hostname first (more stable)
                    connection_target = None
                    if device_hostname:
                        connection_target = device_hostname
                        silent_print(f"Attempting automatic wireless connection via hostname: {device_hostname}")
                    else:
                        # Fallback to IP if hostname not available
                        ip_address = self.detect_and_resolve_device_hostname(adb_path, usb_device_id, env)
                        if ip_address:
                            connection_target = ip_address
                            silent_print(f"Attempting automatic wireless connection via detected IP: {ip_address}")
                    
                    if connection_target:
                        # Add port if not present
                        if ':' not in connection_target:
                            connection_target = f"{connection_target}:5555"
                        
                        # Background auto-connect attempts are silent - no logging unless successful
                        connect_result = subprocess.run(
                            [str(adb_path), 'connect', connection_target],
                            capture_output=True,
                            text=True,
                            timeout=10,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                        
                        # Only log successful connections - failed attempts are completely silent
                        if connect_result.returncode == 0 and 'connected' in connect_result.stdout.lower():
                            silent_print(f"Successfully auto-connected wirelessly via {device_hostname if device_hostname else 'IP'}")
                            # Update the field with hostname (preferred) or IP
                            if hasattr(self, 'wireless_ip_input'):
                                if device_hostname:
                                    # Save hostname (more stable)
                                    self.wireless_ip_input.setText(device_hostname)
                                    self.save_wireless_adb_ip(device_hostname)
                                    self.save_wireless_adb_hostname(device_hostname)
                                else:
                                    # Fallback to IP
                                    self.wireless_ip_input.setText(ip_address)
                                    self.save_wireless_adb_ip(ip_address)
                            # Immediately trigger ADB status update to refresh status light
                            QTimer.singleShot(500, self.start_adb_check_worker)
                            
                            # Immediately check for dual connection (USB + Wi-Fi) and warn user
                            result = subprocess.run(
                                [str(adb_path), 'devices'],
                                capture_output=True,
                                text=True,
                                timeout=5,
                                env=env,
                                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                            )
                            
                            target_device_id = "0123456789ABCDEF"
                            usb_connected = False
                            wifi_connected = False
                            
                            for line in result.stdout.split('\n'):
                                if '\tdevice' in line:
                                    device_id = line.split('\t')[0]
                                    if device_id == target_device_id:
                                        usb_connected = True
                                    elif ':' in device_id:
                                        wifi_connected = True
                            
                            # Silently prefer USB when both USB and Wi-Fi are connected (no dialog needed)
                            if usb_connected and wifi_connected:
                                # Set preference to prefer USB when dual connection is active
                                self.prefer_usb_for_transfers = True
                                # Show dialog only once (first time user sees dual connection)
                                if not self._dual_connection_dialog_shown:
                                    self._dual_connection_dialog_shown = True
                                    self.save_dual_connection_dialog_shown(True)
                                    QMessageBox.warning(
                                        self,
                                        "Dual Connection Detected",
                                        "Your Y1 is connected via both USB and Wi-Fi ADB.\n\n"
                                        "The app will automatically use USB for ADB tasks when both connections are available (USB is more reliable).\n\n"
                                        "You don't need the USB cable connected - you can disconnect it and use Wi-Fi only. All ADB features will work over Wi-Fi."
                                    )
                            
                            # Immediately trigger ADB status update for better performance
                            # No need to wait - connection is successful, so we can infer Wi-Fi connection
                            self.start_adb_check_worker()
                            
                            # Also check if we should show disconnect USB dialog (with delay to prevent stale indicator state on Windows)
                            QTimer.singleShot(500, lambda: self._check_and_notify_after_auto_connect(adb_path, env))
                        # Failed attempts are silently ignored - no logging or user notification
        except Exception:
            # Silently ignore all errors during background auto-connect attempts
            # Don't log or show errors to the user
            pass
    
    def _check_and_notify_after_auto_connect(self, adb_path, env):
        """Check if device is rooted and Fast Update ready after auto-connect, then notify user"""
        try:
            # Wait a bit for connection to fully establish before checking
            # This prevents the status indicator from flashing an outdated state on Windows when checks happen too quickly
            QTimer.singleShot(2000, lambda: self._verify_and_notify_fast_update_ready(adb_path, env))
        except Exception as e:
            silent_print(f"Error checking device status after auto-connect: {e}")
    
    def _verify_and_notify_fast_update_ready(self, adb_path, env):
        """Verify device is rooted and Fast Update ready, then show disconnect dialog"""
        try:
            target_device_id = "0123456789ABCDEF"
            
            # Check for wireless connection
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Find wireless device ID
            wireless_device_id = None
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    if ':' in device_id and device_id != target_device_id:
                        # Check if it's our device
                        try:
                            device_check = subprocess.run(
                                [str(adb_path), '-s', device_id, 'shell', 'getprop', 'ro.serialno'],
                                capture_output=True,
                                text=True,
                                timeout=3,
                                env=env,
                                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                            )
                            if device_check.returncode == 0 and target_device_id in device_check.stdout.strip():
                                wireless_device_id = device_id
                                break
                        except:
                            pass
            
            if not wireless_device_id:
                return  # Not connected wirelessly
            
            # Check if device is rooted
            root_check_cmd = [str(adb_path), '-s', wireless_device_id, 'shell', 'su', '-c', 'id']
            root_check_result = subprocess.run(
                root_check_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            device_is_rooted = (root_check_result.returncode == 0 and 'uid=0' in root_check_result.stdout)
            
            if not device_is_rooted:
                return  # Device not rooted, don't show dialog
            
            # Check if update script exists
            update_script_path = '/data/data/update/update.sh'
            check_cmd = [str(adb_path), '-s', wireless_device_id, 'shell', f'test -f {update_script_path} && echo exists']
            check_result = subprocess.run(
                check_cmd,
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            update_script_exists = (check_result.returncode == 0 and 
                                   'exists' in check_result.stdout.strip() and
                                   check_result.stdout.strip() == 'exists')
            
            # If device is rooted but script is missing, push it
            if device_is_rooted and not update_script_exists:
                silent_print("Device is rooted but update script is missing - pushing script...")
                self.download_and_push_update_script(adb_path)
                # Wait for script to be pushed, then check again
                QTimer.singleShot(5000, lambda: self._verify_and_notify_fast_update_ready(adb_path, env))
                return
            
            # If device is rooted and script exists, show disconnect dialog
            if device_is_rooted and update_script_exists:
                # Check if USB is still connected
                usb_connected = False
                for line in result.stdout.split('\n'):
                    if '\tdevice' in line:
                        device_id = line.split('\t')[0]
                        if device_id == target_device_id:
                            usb_connected = True
                            break
                
                # Only show dialog if USB is still connected (simple reminder to disconnect USB)
                # Also trigger ADB check to update status (with delay to prevent stale indicator state on Windows)
                if usb_connected:
                    # Check flag to prevent duplicate dialogs from subsequent background checks
                    if not hasattr(self, '_disconnect_usb_dialog_shown') or not self._disconnect_usb_dialog_shown:
                        self._disconnect_usb_dialog_shown = True
                        # 2025-11-09 12:00:00 - original: Dialog title was 'Wireless ADB Connected' without beta notice.
                        QMessageBox.information(
                            self,
                            "Wireless ADB (Beta) Connected",
                            "Your Y1 is now connected wirelessly via ADB (beta).\n\n"
                            "You don't need the USB cable connected - all ADB features will work over Wi-Fi. You can disconnect the USB cable if you like."
                        )
                
                # Trigger ADB check to update status (with delay to prevent stale indicator state on Windows)
                QTimer.singleShot(1000, self.check_adb_and_update_script)
        except Exception as e:
            silent_print(f"Error verifying Fast Update status: {e}")
    
    def install_adb_wifi_reborn(self):
        """Download and install ADB Wi-Fi Reborn APK to device"""
        try:
            # Check if device is connected via USB ADB first
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB executable not found. Please ensure ADB is installed.")
                return
            
            # Prepare environment with proper PATH for macOS
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Check if USB device is connected
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Check for USB device (not wireless)
            target_device_id = "0123456789ABCDEF"
            usb_device_found = False
            
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    # Only check for USB device (not IP address)
                    if device_id == target_device_id:
                        usb_device_found = True
                        break
            
            if not usb_device_found:
                QMessageBox.warning(
                    self,
                    "Device Not Connected",
                    "Please connect your Y1 device via USB and enable USB debugging.\n\n"
                    "The device must be connected via USB to install ADB Wi-Fi Reborn."
                )
                return
            
            # Confirm installation
            reply = QMessageBox.question(
                self,
                "Install ADB Wi-Fi Reborn",
                "This will download and install ADB Wi-Fi Reborn to your Y1 device.\n\n"
                "After installation, you'll need to:\n"
                "1. Open ADB Wi-Fi from the Rockbox Apps menu\n"
                "2. Accept the Terms of Service if prompted\n"
                "3. Enable 'Run at Boot' and grant root access in Settings\n"
                "4. Connect it to Wi-Fi inside the app, then power-cycle your Y1 once\n\n"
                "Continue with installation?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            
            if reply != QMessageBox.Yes:
                return
            
            # Show progress
            self.status_label.setText("Downloading ADB Wi-Fi Reborn...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setValue(0)
            QApplication.processEvents()
            
            # Download APK from GitHub releases
            apk_url = "https://github.com/y1-community/supplemental-apks/releases/download/1.0/adbwifi.apk"
            apk_path = Path("adb_wifi_reborn.apk")
            
            try:
                response = requests.get(apk_url, stream=True, timeout=30)
                response.raise_for_status()
                
                total_size = int(response.headers.get('content-length', 0))
                downloaded = 0
                
                with open(apk_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)
                            if total_size > 0:
                                progress = int((downloaded / total_size) * 50)  # 0-50% for download
                                self.progress_bar.setValue(progress)
                                QApplication.processEvents()
                
                self.status_label.setText("Installing ADB Wi-Fi Reborn...")
                self.progress_bar.setValue(60)
                QApplication.processEvents()
                
                # Install APK to device
                install_result = subprocess.run(
                    [str(adb_path), 'install', '-r', str(apk_path)],
                    capture_output=True,
                    text=True,
                    timeout=30,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                
                # Clean up downloaded APK
                try:
                    if apk_path.exists():
                        apk_path.unlink()
                except:
                    pass
                
                if install_result.returncode == 0:
                    # Push configuration files if available
                    config_dir = Path("adb_wifi_reborn_config")
                    config_pushed = False
                    
                    if config_dir.exists() and (config_dir / "shared_prefs").exists():
                        self.status_label.setText("Pushing ADB Wi-Fi Reborn configuration...")
                        self.progress_bar.setValue(95)
                        QApplication.processEvents()
                        
                        try:
                            # Create shared_prefs directory on device
                            subprocess.run(
                                [str(adb_path), '-s', target_device_id, 'shell', 'su', '-c', 
                                 'mkdir -p /data/data/com.ryosoftware.adbw/shared_prefs'],
                                capture_output=True,
                                text=True,
                                timeout=5,
                                env=env,
                                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                            )
                            
                            # Push each preference file
                            shared_prefs_local = config_dir / "shared_prefs"
                            for pref_file in shared_prefs_local.glob("*.xml"):
                                # Push file to temporary location first
                                temp_path = f"/sdcard/{pref_file.name}"
                                push_result = subprocess.run(
                                    [str(adb_path), '-s', target_device_id, 'push', 
                                     str(pref_file), temp_path],
                                    capture_output=True,
                                    text=True,
                                    timeout=5,
                                    env=env,
                                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                )
                                
                                if push_result.returncode == 0:
                                    # Move to shared_prefs with proper permissions
                                    device_path = f"/data/data/com.ryosoftware.adbw/shared_prefs/{pref_file.name}"
                                    subprocess.run(
                                        [str(adb_path), '-s', target_device_id, 'shell', 'su', '-c',
                                         f'cp {temp_path} {device_path} && chmod 660 {device_path} && rm {temp_path}'],
                                        capture_output=True,
                                        text=True,
                                        timeout=5,
                                        env=env,
                                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                    )
                                    silent_print(f"Pushed configuration file: {pref_file.name}")
                            
                            # Set ownership to app user
                            subprocess.run(
                                [str(adb_path), '-s', target_device_id, 'shell', 'su', '-c',
                                 'chown -R u0_a33:u0_a33 /data/data/com.ryosoftware.adbw/shared_prefs'],
                                capture_output=True,
                                text=True,
                                timeout=5,
                                env=env,
                                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                            )
                            
                            config_pushed = True
                            silent_print("ADB Wi-Fi Reborn configuration pushed successfully")
                        except Exception as e:
                            silent_print(f"Warning: Could not push configuration: {e}")
                    
                    self.progress_bar.setValue(100)
                    self.status_label.setText("ADB Wi-Fi Reborn installed successfully")
                    QApplication.processEvents()
                    
                    QMessageBox.information(
                        self,
                        "Installation Complete",
                        "ADB Wi-Fi Reborn is now on your Y1. We‚Äôll guide you through the first-run steps next."
                    )
                    
                    # Launch the ADB Wi-Fi app to surface first-run prompts
                    launched = self._launch_adb_wifi_app_main_activity(adb_path, target_device_id, env)
                    
                    # Show guided setup wizard
                    self._show_adb_wifi_setup_wizard(adb_path, target_device_id, env, config_pushed, launched)
                    
                    # Hide progress bar after a delay
                    QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
                else:
                    error_msg = install_result.stderr or install_result.stdout
                    QMessageBox.warning(
                        self,
                        "Installation Failed",
                        f"Failed to install ADB Wi-Fi Reborn:\n\n{error_msg}\n\n"
                        "Please ensure your device is connected via USB and USB debugging is enabled."
                    )
                    self.progress_bar.setVisible(False)
                    
            except requests.RequestException as e:
                QMessageBox.warning(
                    self,
                    "Download Failed",
                    f"Failed to download ADB Wi-Fi Reborn:\n\n{str(e)}\n\n"
                    "Please check your internet connection and try again."
                )
                self.progress_bar.setVisible(False)
                # Clean up partial download
                try:
                    if apk_path.exists():
                        apk_path.unlink()
                except:
                    pass
                    
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Error installing ADB Wi-Fi Reborn: {str(e)}")
            self.progress_bar.setVisible(False)
    
    def _notify_dual_connection(self, is_startup=False):
        """Silently prefer USB when dual connection is detected - show dialog only once"""
        try:
            # Set preference to prefer USB when dual connection is active
            self.prefer_usb_for_transfers = True
            # Show dialog only once (first time user sees dual connection)
            if not self._dual_connection_dialog_shown:
                self._dual_connection_dialog_shown = True
                self.save_dual_connection_dialog_shown(True)
                if is_startup:
                    # More prominent message at startup
                    msg_box = QMessageBox(self)
                    msg_box.setWindowTitle("Dual Connection Detected")
                    msg_box.setIcon(QMessageBox.Warning)
                    msg_box.setText("Your Y1 is connected via both USB and Wi-Fi ADB.")
                    msg_box.setInformativeText(
                        "The app will automatically use USB for ADB tasks when both connections are available (USB is more reliable).\n\n"
                        "You don't need the USB cable connected - you can disconnect it and use Wi-Fi only. All ADB features will work over Wi-Fi.\n\n"
                        "If you choose to keep both connections, the app will:\n"
                        "‚Ä¢ Use USB for all ADB operations (more reliable)\n"
                        "‚Ä¢ Allow you to disconnect USB at any time"
                    )
                    msg_box.setStandardButtons(QMessageBox.Ok)
                    msg_box.exec()
                else:
                    # Less intrusive message during runtime
                    QMessageBox.information(
                        self,
                        "Dual Connection Detected",
                        "Your Y1 is connected via both USB and Wi-Fi ADB.\n\n"
                        "The app will automatically use USB for ADB tasks when both connections are available (USB is more reliable).\n\n"
                        "You don't need the USB cable connected - you can disconnect it and use Wi-Fi only. All ADB features will work over Wi-Fi."
                    )
        except:
            pass
    
    def on_adb_status_clicked(self, event):
        """Handle click on ADB status widget to trigger connection check"""
        # 2025-11-09 12:10:00 - original: Click only triggered ADB status check. Updated to also attempt wireless refresh.
        import threading
        threading.Thread(target=self._attempt_wireless_refresh, daemon=True).start()
        self.start_adb_check_worker()

    def _set_adb_disconnected_tooltip(self):
        """Apply informative tooltip explaining ADB disconnected state"""
        tooltip_text = (
            "No Y1 connected via ADB. Regular Install/Updates are available. "
            "Smart Drop (Beta) and ‚ö°Ô∏èFast Update become available when your Y1 is powered on "
            "and connected via ADB over USB or Wi-Fi. Click to refresh."
        )
        for attr in ('adb_status_widget', 'adb_status_label', 'adb_status_light'):
            widget = getattr(self, attr, None)
            if widget:
                widget.setToolTip(tooltip_text)

    def _is_y1_device_id(self, adb_path, device_id, env):
        """Return True if the given adb device_id belongs to a recognised Y1."""
        target_device_id = "0123456789ABCDEF"
        if not device_id:
            return False
        if device_id == target_device_id:
            return True
        if ':' not in device_id:
            return False
        try:
            check_result = subprocess.run(
                [str(adb_path), '-s', device_id, 'shell', 'getprop', 'ro.serialno'],
                capture_output=True,
                text=True,
                timeout=3,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            return check_result.returncode == 0 and target_device_id in check_result.stdout.strip()
        except subprocess.TimeoutExpired:
            silent_print(f"Serial check timed out for {device_id}; treating as non-Y1")
        except Exception as e:
            silent_print(f"Serial check failed for {device_id}: {e}")
        return False

    def _extract_y1_wireless_devices(self, adb_path, env):
        """Return a list of wireless adb device ids that are confirmed Y1 units."""
        y1_devices = []
        try:
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    device_id = line.split('\t')[0]
                    if ':' in device_id and self._is_y1_device_id(adb_path, device_id, env):
                        y1_devices.append(device_id)
        except Exception as e:
            silent_print(f"Error extracting wireless Y1 devices: {e}")
        return y1_devices

    # 2025-11-09 12:33:00 - original: There was no dedicated helper to explain Smart Drop requirements and limitations.
    def show_smart_drop_info_dialog(self, _link=None):
        """Display Smart Drop beta requirements and capability details in a dialog."""
        message = (
            "Smart Drop (Beta) becomes available when your Y1 is powered on and connected via ADB over USB or Wi-Fi.\n\n"
            "Why you'll love it:\n"
            "‚Ä¢ Copy albums, playlists and other folders to your Y1 without finder metadata clutter.\n"
            "‚Ä¢ Drag rom.zip or update.zip files to kick off Install/Restore workflows without digging through folders.\n"
            "‚Ä¢ Install APKs instantly when the firmware allows it, so you can experiment with new apps effortlessly.\n\n"
            "Certain firmwares unlock even more: the Original System software exposes ADB so Smart Drop is ready as soon as you connect, "
            "and custom firmwares like the Rockbox ROM layer in Fast Update so Smart Drop can deliver both media and firmware updates from one place.\n\n"
            "Note: Some advanced actions (such as removing or replacing system apps) still depend on firmware capabilities, so availability can vary."
        )
        QMessageBox.information(self, "Smart Drop (Beta)", message)

    def _attempt_wireless_refresh(self):
        """Attempt to reconnect to the saved wireless ADB endpoint (silent background refresh)"""
        try:
            adb_path = self.find_adb_executable()
            if not adb_path:
                return
            
            import os
            import platform
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Determine saved target (prefer hostname, then saved IP, then current field)
            connection_target = self.load_wireless_adb_hostname()
            if not connection_target:
                connection_target = self.load_wireless_adb_ip()
            if (not connection_target or not connection_target.strip()) and hasattr(self, 'wireless_ip_input'):
                field_text = self.wireless_ip_input.text().strip()
                placeholder = self.wireless_ip_input.placeholderText().strip() if self.wireless_ip_input.placeholderText() else ""
                if field_text and field_text != placeholder:
                    connection_target = field_text
            
            if not connection_target:
                return
            
            connection_target = connection_target.strip()
            if not connection_target:
                return
            
            if ':' not in connection_target:
                connection_target_with_port = f"{connection_target}:5555"
            else:
                connection_target_with_port = connection_target
            
            creationflags = subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            result = subprocess.run(
                [str(adb_path), 'connect', connection_target_with_port],
                capture_output=True,
                text=True,
                timeout=6,
                env=env,
                creationflags=creationflags
            )
            
            # Log silently on success; ignore failures for a quiet refresh experience
            if result.returncode == 0 and 'connected' in result.stdout.lower():
                y1_wifi_devices = self._extract_y1_wireless_devices(adb_path, env)
                if not y1_wifi_devices:
                    disconnect_host = connection_target_with_port.split(':')[0]
                    silent_print(f"Wireless refresh connected non-Y1 target {disconnect_host}; disconnecting")
                    try:
                        subprocess.run(
                            [str(adb_path), 'disconnect', disconnect_host],
                            capture_output=True,
                            text=True,
                            timeout=5,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                    except Exception as disconnect_error:
                        silent_print(f"Error while disconnecting non-Y1 target: {disconnect_error}")
                    return

                host_part = y1_wifi_devices[0].split(':')[0]
                self.save_wireless_adb_ip(host_part)
                if any(c.isalpha() for c in host_part):
                    self.save_wireless_adb_hostname(host_part)
                if hasattr(self, 'wireless_ip_input'):
                    self.wireless_ip_input.setText(host_part)
                silent_print(f"Wireless ADB refresh connected via {connection_target_with_port}")
                QTimer.singleShot(750, self.start_adb_check_worker)
        except Exception as e:
            silent_print(f"Wireless ADB refresh error: {e}")
    
    def start_adb_check_worker(self, force=False, reason=None, callback=None):
        """Request an asynchronous ADB status refresh via the broker."""
        return self.adb_status_broker.request_refresh(force=force, reason=reason, callback=callback)
    
    def _build_adb_environment(self):
        """Return an environment dict with platform-specific PATH adjustments for ADB."""
        env = os.environ.copy()
        if platform.system() == "Darwin":
            homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
            current_path = env.get("PATH", "")
            for brew_path in homebrew_paths:
                if brew_path not in current_path:
                    env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
        return env
    
    def _update_adb_state_cache(self, **kwargs):
        """Update cached ADB connection state."""
        if 'last_checked' not in kwargs:
            kwargs['last_checked'] = datetime.now()
        return self.adb_status_broker.update_snapshot(**kwargs)
    
    def get_cached_adb_status(self):
        """Return the most recently cached ADB connection state."""
        return self.adb_status_broker.get_snapshot()
    
    def request_adb_status_update(self, force_refresh=False, callback=None):
        """
        Request an updated ADB status. If a recent cached value exists and no force is requested,
        the callback (if provided) will be invoked asynchronously with the cached state.
        Otherwise a background check is started and the callback will be invoked once complete.
        """
        state_snapshot = self.get_cached_adb_status()
        last_checked = state_snapshot.get('last_checked')
        if (not force_refresh and last_checked and
                (datetime.now() - last_checked).total_seconds() < 3):
            if callback:
                QTimer.singleShot(0, lambda snap=dict(state_snapshot), cb=callback: cb(snap))
            return state_snapshot
        
        self.start_adb_check_worker(force=True, reason="callback", callback=callback)
        return state_snapshot
    
    def _flush_adb_callbacks(self):
        """Invoke and clear any pending ADB status callbacks with the latest state."""
        self.adb_status_broker.flush_callbacks()
    
    def _ensure_adb_capability(self, requirement, feature_name, auto_refresh=True):
        """
        Ensure the current device meets the requested ADB capability before continuing.
        requirement: 'connected', 'root', or 'fast_update_ready'
        Returns (True, snapshot) when satisfied; otherwise shows a friendly warning and returns (False, snapshot).
        """
        snapshot = self.get_cached_adb_status()
        if auto_refresh and not self.adb_status_broker.requirement_met(requirement, snapshot):
            self.request_adb_status_update(force_refresh=True)
            snapshot = self.get_cached_adb_status()
        
        if self.adb_status_broker.requirement_met(requirement, snapshot):
            return True, snapshot
        
        if requirement == 'connected':
            QMessageBox.warning(
                self,
                "ADB Connection Required",
                f"{feature_name} requires your Innioasis Y1 to be connected via ADB (USB or Wi-Fi).\n\n"
                "Connect your device and try again."
            )
        elif requirement == 'root':
            QMessageBox.warning(
                self,
                "Root Access Required",
                f"{feature_name} needs root access on your Y1. Run 'Prepare Device for Fast Updates' or connect over USB "
                "and allow the app to finish preparing your device before retrying."
            )
        elif requirement == 'fast_update_ready':
            marker_date = snapshot.get('fastupdate_marker_date')
            suffix = f" (last prepared {marker_date})" if marker_date else ""
            QMessageBox.warning(
                self,
                "Fast Update Preparation Needed",
                f"{feature_name} needs the Fast Update helper files on your Y1{suffix}.\n\n"
                "Use 'Prepare Device for Fast Updates' or connect over USB so the app can refresh the preparation."
            )
        else:
            QMessageBox.warning(
                self,
                "ADB Requirement Not Met",
                f"{feature_name} cannot continue because the required ADB capability ({requirement}) is not currently available."
            )
        return False, snapshot
    
    def _on_adb_snapshot_changed(self, snapshot):
        """React to status broker snapshot updates and refresh UI indicators."""
        try:
            # Check for USB storage mode, but also check if Root + Fast Update are available
            usb_drive = self._detect_usb_storage_drive()
            status = snapshot.get('status', 'no_adb')
            device_id = snapshot.get('device_id')
            hostname = snapshot.get('hostname')
            metadata = snapshot.get('metadata', {})
            
            # If USB storage mode is detected, check if Root + Fast Update are available
            if usb_drive:
                # Check if Root + Fast Update are available via ADB
                fast_update_ready = bool(metadata.get('fast_update_ready', False))
                update_script_exists = bool(metadata.get('update_script_exists', False))
                marker_is_today = bool(metadata.get('fastupdate_marker_is_today', False))
                is_rooted = status == 'adb_root' or bool(metadata.get('rooted', False))
                
                # If Root + Fast Update are available, show green ADB status instead of orange USB
                if is_rooted and fast_update_ready and update_script_exists and marker_is_today:
                    silent_print(f"USB Storage Mode detected but Root + Fast Update available - showing green ADB status")
                    # Show green ADB status (Root + Fast Update available)
                    self.update_adb_status_ui(status, device_id, hostname, metadata)
                    return
                else:
                    # Root + Fast Update not available - show orange USB status
                    status = 'usb_storage'
                    device_id = None
                    hostname = None
                    details = {'usb_storage_drive': usb_drive}
                    self.update_adb_status_ui(status, device_id, hostname, details)
                    return
            
            # No USB storage mode - proceed with normal ADB status update
            dual_connected = bool(snapshot.get('dual_connected'))
            if dual_connected and not getattr(self, '_last_dual_connection_state', False):
                self._notify_dual_connection(is_startup=not getattr(self, '_dual_connection_dialog_shown', False))
            self._last_dual_connection_state = dual_connected
            self.update_adb_status_ui(status, device_id, hostname, metadata)
        except Exception as e:
            silent_print(f"Error applying ADB snapshot: {e}")
    
    def _check_usb_and_adb_status(self):
        """Check for USB storage mode first, then ADB status if no USB storage mode"""
        # Check USB storage mode first
        usb_drive = self._detect_usb_storage_drive()
        if usb_drive:
            # USB Storage Mode detected - check ADB status to see if Root + Fast Update are available
            # Get current ADB snapshot to check for Root + Fast Update
            snapshot = self.adb_status_broker.get_snapshot() or {}
            status = snapshot.get('status', 'no_adb')
            device_id = snapshot.get('device_id')
            hostname = snapshot.get('hostname')
            metadata = snapshot.get('metadata', {})
            
            # Check if Root + Fast Update are available
            fast_update_ready = bool(metadata.get('fast_update_ready', False))
            update_script_exists = bool(metadata.get('update_script_exists', False))
            marker_is_today = bool(metadata.get('fastupdate_marker_is_today', False))
            is_rooted = status == 'adb_root' or bool(metadata.get('rooted', False))
            
            # If Root + Fast Update are available, show green ADB status instead of orange USB
            if is_rooted and fast_update_ready and update_script_exists and marker_is_today:
                silent_print(f"USB Storage Mode detected but Root + Fast Update available - showing green ADB status")
                # Show green ADB status (Root + Fast Update available)
                self.update_adb_status_ui(status, device_id, hostname, metadata)
                return
            else:
                # Root + Fast Update not available - show orange USB status
                status = 'usb_storage'
                device_id = None
                hostname = None
                details = {'usb_storage_drive': usb_drive}
                self.update_adb_status_ui(status, device_id, hostname, details)
                return
        
        # No USB storage mode - check ADB status
        self.start_adb_check_worker(reason="timer")
    
    def get_connection_label(self, device_id):
        """
        Get the connection method label based on device_id.
        Returns "ADB" for USB connections, "Wi-Fi" for Wi-Fi connections.
        """
        if not device_id:
            return "ADB"  # Default to ADB if device_id is None
        
        target_device_id = "0123456789ABCDEF"
        if device_id == target_device_id:
            return "ADB"  # USB connection
        elif ':' in device_id:
            return "Wi-Fi"  # Wi-Fi connection (contains IP:port or hostname:port)
        else:
            return "ADB"  # Default to ADB for unknown formats
    
    def update_adb_status_ui(self, status, device_id, hostname, details=None):
        """Update ADB status UI based on check results from worker thread (runs in main thread, no blocking)"""
        # Skip UI update if ADB operation is in progress
        if hasattr(self, 'adb_operation_in_progress') and self.adb_operation_in_progress:
            silent_print("Skipping ADB UI update - operation in progress")
            return
        
        try:
            # Check for USB storage mode, but allow callers to bypass this when forcing display state
            skip_usb_detection = bool(details and details.get('_skip_usb_detection'))
            usb_drive = None if skip_usb_detection else self._detect_usb_storage_drive()
            
            # If USB storage mode is detected, check if Root + Fast Update are available
            if usb_drive:
                # Get current ADB snapshot to check for Root + Fast Update availability
                snapshot = self.adb_status_broker.get_snapshot() or {}
                adb_status = snapshot.get('status', 'no_adb')
                adb_device_id = snapshot.get('device_id')
                adb_hostname = snapshot.get('hostname')
                adb_metadata = snapshot.get('metadata', {})
                
                # Check if Root + Fast Update are available
                fast_update_ready = bool(adb_metadata.get('fast_update_ready', False))
                update_script_exists = bool(adb_metadata.get('update_script_exists', False))
                marker_is_today = bool(adb_metadata.get('fastupdate_marker_is_today', False))
                is_rooted = adb_status == 'adb_root' or bool(adb_metadata.get('rooted', False))
                
                # If Root + Fast Update are available, show green ADB status instead of orange USB
                if is_rooted and fast_update_ready and update_script_exists and marker_is_today:
                    silent_print("USB Storage Mode detected but device is rooted with Fast Update ready - forcing green ADB status")
                    metadata_with_usb = dict(adb_metadata)
                    metadata_with_usb['usb_storage_drive'] = usb_drive
                    metadata_with_usb['_skip_usb_detection'] = True
                    status = adb_status or 'adb_root'
                    device_id = adb_device_id
                    hostname = adb_hostname
                    details = metadata_with_usb
                    usb_drive = None  # prevent orange USB fallback below
                else:
                    # Root + Fast Update not available - show orange USB status
                    if hasattr(self, 'adb_status_widget'):
                        self.adb_status_widget.setVisible(True)
                    
                    # Show orange USB light
                    if hasattr(self, 'adb_status_light'):
                        self.adb_status_light.setStyleSheet("""
                            QLabel {
                                color: #FF8800;
                                font-size: 12px;
                            }
                        """)
                    
                    # Update label to show "USB"
                    if hasattr(self, 'adb_status_label'):
                        self.adb_status_label.setText("USB")
                        self.adb_status_label.setStyleSheet("""
                            QLabel {
                                color: #666666;
                                font-size: 10px;
                                font-weight: bold;
                            }
                        """)
                    
                    # Set tooltip - Fast Update status is determined by marker files on device, not USB storage mode
                    tooltip_text = "Smart Drop is available via USB storage mode. Fast Update status is determined by marker files on device."
                    if hasattr(self, 'adb_status_widget'):
                        self.adb_status_widget.setToolTip(tooltip_text)
                    if hasattr(self, 'adb_status_label'):
                        self.adb_status_label.setToolTip(tooltip_text)
                    if hasattr(self, 'adb_status_light'):
                        self.adb_status_light.setToolTip(tooltip_text)
                    
                    # Make status widget non-clickable for USB mode
                    if hasattr(self, 'adb_status_widget'):
                        self.adb_status_widget.setCursor(Qt.ArrowCursor)
                    if hasattr(self, 'adb_status_label'):
                        self.adb_status_label.setCursor(Qt.ArrowCursor)
                    if hasattr(self, 'adb_status_light'):
                        self.adb_status_light.setCursor(Qt.ArrowCursor)
                    
                    # Don't disable Fast Update button - user can start it and will be prompted to turn off USB storage mode
                    # Fast Update status will be determined by marker files, not USB storage mode presence
                    if hasattr(self, 'send_update_btn'):
                        # Keep button enabled - user will be prompted when they click it
                        self.send_update_btn.setEnabled(True)
                        self.send_update_btn.setToolTip("Fast Update: Click to start. You'll be prompted to turn off USB Storage Mode if needed.")
                    
                    silent_print(f"USB Storage Mode detected: {usb_drive} - Fast Update button remains enabled")
                    return  # Don't check ADB status if USB storage mode is active
            
            # No USB storage mode - proceed with normal ADB status check
            metadata = details or {}
            # Find ADB executable for UI updates (quick check, no blocking)
            adb_path = self.find_adb_executable()
            if not adb_path:
                if hasattr(self, 'adb_status_widget'):
                    self.adb_status_widget.setVisible(False)
                # Disable fast install button
                if hasattr(self, 'send_update_btn'):
                    self.send_update_btn.setEnabled(False)
                return
            
            # Use the status from the worker thread to update UI (no blocking operations)
            if status == 'no_adb':
                # No ADB connection - hide indicator (no red state)
                # Reset dialog flag when USB disconnects so dialog can be shown again if reconnected
                self._disconnect_usb_dialog_shown = False
                # Reset auto-connect flag when device disconnects
                self._auto_connect_attempted_for_device = None
                # Clear cached script installation device when fully disconnected
                if hasattr(self, '_script_installation_device_id'):
                    self._script_installation_device_id = None
                if hasattr(self, 'adb_status_widget'):
                    self.adb_status_widget.setVisible(False)
                    if hasattr(self, 'adb_status_label'):
                        self.adb_status_label.setText("ADB")
                # Disable fast install button
                if hasattr(self, 'send_update_btn'):
                    self.send_update_btn.setEnabled(False)
                return
            elif status == 'adb_only':
                # ADB connected but not rooted - show orange light (not clickable)
                # However, if we just completed a fast update, device might still be initializing after reboot
                # Delay showing "not available" message and retry check with longer delays
                if getattr(self, '_fast_update_just_completed', False):
                    completion_time = getattr(self, '_fast_update_completion_time', 0)
                    time_since_completion = time.time() - completion_time
                    # If less than 90 seconds since fast update, retry the check instead of showing "not available"
                    # Device needs time to reboot and fully initialize
                    if time_since_completion < 90:
                        retry_delay = min(10000, 5000 + int(time_since_completion * 1000))  # Increase delay over time
                        silent_print(f"Fast update just completed ({int(time_since_completion)}s ago) - retrying Fast Update check in {retry_delay}ms...")
                        QTimer.singleShot(retry_delay, lambda: self.adb_status_broker.request_refresh(force=True, reason="post_fast_update_retry"))
                        return  # Don't show "not available" message yet
                    else:
                        # Enough time has passed, clear the flag
                        self._fast_update_just_completed = False
                        silent_print("Fast update completion flag cleared - enough time has passed")
                
                # Clean up macOS metadata when non-root connection is established
                if device_id and adb_path:
                    # Schedule cleanup in background thread to avoid blocking UI
                    import threading
                    def cleanup_metadata():
                        try:
                            env = self._build_adb_environment()
                            self._cleanup_device_macos_metadata(adb_path, device_id, env)
                        except Exception as e:
                            silent_print(f"Error cleaning macOS metadata on connection: {e}")
                    threading.Thread(target=cleanup_metadata, daemon=True).start()
                
                if hasattr(self, 'adb_status_widget'):
                    self.adb_status_widget.setVisible(True)
                    # Stop blinking if it was active
                    self.stop_orange_blink()
                    self.adb_status_light.setStyleSheet("""
                        QLabel {
                            color: #FFA500;
                            font-size: 12px;
                        }
                    """)
                    if hasattr(self, 'adb_status_label'):
                        self.adb_status_label.setText(self.get_connection_label(device_id))
                    # Make NOT clickable when connected (even if not rooted)
                    self.adb_status_widget.setCursor(Qt.ArrowCursor)
                    self.adb_status_label.setCursor(Qt.ArrowCursor)
                    self.adb_status_light.setCursor(Qt.ArrowCursor)
                    # Add tooltip explaining the state
                    tooltip_text = "File transfers, screenshots and remote control will work, but Fast Update is not available on the currently installed firmware."
                    if metadata.get('dual_connected'):
                        tooltip_text += "\nWi-Fi ADB is paired for cable-free use when you're ready to unplug."
                    self.adb_status_widget.setToolTip(tooltip_text)
                    self.adb_status_label.setToolTip(tooltip_text)
                    self.adb_status_light.setToolTip(tooltip_text)
                # Disable fast install button - device not ready for fast update
                if hasattr(self, 'send_update_btn'):
                    self.send_update_btn.setEnabled(False)
                
                # Auto-populate wireless IP field with hostname if USB connected (rooted or not)
                # Check if device_id is USB (not wireless)
                target_device_id = "0123456789ABCDEF"
                is_usb_connection = (device_id == target_device_id)
                
                if is_usb_connection and hostname and hasattr(self, 'wireless_ip_input'):
                    # Check if hostname has changed from saved value
                    saved_hostname = self.load_wireless_adb_hostname()
                    if saved_hostname != hostname:
                        # Hostname has changed - update it
                        self.save_wireless_adb_hostname(hostname)
                        silent_print(f"Detected hostname change: {saved_hostname} -> {hostname}")
                    
                    # Only auto-populate if field is empty or contains placeholder/IP
                    current_value = self.wireless_ip_input.text().strip()
                    # Check if current value is an IP address (has dots and 4 numeric parts)
                    is_ip = False
                    if '.' in current_value:
                        parts = current_value.split('.')
                        if len(parts) == 4 and all(p.isdigit() for p in parts):
                            is_ip = True
                    
                    # Auto-populate with hostname if field is empty, placeholder, or contains IP
                    if not current_value or current_value in ["", "192.168.1.100"] or is_ip:
                        # Prioritize hostname over IP (hostnames are more stable)
                        self.wireless_ip_input.setText(hostname)
                        self.save_wireless_adb_ip(hostname)
                        if not saved_hostname or saved_hostname != hostname:
                            self.save_wireless_adb_hostname(hostname)
                        silent_print(f"Auto-populated wireless ADB field with hostname: {hostname}")
                
                # Automatically attempt Wi-Fi connection when USB device is detected
                # Only attempt once per USB device connection
                if device_id and device_id != self._auto_connect_attempted_for_device:
                    self._auto_connect_attempted_for_device = device_id
                    # Attempt auto-connect in background (silent on failure)
                    import os
                    import platform
                    env = os.environ.copy()
                    if platform.system() == "Darwin":
                        homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                        current_path = env.get("PATH", "")
                        for brew_path in homebrew_paths:
                            if brew_path not in current_path:
                                env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
                    # Use QTimer to attempt connection in background (non-blocking)
                    QTimer.singleShot(500, lambda: self._try_auto_connect_wireless(adb_path, env))
                
                return
            elif status == 'adb_root':
                if hasattr(self, 'adb_status_widget'):
                    self.adb_status_widget.setVisible(True)
                
                active_device_id = metadata.get('active_device_id', device_id)
                update_script_exists = bool(metadata.get('update_script_exists', False))
                marker_present = bool(metadata.get('fastupdate_marker_present', metadata.get('fastupdate_marker_exists', False)))
                marker_date_str = metadata.get('fastupdate_marker_date') or ""
                marker_is_today = bool(metadata.get('fastupdate_marker_is_today', False))
                marker_needs_refresh = bool(metadata.get('fastupdate_marker_needs_refresh', marker_present and not marker_is_today))
                fast_update_ready = bool(metadata.get('fast_update_ready', update_script_exists and marker_is_today))
                
                # Clean up macOS metadata when root connection is established
                if active_device_id and adb_path:
                    # Schedule cleanup in background thread to avoid blocking UI
                    import threading
                    def cleanup_metadata():
                        try:
                            env = self._build_adb_environment()
                            self._cleanup_device_macos_metadata(adb_path, active_device_id, env)
                        except Exception as e:
                            silent_print(f"Error cleaning macOS metadata on root connection: {e}")
                    threading.Thread(target=cleanup_metadata, daemon=True).start()
                
                if update_script_exists and active_device_id:
                    self._script_installation_device_id = active_device_id

                if fast_update_ready:
                    self.stop_orange_blink()
                    self.adb_status_light.setStyleSheet("""
                        QLabel {
                            color: #00FF00;
                            font-size: 12px;
                        }
                    """)
                    if hasattr(self, 'adb_status_label'):
                        self.adb_status_label.setText(self.get_connection_label(device_id))
                    self.adb_status_widget.setCursor(Qt.ArrowCursor)
                    self.adb_status_label.setCursor(Qt.ArrowCursor)
                    self.adb_status_light.setCursor(Qt.ArrowCursor)
                    tooltip_lines = []
                    if hostname:
                        tooltip_lines.append(f"Device: {hostname}")
                    if marker_date_str:
                        tooltip_lines.append(f"Fast Update prepared: {marker_date_str}")
                    if metadata.get('dual_connected'):
                        tooltip_lines.append("Wi-Fi ADB linked (USB in use for commands).")
                    tooltip_text = "\n".join(tooltip_lines)
                    self.adb_status_widget.setToolTip(tooltip_text)
                    self.adb_status_label.setToolTip(tooltip_text)
                    self.adb_status_light.setToolTip(tooltip_text)
                    if hasattr(self, 'send_update_btn'):
                        self.send_update_btn.setEnabled(True)
                        tooltip_suffix = f"Last prepared: {marker_date_str}" if marker_date_str else "Device is ready for Fast Update."
                        self.send_update_btn.setToolTip(f"Fast Update ready. {tooltip_suffix}")
                else:
                    # Double-check if device is actually already prepared before showing "Preparing" status
                    # This prevents stuck "Preparing" status when device is already ready
                    device_already_prepared = False
                    if adb_path and active_device_id:
                        try:
                            env_check = self._build_adb_environment()
                            # Quick check: verify script exists and marker is today
                            script_check = self._check_update_script_exists(adb_path, active_device_id, env_check)
                            marker_present_check, marker_value_check = self._read_fastupdate_marker(adb_path, active_device_id, env_check)
                            marker_is_today_check = False
                            if marker_present_check and marker_value_check:
                                try:
                                    marker_dt = datetime.strptime(marker_value_check.strip(), "%Y-%m-%d")
                                    marker_is_today_check = (marker_dt.date() == datetime.now().date())
                                except ValueError:
                                    pass
                            
                            if script_check and marker_is_today_check:
                                # Device is already prepared - show ready status instead
                                device_already_prepared = True
                                silent_print(f"Device {active_device_id} is already prepared - skipping 'Preparing' status")
                        except Exception as check_error:
                            silent_print(f"Error checking device preparation status: {check_error}")
                    
                    if device_already_prepared:
                        # Device is ready - show ready status instead of preparing
                        self.stop_orange_blink()
                        self.adb_status_light.setStyleSheet("""
                            QLabel {
                                color: #00FF00;
                                font-size: 12px;
                            }
                        """)
                        if hasattr(self, 'adb_status_label'):
                            self.adb_status_label.setText(self.get_connection_label(device_id))
                        self.adb_status_widget.setCursor(Qt.ArrowCursor)
                        self.adb_status_label.setCursor(Qt.ArrowCursor)
                        self.adb_status_light.setCursor(Qt.ArrowCursor)
                        tooltip_lines = []
                        if hostname:
                            tooltip_lines.append(f"Device: {hostname}")
                        if marker_date_str:
                            tooltip_lines.append(f"Fast Update prepared: {marker_date_str}")
                        if metadata.get('dual_connected'):
                            tooltip_lines.append("Wi-Fi ADB linked (USB in use for commands).")
                        tooltip_text = "\n".join(tooltip_lines)
                        self.adb_status_widget.setToolTip(tooltip_text)
                        self.adb_status_label.setToolTip(tooltip_text)
                        self.adb_status_light.setToolTip(tooltip_text)
                        if hasattr(self, 'send_update_btn'):
                            self.send_update_btn.setEnabled(True)
                            tooltip_suffix = f"Last prepared: {marker_date_str}" if marker_date_str else "Device is ready for Fast Update."
                            self.send_update_btn.setToolTip(f"Fast Update ready. {tooltip_suffix}")
                    else:
                        # Device needs preparation - show preparing status
                        self.adb_status_light.setStyleSheet("""
                            QLabel {
                                color: #FFA500;
                                font-size: 12px;
                            }
                        """)
                        if hasattr(self, 'adb_status_label'):
                            self.adb_status_label.setText("Preparing Device for Fast Updates")
                        self.start_orange_blink()
                        self.adb_status_widget.setCursor(Qt.ArrowCursor)
                        self.adb_status_label.setCursor(Qt.ArrowCursor)
                        self.adb_status_light.setCursor(Qt.ArrowCursor)
                        self.adb_status_widget.setToolTip("")
                        self.adb_status_label.setToolTip("")
                        self.adb_status_light.setToolTip("")
                        if hasattr(self, 'send_update_btn'):
                            self.send_update_btn.setEnabled(False)
                            if update_script_exists and marker_present and marker_needs_refresh:
                                suffix = f" Last prepared: {marker_date_str}." if marker_date_str else ""
                                self.send_update_btn.setToolTip(f"Refreshing Fast Update preparation‚Ä¶{suffix}")
                            else:
                                self.send_update_btn.setToolTip("Preparing device for Fast Updates‚Ä¶")

                    should_prepare = (not update_script_exists) or marker_needs_refresh
                    worker_running = (hasattr(self, 'adb_update_script_worker') and
                                      self.adb_update_script_worker and
                                      self.adb_update_script_worker.isRunning())
                    operation_in_progress = getattr(self, 'adb_operation_in_progress', False)

                    if should_prepare and adb_path and active_device_id and not worker_running and not operation_in_progress:
                        self.download_and_push_update_script(adb_path, active_device_id)
                        # Clean up macOS metadata as part of Fast Update preparation (silent, non-blocking)
                        self._cleanup_device_macos_metadata_silent(adb_path, active_device_id, self._build_adb_environment())
                
                # Auto-populate wireless IP field with hostname if USB connected
                # Check if device_id is USB (not wireless)
                target_device_id = "0123456789ABCDEF"
                is_usb_connection = (device_id == target_device_id)
                
                if is_usb_connection and hostname and hasattr(self, 'wireless_ip_input'):
                    # Only auto-populate if field is empty or contains placeholder/IP
                    current_value = self.wireless_ip_input.text().strip()
                    # Check if current value is an IP address (has dots and 4 numeric parts)
                    is_ip = False
                    if '.' in current_value:
                        parts = current_value.split('.')
                        if len(parts) == 4 and all(p.isdigit() for p in parts):
                            is_ip = True
                    
                    # Auto-populate with hostname if field is empty, placeholder, or contains IP
                    if not current_value or current_value in ["", "192.168.1.100"] or is_ip:
                        # Prioritize hostname over IP (hostnames are more stable)
                        self.wireless_ip_input.setText(hostname)
                        self.save_wireless_adb_ip(hostname)
                        self.save_wireless_adb_hostname(hostname)
                        silent_print(f"Auto-populated wireless ADB field with hostname: {hostname}")
                
                return
            
            # Fallback - should not reach here, but handle gracefully
            if hasattr(self, 'adb_status_widget'):
                self.adb_status_widget.setVisible(False)
            
        except Exception as e:
            # On error, hide indicator
            if hasattr(self, 'adb_status_widget'):
                self.adb_status_widget.setVisible(False)
            silent_print(f"Error updating ADB status UI: {e}")
    
    def check_adb_and_update_script(self):
        """Legacy helper retained for compatibility; delegate to unified worker."""
        if getattr(self, 'adb_operation_in_progress', False):
            silent_print("Skipping legacy ADB check - operation in progress")
            return
        silent_print("Legacy check_adb_and_update_script delegating to start_adb_check_worker()")
        self.start_adb_check_worker()
    
    def download_and_push_update_script(self, adb_path, device_id=None):
        """Download and push update.sh script to device"""
        try:
            # Prepare environment with proper PATH for macOS
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"

            # Skip installation if update.sh and fastupdate marker already exist
            if device_id:
                marker_present, marker_value = self._read_fastupdate_marker(adb_path, device_id, env)
                marker_is_today = False
                if marker_present and marker_value:
                    raw_value = marker_value.strip()
                    try:
                        marker_dt = datetime.strptime(raw_value, "%Y-%m-%d")
                        marker_is_today = (marker_dt.date() == datetime.now().date())
                    except ValueError:
                        silent_print(f"download_and_push_update_script: marker value '{raw_value}' is invalid; refreshing preparation")
                script_exists = self._check_update_script_exists(adb_path, device_id, env)
                if script_exists and marker_is_today:
                    silent_print(f"Fast Update already prepared today for device {device_id}; skipping script push.")
                    # Still run cleanup even if already prepared
                    self._cleanup_device_macos_metadata_silent(adb_path, device_id, env)
                    self.stop_orange_blink()
                    self.show_preparation_buttons()
                    return

            # Store installation context
            self._script_installation_device_id = device_id
            self._script_installation_env = env
            self._script_installation_adb_path = adb_path

            # Set flag to prevent periodic ADB checks during operation
            self.adb_operation_in_progress = True

            # Stop any existing worker
            if hasattr(self, 'adb_update_script_worker') and self.adb_update_script_worker:
                if self.adb_update_script_worker.isRunning():
                    self.adb_update_script_worker.stop()
                    self.adb_update_script_worker.wait(1000)
            
            # Start blinking orange light
            self.start_orange_blink()
            
            # Update indicator text
            if hasattr(self, 'adb_status_label'):
                self.adb_status_label.setText("Preparing Device for Fast Updates")
            
            # Hide buttons (Install from zip to About)
            self.hide_preparation_buttons()
            
            # Get script directory (same as Python script)
            script_dir = Path.cwd()
            local_cache_path = script_dir / "update.sh"
            
            # Use provided device_id if available, otherwise detect it
            connected_device_id = device_id
            if not connected_device_id:
                # Get connected device ID using unified method
                status, detected_device_id, _, details = self.get_unified_adb_status(adb_path, env)
                if detected_device_id:
                    connected_device_id = detected_device_id
                    # Store the detected device_id for script installation
                    self._script_installation_device_id = connected_device_id
                else:
                    # Fallback to old detection method if unified method fails
                    devices_result = subprocess.run(
                        [str(adb_path), 'devices'],
                        capture_output=True,
                        text=True,
                        timeout=5,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                    )
                    
                    target_device_id = "0123456789ABCDEF"
                    
                    for line in devices_result.stdout.split('\n'):
                        if '\tdevice' in line:
                            device_id_line = line.split('\t')[0]
                            if device_id_line == target_device_id:
                                connected_device_id = device_id_line
                                break
                            elif ':' in device_id_line:
                                # Use same robust detection as get_unified_adb_status
                                parts = device_id_line.split(':')
                                if len(parts) == 2:
                                    host_part = parts[0]
                                    port_part = parts[1]
                                    is_valid_port = port_part.isdigit() and int(port_part) > 0
                                    is_ip_address = False
                                    if '.' in host_part:
                                        ip_parts = host_part.split('.')
                                        if len(ip_parts) == 4 and all(p.isdigit() for p in ip_parts):
                                            is_ip_address = True
                                    is_hostname = (host_part.startswith('android-') and len(host_part) > 8) or (host_part and not is_ip_address and is_valid_port)
                                    
                                    if (is_ip_address or is_hostname) and is_valid_port:
                                        # Accept as wireless device
                                        connected_device_id = device_id_line
                                        break
                    
                    if connected_device_id:
                        self._script_installation_device_id = connected_device_id
            
            # Create worker for downloading and pushing
            update_script_url = "https://raw.githubusercontent.com/rockbox-y1/rockbox/refs/heads/y1/android/scripts/update.sh"
            self.adb_update_script_worker = ADBUpdateScriptWorker(adb_path, update_script_url, local_cache_path, connected_device_id)
            
            # Connect signals
            self.adb_update_script_worker.status_update.connect(self.on_adb_script_status_update)
            self.adb_update_script_worker.download_progress.connect(self.on_adb_script_download_progress)
            self.adb_update_script_worker.completed.connect(self.on_adb_script_completed)
            
            # Start worker
            self.adb_update_script_worker.start()
            
        except Exception as e:
            silent_print(f"Error starting ADB update script worker: {e}")
            # Reset flag on error
            self.adb_operation_in_progress = False
            self.stop_orange_blink()
            self.show_preparation_buttons()
    
    def start_orange_blink(self):
        """Start blinking animation for orange light"""
        self.adb_light_blinking = True
        self.adb_light_visible = True  # Start visible
        self.adb_blink_timer.start(500)  # Blink every 500ms
    
    def stop_orange_blink(self):
        """Stop blinking animation for orange light"""
        self.adb_light_blinking = False
        self.adb_blink_timer.stop()
        # Reset to orange (not blinking)
        if hasattr(self, 'adb_status_light'):
            self.adb_status_light.setStyleSheet("""
                QLabel {
                    color: #FFA500;
                    font-size: 12px;
                }
            """)
    
    def blink_orange_light(self):
        """Toggle orange light visibility for blinking effect"""
        if hasattr(self, 'adb_status_light') and self.adb_light_blinking:
            # Toggle visibility
            self.adb_light_visible = not self.adb_light_visible
            if self.adb_light_visible:
                # Make it orange
                self.adb_status_light.setStyleSheet("""
                    QLabel {
                        color: #FFA500;
                        font-size: 12px;
                    }
                """)
            else:
                # Make it transparent
                self.adb_status_light.setStyleSheet("""
                    QLabel {
                        color: transparent;
                        font-size: 12px;
                    }
                """)
    
    def hide_preparation_buttons(self):
        """Hide buttons from Install from zip to About"""
        if hasattr(self, 'install_zip_btn'):
            self.install_zip_btn.setVisible(False)
        if hasattr(self, 'driver_buttons_container'):
            self.driver_buttons_container.setVisible(False)
        if hasattr(self, 'discord_btn'):
            self.discord_btn.setVisible(False)
        if hasattr(self, 'about_btn'):
            self.about_btn.setVisible(False)
    
    def show_preparation_buttons(self):
        """Show buttons from Install from zip to About"""
        if hasattr(self, 'install_zip_btn'):
            self.install_zip_btn.setVisible(True)
        if hasattr(self, 'driver_buttons_container'):
            self.driver_buttons_container.setVisible(True)
        if hasattr(self, 'discord_btn'):
            self.discord_btn.setVisible(True)
        if hasattr(self, 'about_btn'):
            self.about_btn.setVisible(True)
    
    def on_adb_script_status_update(self, message):
        """Handle status update from ADB script worker - show in status area"""
        if hasattr(self, 'status_label'):
            self.status_label.setText(message)
        # Ensure progress bar is visible during preparation
        if hasattr(self, 'progress_bar'):
            if not self.progress_bar.isVisible():
                self.progress_bar.setVisible(True)
        silent_print(f"ADB Script Status: {message}")
    
    def on_adb_script_download_progress(self, progress):
        """Handle download progress from ADB script worker"""
        if hasattr(self, 'status_label'):
            self.status_label.setText(f"Preparing Device for Fast Updates... {progress}%")
        if hasattr(self, 'progress_bar'):
            self.progress_bar.setVisible(True)
            self.progress_bar.setValue(progress)
    
    def on_adb_script_completed(self, success, message):
        """Handle completion of ADB script download/push"""
        # Stop blinking
        self.stop_orange_blink()
        
        # Show buttons again
        self.show_preparation_buttons()
        
        # Clear operation in progress flag to allow status check
        if hasattr(self, 'adb_operation_in_progress'):
            self.adb_operation_in_progress = False
        
        # Reset indicator text (will be updated by re-check below)
        if hasattr(self, 'adb_status_label'):
            self.adb_status_label.setText(self.get_connection_label(None))
        
        if success:
            if hasattr(self, 'status_label'):
                self.status_label.setText("Update script installed successfully")
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(False)

            # Update Fast Update marker for the day
            try:
                adb_path = getattr(self, '_script_installation_adb_path', None)
                device_id = getattr(self, '_script_installation_device_id', None)
                env = getattr(self, '_script_installation_env', None)
                if adb_path and device_id:
                    if env is None:
                        env = os.environ.copy()
                        if platform.system() == "Darwin":
                            homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                            current_path = env.get("PATH", "")
                            for brew_path in homebrew_paths:
                                if brew_path not in current_path:
                                    env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
                    self._write_fastupdate_marker(adb_path, device_id, env)
                    # Clean up macOS metadata after script installation
                    self._cleanup_device_macos_metadata_silent(adb_path, device_id, env)
            except Exception as marker_error:
                silent_print(f"Unable to update Fast Update marker: {marker_error}")
            finally:
                self._script_installation_env = None
                self._script_installation_adb_path = None

            # Re-check ADB status to update indicator (use worker thread for proper status check)
            # Use a longer delay to ensure script installation is fully complete and file system is synced
            # This is especially important for Wi-Fi connections which may be slower
            QTimer.singleShot(2000, self.start_adb_check_worker)
            # Enable fast install button
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(True)
        else:
            if hasattr(self, 'status_label'):
                self.status_label.setText("Ready")
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(False)
        silent_print(f"ADB Script Worker completed: {success} - {message}")
    
    def run_update_script_via_adb(self):
        """Run the update script on the device via ADB after update.zip transfer"""
        try:
            # Find ADB executable
            adb_path = self.find_adb_executable()
            if not adb_path:
                silent_print("ADB not found - cannot run update script")
                return False
            
            # Check if device is connected via ADB
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Parse device list
            devices = []
            for line in result.stdout.split('\n'):
                if '\tdevice' in line:
                    devices.append(line.split('\t')[0])
            
            if not devices:
                silent_print("No ADB devices connected - cannot run update script")
                return False
            
            silent_print(f"Found {len(devices)} ADB device(s): {devices}")
            
            # Run the update script as root
            self.status_label.setText("ADB: Running update script as root...")
            QApplication.processEvents()
            
            # Update script path
            update_script_path = '/data/data/update/update.sh'
            
            # Make the script executable before running it
            silent_print(f"Making {update_script_path} executable...")
            chmod_result = subprocess.run(
                [str(adb_path), 'shell', 'su', '-c', f'chmod +x {update_script_path} || sh -c "chmod 755 {update_script_path}"'],
                capture_output=True,
                text=True,
                timeout=5,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            if chmod_result.returncode == 0:
                silent_print(f"Successfully made {update_script_path} executable")
            else:
                silent_print(f"Warning: Could not make script executable (will try running with sh): {chmod_result.stderr}")
            
            silent_print(f"Executing {update_script_path} as root...")
            
            # Prepare environment with proper PATH for macOS
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Run the script with real-time output capture
            process = subprocess.Popen(
                [str(adb_path), 'shell', 'su', '-c', f'sh {update_script_path}'],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line and display in status area
            script_output_lines = []
            script_success = False
            progress = 0
            progress_increment = 25  # Each "++" line = 25% progress
            
            # Show progress bar
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(True)
                self.progress_bar.setRange(0, 100)
                self.progress_bar.setValue(0)
            
            try:
                while True:
                    output = process.stdout.readline()
                    if output == '' and process.poll() is not None:
                        break
                    
                    if output:
                        line = output.strip()
                        if line:
                            script_output_lines.append(line)
                            silent_print(line)
                            
                            # Check if line contains "++" (progress indicator)
                            if '++' in line:
                                # Remove "++" and any leading/trailing whitespace for display
                                display_text = line.replace('++', '').strip()
                                if display_text:
                                    self.status_label.setText(display_text)
                                else:
                                    self.status_label.setText(line)
                                
                                # Increment progress by 25% for each "++" line
                                progress = min(progress + progress_increment, 100)
                                if hasattr(self, 'progress_bar'):
                                    self.progress_bar.setValue(progress)
                            else:
                                # Regular line without "++" - just show it
                                self.status_label.setText(line)
                            
                            QApplication.processEvents()
                
                # Wait for process to complete
                return_code = process.wait()
                script_success = (return_code == 0)
                
            except subprocess.TimeoutExpired:
                silent_print("Update script execution timed out")
                process.terminate()
                script_success = False
            except Exception as e:
                silent_print(f"Error reading script output: {e}")
                process.terminate()
                script_success = False
            
            if script_success:
                # Show all output lines in status
                if script_output_lines:
                    # Show the last line (remove "++" prefix if present)
                    final_line = script_output_lines[-1]
                    if '++' in final_line:
                        final_output = final_line.replace('++', '').strip()
                        if not final_output:
                            final_output = final_line
                    else:
                        final_output = final_line
                    self.status_label.setText(final_output)
                    # Set progress to 100% on completion
                    if hasattr(self, 'progress_bar'):
                        self.progress_bar.setValue(100)
                else:
                    self.status_label.setText("Update completed successfully")
                    if hasattr(self, 'progress_bar'):
                        self.progress_bar.setValue(100)
                return True
            else:
                # Script failed - show instructions
                self.status_label.setText("Update Script: Failed to execute automatically")
                QMessageBox.warning(
                    self,
                    "Update Script Not Executed",
                    "The update script could not be executed automatically via ADB.\n\n"
                    "To complete the update:\n\n"
                    "1. On your Y1 device, go to:\n"
                    "   System Menu > Firmware Update\n\n"
                    "2. The update.zip file has been placed in the .rockbox folder\n"
                    "3. The device will install the update from there\n\n"
                    "The update.zip file is ready on your device."
                )
                return False
                
        except subprocess.TimeoutExpired:
            silent_print("ADB script execution timed out")
            self.status_label.setText("Update script execution timed out")
            return False
        except Exception as e:
            silent_print(f"Error running update script via ADB: {e}")
            self.status_label.setText(f"Error running update script: {str(e)[:100]}")
            return False
    
    def execute_adb_update(self, adb_path):
        """Execute the ADB-based update with live output to status"""
        # Set flag to prevent periodic ADB checks during operation
        self.adb_operation_in_progress = True
        try:
            # Prepare environment with proper PATH for macOS (needed for all ADB commands)
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            self.status_label.setText("ADB: Downloading update.zip...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 100)
            self.progress_bar.setValue(0)
            QApplication.processEvents()
            
            # Disable buttons
            self.download_btn.setEnabled(False)
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(False)
            
            # Check cache first
            cache_path = get_update_zip_cache_path(self.current_update_zip_url)
            temp_update_path = None
            
            if cache_path.exists():
                silent_print(f"Using cached update.zip from: {cache_path}")
                self.status_label.setText("ADB: Using cached update.zip...")
                self.progress_bar.setValue(20)
                QApplication.processEvents()
                temp_update_path = cache_path
            else:
                # Download update.zip
                silent_print("Downloading update.zip...")
                self.status_label.setText("ADB: Downloading update.zip...")
                response = requests.get(self.current_update_zip_url, stream=True, timeout=30)
                response.raise_for_status()
                
                total_size = int(response.headers.get('content-length', 0))
                downloaded = 0
                
                # Download to cache file
                cache_path.parent.mkdir(parents=True, exist_ok=True)
                temp_update_path = cache_path
                
                with open(temp_update_path, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
                            downloaded += len(chunk)
                            if total_size > 0:
                                progress = int((downloaded / total_size) * 40)  # 0-40% for download
                                self.progress_bar.setValue(progress)
                                QApplication.processEvents()
                
                silent_print(f"Download complete: {downloaded} bytes, cached to {cache_path}")
            
            silent_print("Preparing to push to device...")
            self.status_label.setText("ADB: Creating .rockbox directory...")
            self.progress_bar.setValue(40)
            QApplication.processEvents()
            
            # Create .rockbox directory on device
            mkdir_result = subprocess.run(
                [str(adb_path), 'shell', 'mkdir', '-p', '/sdcard/.rockbox'],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if mkdir_result.stdout.strip():
                self.status_label.setText(f"ADB: {mkdir_result.stdout.strip()}")
                QApplication.processEvents()
            
            self.status_label.setText("ADB: Pushing update.zip to device...")
            self.progress_bar.setValue(50)
            QApplication.processEvents()
            
            # Push update.zip with real-time output (unbuffered for immediate output)
            push_process = subprocess.Popen(
                [str(adb_path), 'push', str(temp_update_path), '/sdcard/.rockbox/update.zip'],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=0,  # Unbuffered for immediate output
                universal_newlines=True,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line and display in status area
            push_output_lines = []
            try:
                while True:
                    output = push_process.stdout.readline()
                    if output == '' and push_process.poll() is not None:
                        break
                    
                    if output:
                        line = output.strip()
                        if line:
                            push_output_lines.append(line)
                            silent_print(f"ADB Push: {line}")
                            # Display in status area
                            self.status_label.setText(f"ADB: {line}")
                            # Process events immediately to update UI in real-time
                QApplication.processEvents()
                
                # Wait for process to complete
                return_code = push_process.wait()
                
                if return_code != 0:
                    error_msg = '\n'.join(push_output_lines) if push_output_lines else "Unknown error"
                    raise Exception(f"Failed to push: {error_msg}")
                
            except subprocess.TimeoutExpired:
                silent_print("ADB push timed out")
                push_process.terminate()
                raise Exception("ADB push operation timed out")
            except Exception as e:
                push_process.terminate()
                raise
            
            silent_print("update.zip pushed successfully")
            # Show final push status
            if push_output_lines:
                final_line = push_output_lines[-1]
                self.status_label.setText(f"ADB: {final_line}")
            else:
                self.status_label.setText("ADB: update.zip pushed successfully")
            QApplication.processEvents()
            self.progress_bar.setValue(70)
            
            # Don't delete cached file - keep it for future use
            # Cache file will be reused on next download
            
            # Run update script as root
            self.status_label.setText("ADB: Running update script as root...")
            self.progress_bar.setValue(80)
            QApplication.processEvents()
            
            # Update script path
            update_script_path = '/data/data/update/update.sh'
            
            # Make the script executable before running it
            silent_print(f"Making {update_script_path} executable...")
            chmod_result = subprocess.run(
                [str(adb_path), 'shell', 'su', '-c', f'chmod +x {update_script_path} || sh -c "chmod 755 {update_script_path}"'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            if chmod_result.returncode == 0:
                silent_print(f"Successfully made {update_script_path} executable")
            else:
                silent_print(f"Warning: Could not make script executable (will try running with sh): {chmod_result.stderr}")
            
            silent_print(f"Executing {update_script_path} as root...")
            
            # Run the script with real-time output capture (unbuffered for immediate output)
            process = subprocess.Popen(
                [str(adb_path), 'shell', 'su', '-c', f'sh {update_script_path}'],
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=0,  # Unbuffered for immediate output
                universal_newlines=True,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line and display in status area in real-time
            script_output_lines = []
            script_success = False
            progress = 80  # Start from 80% (where we are after push)
            progress_increment = 25  # Each "++" line = 25% progress
            
            try:
                while True:
                    output = process.stdout.readline()
                    if output == '' and process.poll() is not None:
                        break
                    
                    if output:
                        line = output.strip()
                        if line:
                            script_output_lines.append(line)
                            silent_print(line)
                            
                            # Check if line contains "++" (progress indicator)
                            if '++' in line:
                                # Remove "++" and any leading/trailing whitespace for display
                                display_text = line.replace('++', '').strip()
                                if display_text:
                                    self.status_label.setText(display_text)
                                else:
                                    self.status_label.setText(line)
                                
                                # Increment progress by 25% for each "++" line
                                progress = min(progress + progress_increment, 100)
                                if hasattr(self, 'progress_bar'):
                                    self.progress_bar.setValue(progress)
                            else:
                                # Regular line without "++" - just show it
                                self.status_label.setText(line)
                            
                            # Process events immediately to update UI in real-time
                QApplication.processEvents()
            
                # Wait for process to complete
                return_code = process.wait()
                script_success = (return_code == 0)
                
            except subprocess.TimeoutExpired:
                silent_print("Update script execution timed out")
                process.terminate()
                script_success = False
            except Exception as e:
                silent_print(f"Error reading script output: {e}")
                process.terminate()
                script_success = False
            
            # Set progress to 100% on completion
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setValue(100)
                QApplication.processEvents()
                
                # Small delay before hiding progress
                QTimer.singleShot(500, lambda: self.progress_bar.setVisible(False))
            
            # Re-enable buttons
            self.download_btn.setEnabled(True)
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(True)
            
            if script_success:
                # Show all output lines in status
                if script_output_lines:
                    # Show the last line (remove "++" prefix if present)
                    final_line = script_output_lines[-1]
                    if '++' in final_line:
                        final_output = final_line.replace('++', '').strip()
                        if not final_output:
                            final_output = final_line
                    else:
                        final_output = final_line
                    self.status_label.setText(final_output)
                else:
                    self.status_label.setText("Update completed")
                
                # Show completion message
                QMessageBox.information(
                    self,
                    "Update Complete! ‚úÖ",
                    "‚ö° Fast Update completed successfully via ADB!\n\n"
                    "The update script has been executed on your Y1.\n"
                    "Your device will restart automatically to apply the update.\n\n"
                    "Please wait for your Y1 to reboot."
                )
            else:
                # Script failed - show instructions
                self.status_label.setText("Update Script: Failed to execute automatically")
                QMessageBox.warning(
                    self,
                    "Update Script Not Executed",
                    "The update script could not be executed automatically via ADB.\n\n"
                    "To complete the update:\n\n"
                    "1. On your Y1 device, go to:\n"
                    "   System Menu > Firmware Update\n\n"
                    "2. The update.zip file has been placed in the .rockbox folder\n"
                    "3. The device will install the update from there\n\n"
                    "The update.zip file is ready on your device."
                )
            
        except subprocess.TimeoutExpired:
            silent_print("ADB update operation timed out")
            self.status_label.setText("ADB: Update operation timed out")
            # Re-enable buttons
            self.download_btn.setEnabled(True)
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(True)
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(False)
            QMessageBox.warning(
                self,
                "Update Timeout",
                "The ADB update operation timed out.\n\n"
                "To complete the update:\n\n"
                "1. On your Y1 device, go to:\n"
                "   System Menu > Firmware Update\n\n"
                "2. The update.zip file has been placed in the .rockbox folder\n"
                "3. The device will install the update from there\n\n"
                "The update.zip file is ready on your device."
            )
            # Reset flag on timeout
            self.adb_operation_in_progress = False
        except Exception as e:
            silent_print(f"Error during ADB update: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"ADB: Error - {str(e)[:100]}")
            # Re-enable buttons
            self.download_btn.setEnabled(True)
            if hasattr(self, 'send_update_btn'):
                self.send_update_btn.setEnabled(True)
            if hasattr(self, 'progress_bar'):
                self.progress_bar.setVisible(False)
            QMessageBox.warning(
                self,
                "ADB Update Failed",
                f"Failed to perform automatic update via ADB:\n\n{str(e)}\n\nPlease try using USB Storage mode instead."
            )
            # Reset flag on error
            self.adb_operation_in_progress = False
        finally:
            # Ensure flag is reset
            if hasattr(self, 'adb_operation_in_progress'):
                self.adb_operation_in_progress = False
    
    def handle_smart_drop_payload(self, file_paths):
        """Analyze and process Smart Drop content including themes, Rockbox assets, and media."""
        try:
            if not file_paths:
                return
            paths = []
            for item in file_paths:
                if not item:
                    continue
                path_obj = Path(item)
                if not path_obj.exists():
                    silent_print(f"Smart Drop: Skipping missing item {item}")
                    continue
                paths.append(path_obj)
            if not paths:
                QMessageBox.information(self, "Smart Drop", "No files were available to process.")
                return
            
            # Check if we have USB Storage Mode or ADB connection - prompt if needed
            # Separate rom*.zip files from other files first
            rom_zip_files = []
            other_files = []
            for path in paths:
                if path.is_file() and fnmatch.fnmatch(path.name.lower(), 'rom*.zip'):
                    rom_zip_files.append(path)
                else:
                    other_files.append(path)
            
            # If there are non-rom.zip files, we need a connection - prompt user
            if other_files:
                has_connection, connection_type, usb_drive = self._ensure_connection_for_operation("transfer files via Smart Drop")
                if not has_connection:
                    return
            
            # Process rom.zip files first (if any) - installation process will prompt to turn off/disconnect
            if rom_zip_files:
                for rom_zip in rom_zip_files:
                    self.install_from_zip(str(rom_zip))
                # If only rom.zip files, we're done
                if not other_files:
                    return
            
            # Normal Smart Drop processing for non-rom.zip files
            if not other_files:
                return
            
            # Check for update*.zip files first (using wildcard pattern)
            update_zip_files = []
            remaining_files = []
            for path in other_files:
                if path.is_file() and fnmatch.fnmatch(path.name.lower(), 'update*.zip'):
                    update_zip_files.append(path)
                else:
                    remaining_files.append(path)
            
            # Handle update*.zip files specially - use Fast Update flow
            if update_zip_files:
                for update_zip in update_zip_files:
                    # Use Fast Update flow (same as when triggered from software list)
                    self._handle_update_zip_smart_drop(str(update_zip))
                # If only update*.zip files, we're done
                if not remaining_files:
                    return
            
            # Analyze remaining files
            analysis = self._analyze_smart_drop_sources(remaining_files)
            cleanup_targets = analysis.get('cleanup_paths', [])
            if cleanup_targets:
                self._register_smart_drop_cleanup(cleanup_targets)
            
            handled_anything = False
            
            # Check if we have themes AND other files - if so, transfer zips/folders as-is
            has_themes = bool(analysis.get('rockbox_dirs') or analysis.get('theme_dirs'))
            has_other_content = bool(
                analysis.get('audio_files') or 
                analysis.get('image_files') or 
                analysis.get('apk_files') or
                analysis.get('other_files')
            )
            
            # If zip/folder contains themes AND other files, transfer as-is
            if has_themes and has_other_content:
                # Transfer zips/folders as-is without unpacking
                for source in remaining_files:
                    if source.is_file() and source.suffix.lower() == '.zip':
                        # Transfer zip as-is
                        handled_anything = True
                        self._transfer_file_as_is(str(source))
                    elif source.is_dir():
                        # Transfer folder as-is
                        handled_anything = True
                        self._transfer_folder_as_is(str(source))
            else:
                # Handle themes only (no other content)
                rockbox_dirs = sorted({path for path in analysis.get('rockbox_dirs', set())}, key=lambda p: str(p))
                for rockbox_dir in rockbox_dirs:
                    if hasattr(self, 'merge_rockbox_folder'):
                        handled_anything = True
                        self.merge_rockbox_folder(str(rockbox_dir))
                
                theme_dirs = sorted({path for path in analysis.get('theme_dirs', set())}, key=lambda p: str(p))
                if theme_dirs and hasattr(self, 'install_theme_folders'):
                    handled_anything = True
                    self.install_theme_folders([str(path) for path in theme_dirs])
                
                # Handle APKs separately
                apk_files = sorted({path for path in analysis.get('apk_files', set())}, key=lambda p: str(p))
                if apk_files and hasattr(self, 'install_apk'):
                    handled_anything = True
                    for apk in apk_files:
                        try:
                            self.install_apk(str(apk))
                        except Exception as apk_error:
                            silent_print(f"Smart Drop: Failed to install APK {apk}: {apk_error}")
                
                # If no themes but other files, transfer as-is
                if not has_themes and has_other_content:
                    for source in remaining_files:
                        if source.is_file():
                            handled_anything = True
                            self._transfer_file_as_is(str(source))
                        elif source.is_dir():
                            handled_anything = True
                            self._transfer_folder_as_is(str(source))
            
            if cleanup_targets and not handled_anything and not getattr(self, 'adb_operation_in_progress', False):
                QTimer.singleShot(200, self._run_smart_drop_cleanup)
            
            if not handled_anything:
                QMessageBox.information(self, "Smart Drop", "No supported files were detected in the selection.")
        except Exception as e:
            silent_print(f"Smart Drop processing error: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(
                self,
                "Smart Drop Error",
                f"An error occurred while processing the dropped items:\n\n{str(e)}"
            )
            QTimer.singleShot(200, self._run_smart_drop_cleanup)

    def _analyze_smart_drop_sources(self, sources):
        """Inspect Smart Drop sources and bucket their contents."""
        analysis = {
            'rockbox_dirs': set(),
            'theme_dirs': set(),
            'apk_files': set(),
            'audio_files': set(),
            'image_files': set(),
            'other_files': set(),
            'cleanup_paths': []
        }
        for source in sources:
            try:
                if source.is_dir():
                    self._collect_smart_drop_directory(source, analysis)
                elif source.is_file():
                    suffix = source.suffix.lower()
                    if suffix == '.zip':
                        self._collect_smart_drop_zip(source, analysis)
                    else:
                        self._categorize_smart_drop_file(source, analysis)
            except Exception as analyze_error:
                silent_print(f"Smart Drop: failed to inspect {source}: {analyze_error}")
        return analysis

    def _collect_smart_drop_directory(self, directory, analysis):
        """Recursively evaluate a directory for Smart Drop content."""
        try:
            directory = Path(directory)
            if not directory.exists() or self._is_macos_metadata(directory):
                return
            if directory.name.lower() == '.rockbox':
                analysis['rockbox_dirs'].add(directory)
                return
            if hasattr(self, '_is_theme_folder') and self._is_theme_folder(str(directory)):
                analysis['theme_dirs'].add(directory)
                return
            for entry in directory.iterdir():
                if self._is_macos_metadata(entry):
                    continue
                if entry.is_dir():
                    self._collect_smart_drop_directory(entry, analysis)
                else:
                    self._categorize_smart_drop_file(entry, analysis)
        except Exception as dir_error:
            silent_print(f"Smart Drop: directory scan error for {directory}: {dir_error}")

    def _collect_smart_drop_zip(self, zip_path, analysis):
        """Extract a ZIP to a temporary location and analyze its contents."""
        try:
            temp_dir = Path(tempfile.mkdtemp(prefix="smartdrop-"))
            with zipfile.ZipFile(zip_path, 'r') as zf:
                for member in zf.infolist():
                    member_name = member.filename or ""
                    if self._is_macos_metadata(member_name):
                        continue
                    try:
                        zf.extract(member, temp_dir)
                    except Exception as extract_error:
                        silent_print(f"Smart Drop: failed to extract {member_name} from {zip_path}: {extract_error}")
            self._cleanup_macos_metadata(temp_dir)
            analysis['cleanup_paths'].append(temp_dir)
            self._collect_smart_drop_directory(temp_dir, analysis)
        except Exception as zip_error:
            silent_print(f"Smart Drop: zip analysis error for {zip_path}: {zip_error}")

    def _categorize_smart_drop_file(self, file_path, analysis):
        """Classify a single file for Smart Drop handling."""
        try:
            file_path = Path(file_path)
            if not file_path.exists() or self._is_macos_metadata(file_path):
                return
            suffix = file_path.suffix.lower()
            audio_extensions = {'.mp3', '.flac', '.ogg', '.wav', '.m4a', '.aac', '.opus', '.wma'}
            image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'}
            if suffix == '.apk':
                analysis['apk_files'].add(file_path)
            elif suffix in audio_extensions:
                analysis['audio_files'].add(file_path)
            elif suffix in image_extensions:
                analysis['image_files'].add(file_path)
            else:
                analysis['other_files'].add(file_path)
        except Exception as file_error:
            silent_print(f"Smart Drop: file categorization error for {file_path}: {file_error}")
    
    def _handle_update_zip_smart_drop(self, update_zip_path):
        """Handle update*.zip files dropped via Smart Drop - use Fast Update flow when available."""
        try:
            update_zip_path = Path(update_zip_path)
            if not update_zip_path.exists():
                QMessageBox.warning(self, "Error", f"update*.zip file not found: {update_zip_path}")
                return
            
            # Check if Fast Update is available (same as when triggered from software list)
            ready, snapshot = self._ensure_adb_capability('fast_update_ready', "Fast Update")
            if ready:
                # Fast Update is available - use the same flow as try_adb_fast_update
                self._handle_local_update_zip_fast_update(update_zip_path)
            else:
                # Fast Update not available - use manual copy method
                self._handle_update_zip_manual(update_zip_path)
            
        except Exception as e:
            silent_print(f"Error handling update*.zip: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(
                self,
                "Error",
                f"Failed to handle update*.zip file:\n\n{str(e)}"
            )
    
    def _handle_local_update_zip_fast_update(self, update_zip_path):
        """Handle local update*.zip file using Fast Update flow (same as downloaded from software list)."""
        try:
            # Check for USB Storage Mode - Fast Update cannot proceed if it's active
            while True:
                usb_drive = self._detect_usb_storage_drive()
                if not usb_drive:
                    # USB Storage Mode is off - proceed
                    silent_print("USB Storage Mode is off - proceeding with Fast Update")
                    break
                
                # USB Storage Mode detected - prompt user to turn it off
                reply = QMessageBox.question(
                    self,
                    "USB Storage Mode Detected",
                    "Fast Update requires ADB access and cannot proceed while USB Storage Mode is active.\n\n"
                    "Please turn off USB Storage mode, then click OK.\n\n"
                    f"Detected Y1 drive: {usb_drive}",
                    QMessageBox.Ok | QMessageBox.Cancel,
                    QMessageBox.Ok
                )
                
                if reply == QMessageBox.Cancel:
                    silent_print("User cancelled Fast Update - USB Storage Mode active")
                    return
                
                # Check again after user clicked OK
                QApplication.processEvents()
                time.sleep(0.5)
            
            # Find ADB executable
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(
                    self,
                    "Fast Update Requires ADB",
                    "Fast Update requires an ADB connection, but ADB is not available.\n\n"
                    "To install your Y1's software update, you have two options:\n\n"
                    "1. Select a Fast Install enabled firmware from the available software list "
                    "and do a clean install by selecting \"Install / Restore\"\n\n"
                    "2. Use a full-sized rom.zip file to continue installing your Y1's software update\n\n"
                    "Fast Update (update.zip) requires ADB to push files and run scripts automatically."
                )
                self.status_label.setText("Fast Update requires ADB connection")
                return
            
            # Prepare environment
            env = self._build_adb_environment()
            
            # Get device ID
            snapshot = self.get_cached_adb_status()
            device_id = snapshot.get('device_id') or snapshot.get('active_device_id')
            if not device_id:
                QMessageBox.warning(
                    self,
                    "Fast Update Requires ADB Connection",
                    "Fast Update requires an ADB connection, but no ADB device is connected.\n\n"
                    "To install your Y1's software update, you have two options:\n\n"
                    "1. Select a Fast Install enabled firmware from the available software list "
                    "and do a clean install by selecting \"Install / Restore\"\n\n"
                    "2. Use a full-sized rom.zip file to continue installing your Y1's software update\n\n"
                    "Fast Update (update.zip) requires ADB to push files and run scripts automatically."
                )
                self.status_label.setText("Fast Update requires ADB connection")
                return
            
            # Use Fast Update flow - push and run script (same as downloaded update.zip)
            self.adb_operation_in_progress = True
            self.status_label.setText("Pushing update*.zip to device...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            
            # Push update*.zip to device
            push_cmd = [str(adb_path), '-s', device_id, 'push', str(update_zip_path), '/sdcard/.rockbox/update.zip']
            result = subprocess.run(
                push_cmd,
                capture_output=True,
                text=True,
                timeout=60,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if result.returncode == 0:
                # Run update script (same as Fast Update)
                script_success = self.run_update_script_via_adb()
                if script_success:
                    QMessageBox.information(
                        self,
                        "Update Complete",
                        "‚úÖ update*.zip has been pushed to your Y1.\n\n"
                        "‚úÖ Update script executed successfully via ADB.\n\n"
                        "Your Y1 will restart and apply the update automatically."
                    )
                    self.status_label.setText("Fast Update completed successfully")
                else:
                    QMessageBox.information(
                        self,
                        "Update Pushed",
                        "‚úÖ update*.zip has been pushed to your Y1.\n\n"
                        "Next steps:\n"
                        "1. On your Y1, go to Main Menu > System\n"
                        "2. Select Firmware Update\n"
                        "3. The update will install automatically"
                    )
                    self.status_label.setText("update*.zip pushed - run Firmware Update on device")
            else:
                error_msg = result.stderr or result.stdout or "Unknown error"
                QMessageBox.warning(
                    self,
                    "Push Failed",
                    f"Failed to push update*.zip to device:\n\n{error_msg}"
                )
                self.status_label.setText("Failed to push update*.zip")
            
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
            
        except Exception as e:
            silent_print(f"Error in Fast Update flow: {e}")
            import traceback
            traceback.print_exc()
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
            QMessageBox.warning(
                self,
                "Error",
                f"Failed to perform Fast Update:\n\n{str(e)}"
            )
    
    def _handle_update_zip_manual(self, update_zip_path):
        """Handle update*.zip file manually (copy to .rockbox folder)."""
        try:
            update_zip_path = Path(update_zip_path)
            if not update_zip_path.exists():
                QMessageBox.warning(self, "Error", f"update*.zip file not found: {update_zip_path}")
                return
            
            # Check for USB storage mode first
            usb_drive = self._detect_usb_storage_drive()
            if usb_drive:
                # Copy to .rockbox folder on USB drive
                rockbox_dir = Path(usb_drive) / ".rockbox"
                if not rockbox_dir.exists():
                    rockbox_dir.mkdir(parents=True, exist_ok=True)
                destination = rockbox_dir / "update.zip"
                shutil.copy2(update_zip_path, destination)
                self.status_label.setText("update*.zip copied to .rockbox folder")
                
                # Try to run update script via ADB
                script_success = self.run_update_script_via_adb()
                if script_success:
                    QMessageBox.information(
                        self,
                        "Update Complete",
                        "‚úÖ update*.zip has been copied to your Y1.\n\n"
                        "‚úÖ Update script executed successfully via ADB.\n\n"
                        "Your Y1 will restart and apply the update automatically."
                    )
                else:
                    QMessageBox.information(
                        self,
                        "Update Copied",
                        "‚úÖ update*.zip has been copied to your Y1.\n\n"
                        "Next steps:\n"
                        "1. Safely disconnect your Y1 from your computer\n"
                        "2. On your Y1, go to Main Menu > System\n"
                        "3. Select Firmware Update\n"
                        "4. The update will install automatically"
                    )
                return
            
            # No USB drive - try ADB
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(
                    self,
                    "No Connection",
                    "No USB Storage Mode or ADB connection detected.\n\n"
                    "Please connect your Y1 via USB Storage Mode or ADB to install update*.zip."
                )
                return
            
            # Use ADB to push update*.zip
            env = self._build_adb_environment()
            snapshot = self.get_cached_adb_status()
            device_id = snapshot.get('device_id')
            
            if not device_id:
                QMessageBox.warning(
                    self,
                    "No ADB Connection",
                    "No ADB device connected.\n\n"
                    "Please connect your Y1 via USB or Wi-Fi ADB to install update*.zip."
                )
                return
            
            # Push update*.zip to device
            self.status_label.setText("Pushing update*.zip to device...")
            push_cmd = [str(adb_path), '-s', device_id, 'push', str(update_zip_path), '/sdcard/.rockbox/update.zip']
            result = subprocess.run(
                push_cmd,
                capture_output=True,
                text=True,
                timeout=60,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            if result.returncode == 0:
                # Try to run update script
                script_success = self.run_update_script_via_adb()
                if script_success:
                    QMessageBox.information(
                        self,
                        "Update Complete",
                        "‚úÖ update*.zip has been pushed to your Y1.\n\n"
                        "‚úÖ Update script executed successfully via ADB.\n\n"
                        "Your Y1 will restart and apply the update automatically."
                    )
                else:
                    QMessageBox.information(
                        self,
                        "Update Pushed",
                        "‚úÖ update*.zip has been pushed to your Y1.\n\n"
                        "Next steps:\n"
                        "1. On your Y1, go to Main Menu > System\n"
                        "2. Select Firmware Update\n"
                        "3. The update will install automatically"
                    )
            else:
                QMessageBox.warning(
                    self,
                    "Push Failed",
                    f"Failed to push update*.zip to device:\n\n{result.stderr or result.stdout}"
                )
                self.status_label.setText("Failed to push update*.zip")
            
        except Exception as e:
            silent_print(f"Error handling update*.zip manually: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(
                self,
                "Error",
                f"Failed to handle update*.zip file:\n\n{str(e)}"
            )
    
    def _transfer_file_as_is(self, file_path):
        """Transfer a single file to the device as-is (no unpacking or special handling)."""
        try:
            self.transfer_files_to_device([file_path])
        except Exception as e:
            silent_print(f"Error transferring file {file_path}: {e}")
            QMessageBox.warning(
                self,
                "Transfer Error",
                f"Failed to transfer file:\n{str(e)}"
            )
    
    def _transfer_folder_as_is(self, folder_path):
        """Transfer a folder to the device as-is (no unpacking or special handling)."""
        try:
            self.transfer_files_to_device([folder_path])
        except Exception as e:
            silent_print(f"Error transferring folder {folder_path}: {e}")
            QMessageBox.warning(
                self,
                "Transfer Error",
                f"Failed to transfer folder:\n{str(e)}"
            )

    def _queue_smart_drop_transfers(self, transfers):
        """Queue Smart Drop transfers so they run sequentially without collisions."""
        if not transfers:
            return
        for label, paths in transfers:
            if not paths:
                continue
            self._smart_drop_followup_transfers.append((label, paths))
        QTimer.singleShot(0, self._kick_smart_drop_transfer_runner)

    def _kick_smart_drop_transfer_runner(self):
        """Process queued Smart Drop transfers one at a time."""
        if getattr(self, 'adb_operation_in_progress', False):
            QTimer.singleShot(600, self._kick_smart_drop_transfer_runner)
            return
        if not self._smart_drop_followup_transfers:
            if not self.file_transfer_queue:
                self._run_smart_drop_cleanup()
            return
        label, paths = self._smart_drop_followup_transfers.pop(0)
        if label and hasattr(self, 'status_label'):
            self.status_label.setText(f"Preparing to transfer {label}...")
        self.transfer_files_to_device(paths)
        if not getattr(self, 'adb_operation_in_progress', False):
            QTimer.singleShot(600, self._kick_smart_drop_transfer_runner)

    def _register_smart_drop_cleanup(self, paths):
        """Track temporary paths so they can be deleted after Smart Drop completes."""
        if not paths:
            return
        self._smart_drop_cleanup_paths.extend(paths)

    def _run_smart_drop_cleanup(self):
        """Remove any temporary directories created during Smart Drop analysis."""
        if not getattr(self, '_smart_drop_cleanup_paths', None):
            return
        cleanup_targets = list(self._smart_drop_cleanup_paths)
        self._smart_drop_cleanup_paths = []
        for target in cleanup_targets:
            try:
                shutil.rmtree(target, ignore_errors=True)
            except Exception as cleanup_error:
                silent_print(f"Smart Drop: cleanup failed for {target}: {cleanup_error}")

    def transfer_files_to_device(self, file_paths, retry_via=None):
        """Transfer files/folders to device over ADB when connected (with queuing support) or via USB fallback"""
        try:
            if not self._ensure_adb_idle("a Smart Drop transfer"):
                return
            
            # Check for connection (ADB or USB drive) - prompt if needed
            has_connection, connection_type, usb_drive = self._ensure_connection_for_operation("transfer files")
            if not has_connection:
                return
            
            # If USB storage mode is available, use it directly
            if connection_type == "usb_storage" and usb_drive and retry_via != 'usb':
                silent_print(f"USB Storage Mode detected, using USB storage drive for file transfer: {usb_drive}")
                destination_folder = self._select_usb_storage_folder(usb_drive, file_paths)
                if destination_folder:
                    self._transfer_files_via_usb(file_paths, destination_folder, fallback_try='adb' if retry_via is None else None)
                return
            
            # Check if ADB is available
            adb_path = self.find_adb_executable()
            
            # Prepare environment once and reuse after status callback
            env = self._build_adb_environment()
            
            # Show status message while checking for device
            self.status_label.setText("Checking for connected device...")
            QApplication.processEvents()
            
            def _on_status_ready(snapshot):
                try:
                    self._continue_transfer_after_status(file_paths, adb_path, env, snapshot, retry_via=retry_via)
                except Exception as callback_error:
                    silent_print(f"Error handling Smart Drop status: {callback_error}")
                    # Try USB storage mode as fallback
                    usb_drive_fallback = self._detect_usb_storage_drive()
                    if usb_drive_fallback:
                        silent_print(f"ADB transfer failed, using USB storage drive: {usb_drive_fallback}")
                        self._transfer_files_via_usb(file_paths, usb_drive_fallback, fallback_try='adb')
                    else:
                        self.status_label.setText("Transfer error: Unable to start ADB transfer.")
                        QMessageBox.warning(
                            self,
                            "Transfer Error",
                            "Unable to start ADB transfer. Please verify your connection and try again."
                        )
            
            self.request_adb_status_update(force_refresh=True, callback=_on_status_ready)
            
        except Exception as e:
            silent_print(f"Error during file transfer: {e}")
            import traceback
            traceback.print_exc()
            # Try USB storage mode as fallback
            usb_drive = self._detect_usb_storage_drive()
            if usb_drive and retry_via != 'usb':
                silent_print(f"Transfer error, trying USB storage drive: {usb_drive}")
                self._transfer_files_via_usb(file_paths, usb_drive, fallback_try='adb')
            else:
                self.status_label.setText(f"Transfer error: {str(e)[:100]}")
                self.progress_bar.setVisible(False)
                QMessageBox.warning(
                    self,
                    "Transfer Error",
                    f"An error occurred during file transfer:\n\n{str(e)}"
                )
            # Reset flag on error
            if hasattr(self, 'adb_operation_in_progress'):
                self.adb_operation_in_progress = False
    
    def _continue_transfer_after_status(self, file_paths, adb_path, env, snapshot, retry_via=None):
        """Continue Smart Drop workflow after asynchronous status lookup completes.
        
        Gracefully selects the appropriate transfer method:
        - USB Storage Mode: If detected, uses file system access (works for file transfers)
        - ADB over Wi-Fi: If available and USB Storage Mode is off, uses ADB Wi-Fi
        - ADB over USB: If available and USB Storage Mode is off, uses ADB USB
        - Fallback: Prompts user to use USB Storage Mode if no ADB available
        """
        status = snapshot.get('status', 'no_adb')
        connected_device_id = snapshot.get('device_id')
        
        # Check for USB storage mode first - if detected, use it directly for file transfers
        # Note: USB Storage Mode works great for file transfers, but blocks ADB operations
        # like Fast Update scripts and APK installs
        usb_drive = self._detect_usb_storage_drive()
        if usb_drive and retry_via != 'usb':
            silent_print(f"USB Storage Mode detected, using USB storage drive for file transfer: {usb_drive}")
            # Use USB storage mode file system access for folder selection
            destination_folder = self._select_usb_storage_folder(usb_drive, file_paths)
            if destination_folder:
                # Transfer directly to USB drive using file system access
                self._transfer_files_via_usb(file_paths, destination_folder, fallback_try='adb' if retry_via is None else None)
            return
        
        # No USB Storage Mode - check ADB status
        # ADB can work over Wi-Fi or USB, both are fine for file transfers
        if status == 'no_adb' or not connected_device_id:
            # No ADB connection (neither Wi-Fi nor USB) and no USB storage mode - prompt user
            reply = QMessageBox.question(
                self,
                "ADB Not Connected",
                "No ADB device is connected (neither Wi-Fi nor USB) and no USB storage drive was detected.\n\n"
                "Would you like to transfer files via USB drive instead?\n\n"
                "You can select your Y1's USB drive or folder location using your system's file browser.\n\n"
                "Files will be available after you turn off USB Storage Mode.",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                self._transfer_files_via_usb(file_paths, fallback_try='adb')
            return
        
        # Process events to keep GUI responsive
        QApplication.processEvents()
        
        # Ask user to select destination folder on device (ADB mode)
        destination_folder = self.select_device_folder(adb_path, connected_device_id, env, file_paths)
        if not destination_folder:
            # User cancelled folder selection
            return
        
        # Check if a transfer is already in progress
        fallback_for_queue = 'usb' if retry_via is None else None
        if (hasattr(self, 'file_transfer_worker') and self.file_transfer_worker and 
                self.file_transfer_worker.isRunning()):
            # Add to queue instead of starting immediately
            self.file_transfer_queue.append((file_paths, destination_folder, adb_path, connected_device_id, env, fallback_for_queue))
            queue_size = len(self.file_transfer_queue)
            self.status_label.setText(f"Transfer queued ({queue_size} in queue). Current transfer in progress...")
            QMessageBox.information(
                self,
                "Transfer Queued",
                f"Your files have been added to the transfer queue.\n\n"
                f"Queue position: {queue_size}\n"
                f"The transfer will begin automatically after the current transfer completes."
            )
            return
        
        # No transfer in progress - start immediately
        self._start_file_transfer(file_paths, destination_folder, adb_path, connected_device_id, env, fallback_try=fallback_for_queue)
    
    def _start_file_transfer(self, file_paths, destination_folder, adb_path, connected_device_id, env, fallback_try=None):
        """Start a file transfer (internal method)"""
        try:
            # Set flag to prevent periodic ADB checks during operation
            self.adb_operation_in_progress = True
            
            # Show progress
            queue_size = len(self.file_transfer_queue) if hasattr(self, 'file_transfer_queue') else 0
            if queue_size > 0:
                self.status_label.setText(f"Preparing to transfer files... ({queue_size} in queue)")
            else:
                self.status_label.setText("Preparing to transfer files...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, len(file_paths))
            self.progress_bar.setValue(0)
            QApplication.processEvents()
            
            # Create and start worker thread for non-blocking file transfer
            self.file_transfer_worker = FileTransferWorker(adb_path, connected_device_id, env, file_paths, destination_folder)
            self.file_transfer_worker.fallback_try = fallback_try
            self.file_transfer_worker.status_update.connect(self._on_file_transfer_status)
            self.file_transfer_worker.progress_update.connect(self._on_file_transfer_progress)
            self.file_transfer_worker.completed.connect(self._on_file_transfer_complete)
            
            # Start worker thread
            self.file_transfer_worker.start()
            
        except Exception as e:
            silent_print(f"Error starting file transfer: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Transfer error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            # Reset flag on error
            if hasattr(self, 'adb_operation_in_progress'):
                self.adb_operation_in_progress = False
            # Try to process next item in queue
            self._process_next_queued_transfer()
    
    def _on_file_transfer_status(self, message):
        """Handle status updates from FileTransferWorker"""
        # Add queue information to status if there are queued transfers
        queue_size = len(self.file_transfer_queue) if hasattr(self, 'file_transfer_queue') else 0
        if queue_size > 0:
            self.status_label.setText(f"{message} ({queue_size} in queue)")
        else:
            self.status_label.setText(message)
    
    def _on_file_transfer_progress(self, current, total):
        """Handle progress updates from FileTransferWorker"""
        # Ensure progress bar range matches total
        if self.progress_bar.maximum() != total:
            self.progress_bar.setRange(0, total)
        self.progress_bar.setValue(current)
    
    def _on_file_transfer_complete(self, success, result):
        """Handle completion of FileTransferWorker"""
        # Reset flag
        self.adb_operation_in_progress = False
        fallback_try = None
        original_paths = []
        if hasattr(self, 'file_transfer_worker') and self.file_transfer_worker:
            fallback_try = getattr(self.file_transfer_worker, 'fallback_try', None)
            try:
                original_paths = list(self.file_transfer_worker.file_paths)
            except Exception:
                original_paths = []
        
        transferred_count = result.get('transferred_count', 0)
        failed_files = result.get('failed_files', [])
        total = result.get('total', 0)
        retry_triggered = bool(fallback_try == 'usb' and transferred_count < total)
        
        # Show completion message
        if retry_triggered:
            self.status_label.setText("ADB transfer incomplete, switching to USB storage‚Ä¶")
        else:
            if transferred_count == total:
                self.status_label.setText(f"Successfully transferred {transferred_count} item(s) to device")
                QMessageBox.information(
                    self,
                    "Transfer Complete",
                    f"Successfully transferred {transferred_count} item(s) to your device."
                )
            elif transferred_count > 0:
                self.status_label.setText(f"Transferred {transferred_count} of {total} item(s)")
                failed_list = '\n'.join(failed_files)
                QMessageBox.warning(
                    self,
                    "Transfer Partially Complete",
                    f"Transferred {transferred_count} of {total} item(s).\n\n"
                    f"Failed items:\n{failed_list}"
                )
            else:
                self.status_label.setText("File transfer failed")
                failed_list = '\n'.join(failed_files)
                QMessageBox.warning(
                    self,
                    "Transfer Failed",
                    f"Failed to transfer all items:\n\n{failed_list}"
                )
            # Hide progress bar only when not retrying
            self.progress_bar.setVisible(False)
        
        if retry_triggered and original_paths:
            QTimer.singleShot(250, lambda paths=list(original_paths): self._transfer_files_via_usb(paths, fallback_try='adb'))
        
        # Clear worker reference before queue processing
        self.file_transfer_worker = None
        
        # Process next item in queue if available
        self._process_next_queued_transfer()
        QTimer.singleShot(150, self._kick_smart_drop_transfer_runner)
        if not self.file_transfer_queue and not self._smart_drop_followup_transfers:
            QTimer.singleShot(200, self._run_smart_drop_cleanup)
    
    def _process_next_queued_transfer(self):
        """Process the next item in the file transfer queue"""
        if not hasattr(self, 'file_transfer_queue'):
            self.file_transfer_queue = []
        
        if self.file_transfer_queue:
            # Get next item from queue
            file_paths, destination_folder, adb_path, connected_device_id, env, fallback_try = self.file_transfer_queue.pop(0)
            silent_print(f"Processing queued transfer: {len(file_paths)} file(s)")
            
            # Start the next transfer
            QTimer.singleShot(
                500,
                lambda paths=list(file_paths), dest=destination_folder, adb=adb_path,
                       device_id=connected_device_id, env_vars=env, fb=fallback_try:
                    self._start_file_transfer(paths, dest, adb, device_id, env_vars, fallback_try=fb)
            )
    
    def select_device_folder(self, adb_path, device_id, env, file_paths=None):
        """Show dialog to select destination folder on device with expandable tree view"""
        try:
            # Check for USB storage mode first - if detected, use file system access
            usb_drive = self._detect_usb_storage_drive()
            if usb_drive:
                # Use USB storage mode file system access instead of ADB
                return self._select_usb_storage_folder(usb_drive, file_paths)
            
            # Hardcoded mountpoint that contains .rockbox
            mountpoint = "/storage/sdcard0"
            
            # Show status message while indexing
            if hasattr(self, 'status_label'):
                self.status_label.setText("Indexing files and folders on device...")
                QApplication.processEvents()
            
            # Determine suggested folder based on file types
            suggested_folder = self._suggest_folder_by_file_type(file_paths) if file_paths else None
            
            # List top-level folders on device
            folders = self.list_device_folders(adb_path, device_id, env)
            
            # Clear status message after indexing
            if hasattr(self, 'status_label'):
                self.status_label.setText("")
                QApplication.processEvents()
            
            if not folders:
                # If we can't list folders, default to mountpoint
                reply = QMessageBox.question(
                self,
                    "Select Destination",
                    f"Could not list folders on device.\n\n"
                    f"Would you like to transfer to {mountpoint}/ ?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                if reply == QMessageBox.Yes:
                    return mountpoint
                return None
            
            # Create dialog for folder selection
            dialog = QDialog(self)
            dialog.setWindowTitle("Select Destination Folder on Device")
            dialog.setMinimumWidth(500)
            dialog.setMinimumHeight(400)
            
            layout = QVBoxLayout(dialog)
            
            # Label
            label = QLabel("Select the folder on your device where you want to transfer the files:")
            layout.addWidget(label)
            
            # Tree widget for folders (expandable)
            tree_widget = QTreeWidget()
            tree_widget.setHeaderLabel("Folders")
            tree_widget.setRootIsDecorated(True)
            
            # Helper function to remove mountpoint prefix for display
            def display_name(path):
                if path.startswith(mountpoint + '/'):
                    return path[len(mountpoint) + 1:]  # Remove mountpoint + '/'
                elif path == mountpoint:
                    return '/'
                return path
            
            # Helper function to get full path from display name
            def full_path(display):
                if display == '/':
                    return mountpoint
                return f'{mountpoint}/{display}'
            
            # Add root item
            root_item = QTreeWidgetItem(tree_widget, ['/'])
            root_item.setData(0, Qt.UserRole, mountpoint)
            root_item.setExpanded(True)
            
            # Add top-level folders
            folder_items = {}
            for folder in sorted(folders):
                display = display_name(folder)
                # Get parent path
                parent_path = mountpoint
                if '/' in display:
                    parent_display = '/'.join(display.split('/')[:-1])
                    parent_path = full_path(parent_display)
                
                # Create item
                item = QTreeWidgetItem([display])
                item.setData(0, Qt.UserRole, folder)
                
                # Add placeholder for lazy loading
                placeholder = QTreeWidgetItem(item, ['...'])
                placeholder.setData(0, Qt.UserRole, None)
                
                # Add to appropriate parent
                if parent_path == mountpoint:
                    root_item.addChild(item)
                else:
                    # Find parent item
                    if parent_path in folder_items:
                        folder_items[parent_path].addChild(item)
                    else:
                        root_item.addChild(item)
                
                folder_items[folder] = item
            
            # Function to load subfolders on demand
            def load_subfolders(item):
                if item.childCount() == 1:
                    child = item.child(0)
                    if child.data(0, Qt.UserRole) is None:  # Placeholder
                        parent_path = item.data(0, Qt.UserRole)
                        if parent_path:
                            # Show status message while loading subfolders
                            if hasattr(self, 'status_label'):
                                folder_name = Path(parent_path).name if parent_path else "folder"
                                self.status_label.setText(f"Loading subfolders in {folder_name}...")
                                QApplication.processEvents()
                            
                            # Load subfolders
                            subfolders = self.list_device_subfolders(adb_path, device_id, env, parent_path)
                            item.removeChild(child)  # Remove placeholder
                            for subfolder in sorted(subfolders):
                                display = display_name(subfolder)
                                sub_item = QTreeWidgetItem([display])
                                sub_item.setData(0, Qt.UserRole, subfolder)
                                # Add placeholder for nested subfolders
                                placeholder = QTreeWidgetItem(sub_item, ['...'])
                                placeholder.setData(0, Qt.UserRole, None)
                                item.addChild(sub_item)
                                folder_items[subfolder] = sub_item
                            
                            # Clear status message after loading
                            if hasattr(self, 'status_label'):
                                self.status_label.setText("")
                                QApplication.processEvents()
            
            # Connect expansion signal
            tree_widget.itemExpanded.connect(load_subfolders)
            
            # Select suggested folder if available
            if suggested_folder:
                for i in range(root_item.childCount()):
                    child = root_item.child(i)
                    if child.data(0, Qt.UserRole) == suggested_folder:
                        tree_widget.setCurrentItem(child)
                        break
            
            layout.addWidget(tree_widget)
            
            # Custom folder input
            custom_layout = QHBoxLayout()
            custom_label = QLabel("Or enter custom path:")
            custom_layout.addWidget(custom_label)
            custom_input = QLineEdit()
            custom_input.setPlaceholderText(f"{mountpoint}/example")
            custom_layout.addWidget(custom_input)
            layout.addLayout(custom_layout)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            ok_button = QPushButton("OK")
            cancel_button = QPushButton("Cancel")
            ok_button.clicked.connect(dialog.accept)
            cancel_button.clicked.connect(dialog.reject)
            button_layout.addWidget(ok_button)
            button_layout.addWidget(cancel_button)
            layout.addLayout(button_layout)
            
            # Show dialog
            if dialog.exec() == QDialog.Accepted:
                # Check if custom path was entered
                if custom_input.text().strip():
                    return custom_input.text().strip()
                # Otherwise use selected folder
                selected_item = tree_widget.currentItem()
                if selected_item:
                    path = selected_item.data(0, Qt.UserRole)
                    if path:
                        return path
            
            return None
            
        except Exception as e:
            silent_print(f"Error showing folder selection dialog: {e}")
            import traceback
            traceback.print_exc()
            # Fallback to mountpoint
            mountpoint = "/storage/sdcard0"
            return mountpoint
    
    def _transfer_files_via_usb(self, file_paths, usb_drive_path=None, fallback_try=None):
        """Transfer files/folders to device via USB drive using worker thread (non-blocking)"""
        try:
            from PySide6.QtWidgets import QFileDialog, QMessageBox
            
            # Use auto-detected USB drive if provided, otherwise prompt user
            if usb_drive_path:
                folder_path = usb_drive_path
                silent_print(f"Using auto-detected USB storage drive: {folder_path}")
            else:
                # Ask user to select USB drive or folder location using OS-native file dialog
                folder_path = QFileDialog.getExistingDirectory(
                    self,
                    "Select Y1 USB Drive or Destination Folder",
                    "",
                    QFileDialog.ShowDirsOnly | QFileDialog.DontResolveSymlinks
                )
            
            if not folder_path:
                # User cancelled
                return
            
            # Check if a transfer is already in progress
            if (hasattr(self, 'usb_transfer_worker') and self.usb_transfer_worker and 
                    self.usb_transfer_worker.isRunning()):
                # Add to queue instead of starting immediately
                if not hasattr(self, 'usb_transfer_queue'):
                    self.usb_transfer_queue = []
                self.usb_transfer_queue.append((file_paths, folder_path, fallback_try))
                queue_size = len(self.usb_transfer_queue)
                self.status_label.setText(f"USB transfer queued ({queue_size} in queue). Current transfer in progress...")
                QMessageBox.information(
                    self,
                    "Transfer Queued",
                    f"Your files have been added to the USB transfer queue.\n\n"
                    f"Queue position: {queue_size}\n"
                    f"The transfer will begin automatically after the current transfer completes."
                )
                return
            
            # Show progress
            self.status_label.setText(f"Preparing to transfer {len(file_paths)} item(s) to USB drive...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, len(file_paths))
            self.progress_bar.setValue(0)
            QApplication.processEvents()
            
            # Create and start worker thread for non-blocking USB file transfer
            self.usb_transfer_worker = USBFileTransferWorker(file_paths, folder_path)
            self.usb_transfer_worker.fallback_try = fallback_try
            self.usb_transfer_worker.status_update.connect(self._on_usb_transfer_status)
            self.usb_transfer_worker.progress_update.connect(self._on_usb_transfer_progress)
            self.usb_transfer_worker.completed.connect(self._on_usb_transfer_complete)
            
            # Start worker thread
            self.usb_transfer_worker.start()
                
        except Exception as e:
            silent_print(f"Error starting USB file transfer: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Transfer error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
    
    def _on_usb_transfer_status(self, message):
        """Handle status updates from USBFileTransferWorker"""
        # Add queue information to status if there are queued transfers
        queue_size = len(self.usb_transfer_queue) if hasattr(self, 'usb_transfer_queue') else 0
        if queue_size > 0:
            self.status_label.setText(f"{message} ({queue_size} in queue)")
        else:
            self.status_label.setText(message)
    
    def _on_usb_transfer_progress(self, current, total):
        """Handle progress updates from USBFileTransferWorker"""
        # Ensure progress bar range matches total
        if self.progress_bar.maximum() != total:
            self.progress_bar.setRange(0, total)
        self.progress_bar.setValue(current)
    
    def _on_usb_transfer_complete(self, success, result):
        """Handle completion of USBFileTransferWorker"""
        transferred_count = result.get('transferred_count', 0)
        failed_files = result.get('failed_files', [])
        total = result.get('total', 0)
        usb_drive_path = result.get('usb_drive_path', '')
        auto_detected = usb_drive_path == self._detect_usb_storage_drive()
        fallback_try = None
        original_paths = []
        if hasattr(self, 'usb_transfer_worker') and self.usb_transfer_worker:
            fallback_try = getattr(self.usb_transfer_worker, 'fallback_try', None)
            try:
                original_paths = list(self.usb_transfer_worker.file_paths)
            except Exception:
                original_paths = []
        # Clear worker reference early
        self.usb_transfer_worker = None
        
        retry_triggered = bool(fallback_try == 'adb' and transferred_count < total)
        
        if retry_triggered:
            self.status_label.setText("USB transfer incomplete, trying ADB over USB connection‚Ä¶")
            # Kick off ADB transfer (prevent USB retry loop by marking retry_via)
            QTimer.singleShot(250, lambda paths=list(original_paths): self.transfer_files_to_device(paths, retry_via='usb'))
        else:
            # Hide progress bar when no retry
            self.progress_bar.setVisible(False)
        
        # Show completion message
        if not retry_triggered:
            if transferred_count == total and success:
                self.status_label.setText(f"Successfully transferred {transferred_count} item(s) to USB drive")
                if not auto_detected:
                    QMessageBox.information(
                        self,
                        "Transfer Complete",
                        f"Successfully transferred {transferred_count} item(s) to:\n\n{usb_drive_path}"
                    )
            elif transferred_count > 0:
                self.status_label.setText(f"Transferred {transferred_count} of {total} item(s)")
                failed_list = '\n'.join(failed_files)
                QMessageBox.warning(
                    self,
                    "Transfer Partially Complete",
                    f"Transferred {transferred_count} of {total} item(s) to:\n\n{usb_drive_path}\n\n"
                    f"Failed items:\n{failed_list}"
                )
            else:
                self.status_label.setText("USB transfer failed")
                failed_list = '\n'.join(failed_files)
                QMessageBox.warning(
                    self,
                    "Transfer Failed",
                    f"Failed to transfer all items to:\n\n{usb_drive_path}\n\n"
                    f"Failed items:\n{failed_list}"
                )
        
        # Process next item in queue if available
        self._process_next_queued_usb_transfer()
        if retry_triggered:
            # Make sure cleanup continues when retry chain finishes
            return
    
    def _process_next_queued_usb_transfer(self):
        """Process the next item in the USB file transfer queue"""
        if not hasattr(self, 'usb_transfer_queue'):
            self.usb_transfer_queue = []
        
        if self.usb_transfer_queue:
            # Get next item from queue
            file_paths, usb_drive_path, fallback_try = self.usb_transfer_queue.pop(0)
            silent_print(f"Processing queued USB transfer: {len(file_paths)} file(s)")
            
            # Start the next transfer
            QTimer.singleShot(500, lambda: self._transfer_files_via_usb(file_paths, usb_drive_path, fallback_try))

    def open_wifi_connect_dialog(
        self,
        adb_path_override=None,
        device_id_override=None,
        env_override=None,
    ):
        """Open the Wi-Fi picker for Y1 devices and configure wpa_supplicant via ADB."""
        from PySide6.QtWidgets import (
            QDialog,
            QVBoxLayout,
            QLabel,
            QListWidget,
            QListWidgetItem,
            QPushButton,
            QLineEdit,
            QHBoxLayout,
            QMessageBox,
            QCheckBox,
        )
        
        # Resolve ADB context
        if adb_path_override and device_id_override and env_override:
            adb_path = Path(adb_path_override)
            device_id = device_id_override
            env = env_override
        else:
            ready, snapshot = self._ensure_adb_capability("root", "Connect to Wi-Fi via ADB")
            if not ready:
                return
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB is required to configure Wi-Fi over USB.")
                return
            env = self._build_adb_environment()
            device_id = snapshot.get("active_device_id") or snapshot.get("device_id")
        
        if not device_id:
            QMessageBox.warning(self, "Device Not Connected", "No rooted Y1 was detected over ADB.")
            return
        
        if device_id != "0123456789ABCDEF":
            QMessageBox.warning(
                self,
                "Unsupported Device",
                "This Wi-Fi setup tool is designed for the Innioasis Y1. "
                "Connect a Y1 over USB with root ADB enabled to continue.",
            )
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Connect Y1 to Wi-Fi")
        dialog.setMinimumWidth(520)
        layout = QVBoxLayout(dialog)
        
        intro = QLabel(
            "Pick your Wi-Fi network and Updater will configure the Y1 automatically. "
            "We refresh the list every 10 seconds."
        )
        intro.setWordWrap(True)
        layout.addWidget(intro)
        
        status_label = QLabel("Scanning for networks‚Ä¶")
        layout.addWidget(status_label)
        
        network_list = QListWidget()
        layout.addWidget(network_list)
        
        # Connection status indicator
        connection_status = QLabel("Current Wi-Fi status: unknown")
        layout.addWidget(connection_status)
        
        # Manual entry fields
        ssid_row = QHBoxLayout()
        ssid_label = QLabel("SSID:")
        ssid_input = QLineEdit()
        ssid_input.setPlaceholderText("Exact network name")
        ssid_row.addWidget(ssid_label)
        ssid_row.addWidget(ssid_input)
        layout.addLayout(ssid_row)
        
        password_row = QHBoxLayout()
        password_label = QLabel("Password:")
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.Password)
        password_row.addWidget(password_label)
        password_row.addWidget(password_input)
        layout.addLayout(password_row)
        
        show_password = QCheckBox("Show password")
        show_password.toggled.connect(
            lambda checked: password_input.setEchoMode(QLineEdit.Normal if checked else QLineEdit.Password)
        )
        layout.addWidget(show_password)
        
        # Button row
        button_row = QHBoxLayout()
        refresh_btn = QPushButton("Refresh")
        settings_btn = QPushButton("Open Wi-Fi Settings on Y1")
        connect_btn = QPushButton("Connect")
        close_btn = QPushButton("Close")
        button_row.addWidget(refresh_btn)
        button_row.addWidget(settings_btn)
        button_row.addStretch()
        button_row.addWidget(close_btn)
        button_row.addWidget(connect_btn)
        layout.addLayout(button_row)
        
        # Track currently scheduled futures so we can clean them up
        def _track_future(fut):
            self._active_wifi_scan_futures.add(fut)
            def _cleanup(_):
                self._active_wifi_scan_futures.discard(fut)
            fut.add_done_callback(_cleanup)
            return fut
        
        def populate_networks(networks):
            network_list.clear()
            for net in networks:
                ssid = net.get("ssid") or "(hidden network)"
                signal = net.get("signal") or ""
                display = f"{ssid}  {signal}"
                item = QListWidgetItem(display)
                item.setData(Qt.UserRole, net)
                network_list.addItem(item)
            status_label.setText(
                "Select a network and click Connect."
                if networks
                else "No networks detected yet‚Äîcheck your router or try again."
            )
            refresh_btn.setEnabled(True)
        
        def schedule_status_update():
            fut = _track_future(
                self._wifi_scan_executor.submit(
                    self._get_wifi_connection_snapshot,
                    adb_path,
                    device_id,
                    env,
                )
            )
            def finished(future):
                snapshot = future.result()
                def update_label():
                    if snapshot:
                        ssid = snapshot.get("ssid") or "not connected"
                        state = snapshot.get("state") or "unknown"
                        rssi = snapshot.get("rssi")
                        detail = f"{state}"
                        if rssi is not None:
                            detail += f", RSSI {rssi} dBm"
                        connection_status.setText(f"Current Wi-Fi status: {ssid} ({detail})")
                    else:
                        connection_status.setText("Current Wi-Fi status: unknown")
                QTimer.singleShot(0, update_label)
            fut.add_done_callback(finished)
        
        def refresh_networks(manual=False):
            refresh_btn.setEnabled(False)
            if manual:
                status_label.setText("Scanning for networks‚Ä¶")
            fut = _track_future(
                self._wifi_scan_executor.submit(
                    self._get_wifi_networks_via_adb,
                    adb_path,
                    device_id,
                    env,
                )
            )
            def finished(future):
                networks = future.result()
                def update():
                    populate_networks(networks)
                QTimer.singleShot(0, update)
            fut.add_done_callback(finished)
        
        def on_selection_changed():
            item = network_list.currentItem()
            if item:
                data = item.data(Qt.UserRole) or {}
                ssid = data.get("ssid")
                if ssid:
                    ssid_input.setText(ssid)
                    ssid_input.setCursorPosition(len(ssid))
        network_list.itemSelectionChanged.connect(on_selection_changed)
        
        def attempt_connect():
            ssid = ssid_input.text().strip()
            password = password_input.text()
            if not ssid:
                QMessageBox.warning(dialog, "Missing SSID", "Select a network or enter an SSID to continue.")
                return
            
            selected_item = network_list.currentItem()
            selected_data = selected_item.data(Qt.UserRole) if selected_item else {}
            bssid = selected_data.get("bssid")
            
            connect_btn.setEnabled(False)
            status_label.setText("Configuring Wi-Fi on your Y1‚Ä¶")
            
            fut = _track_future(
                self._wifi_scan_executor.submit(
                    self._configure_wifi_network_on_y1,
                    adb_path,
                    device_id,
                    env,
                    ssid,
                    password,
                    bssid,
                )
            )
            
            def finished(future):
                success, message = future.result()
                def update():
                    connect_btn.setEnabled(True)
                    if success:
                        QMessageBox.information(dialog, "Wi-Fi", message or "Wi-Fi profile saved.")
                        status_label.setText("Waiting for the Y1 to join Wi-Fi‚Ä¶")
                        schedule_status_update()
                    else:
                        QMessageBox.warning(dialog, "Wi-Fi", message or "Unable to configure Wi-Fi.")
                        status_label.setText("Try again or choose a different network.")
                    refresh_networks()
                QTimer.singleShot(0, update)
            fut.add_done_callback(finished)
        
        def launch_wifi_settings():
            ok, msg = self._launch_wifi_settings_on_y1(adb_path, device_id, env)
            if ok:
                status_label.setText("Opened Wi-Fi settings on your Y1. Connect there, then return to finish.")
            else:
                QMessageBox.warning(dialog, "Wi-Fi Settings", msg or "Unable to open Wi-Fi settings on the device.")
        
        refresh_btn.clicked.connect(lambda: refresh_networks(manual=True))
        settings_btn.clicked.connect(launch_wifi_settings)
        connect_btn.clicked.connect(attempt_connect)
        close_btn.clicked.connect(dialog.reject)
        
        # Timers to keep data fresh
        refresh_timer = QTimer(dialog)
        refresh_timer.setInterval(10000)
        refresh_timer.timeout.connect(refresh_networks)
        refresh_timer.start()
        
        status_timer = QTimer(dialog)
        status_timer.setInterval(5000)
        status_timer.timeout.connect(schedule_status_update)
        status_timer.start()
        
        def cleanup():
            refresh_timer.stop()
            status_timer.stop()
            for fut in list(self._active_wifi_scan_futures):
                fut.cancel()
        
        dialog.finished.connect(cleanup)
        
        refresh_networks()
        schedule_status_update()
        dialog.exec()
    
    def _get_wifi_networks_via_adb(self, adb_path, device_id, env):
        """Retrieve Wi-Fi scan results via adb shell (root). Supports Android 4.2.2+."""
        def _merge_network(result_map, entry):
            if not entry:
                return
            ssid = (entry.get('ssid') or "").strip()
            bssid = (entry.get('bssid') or "").strip().lower()
            key = (ssid.lower(), bssid)
            signal_value = _extract_signal_value(entry.get('signal') or entry.get('level'))
            entry = dict(entry)
            if signal_value > -200 and not entry.get('signal'):
                entry['signal'] = f"{signal_value} dBm"
            existing = result_map.get(key)
            if existing is None or signal_value > _extract_signal_value(existing.get('signal')):
                result_map[key] = entry
            elif existing is not None:
                # Preserve any metadata like flags
                for meta_key in ('flags', 'frequency', 'channel'):
                    if meta_key not in existing or not existing[meta_key]:
                        existing[meta_key] = entry.get(meta_key)

        result_map = {}
        adb_base = [str(adb_path), '-s', device_id, 'shell', 'su', '-c']

        # Kick off a scan using the legacy broadcast (works on Android 4.2.2)
        try:
            subprocess.run(
                [str(adb_path), '-s', device_id, 'shell', 'am', 'broadcast', '-a', 'android.net.wifi.SCAN_RESULTS'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
        except Exception as broadcast_error:
            silent_print(f"Wi-Fi broadcast scan trigger failed: {broadcast_error}")

        # Also try the cmd wifi start-scan call (no harm if unavailable)
        try:
            subprocess.run(
                adb_base + ['cmd wifi start-scan'],
                capture_output=True,
                text=True,
                timeout=6,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
        except Exception:
            pass

        time.sleep(3)

        # Gather results from cmd wifi list-scan-results
        try:
            result = subprocess.run(
                adb_base + ['cmd wifi list-scan-results'],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode == 0 and result.stdout:
                for entry in self._parse_cmd_wifi_scan(result.stdout):
                    _merge_network(result_map, entry)
        except Exception as cmd_error:
            silent_print(f"Wi-Fi cmd wifi scan error (expected on Android <5.0): {cmd_error}")

        # Parse dumpsys wifi, which is authoritative on Android 4.2.2
        try:
            dumpsys = subprocess.run(
                [str(adb_path), '-s', device_id, 'shell', 'dumpsys', 'wifi'],
                capture_output=True,
                text=True,
                timeout=12,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if dumpsys.returncode == 0 and dumpsys.stdout:
                for entry in self._parse_dumpsys_wifi_scan(dumpsys.stdout):
                    _merge_network(result_map, entry)
        except Exception as dumpsys_error:
            silent_print(f"Wi-Fi dumpsys scan error: {dumpsys_error}")

        # Fallback to wpa_cli where available
        try:
            subprocess.run(
                adb_base + ['wpa_cli -i wlan0 scan'],
                capture_output=True,
                text=True,
                timeout=8,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            time.sleep(1.5)
            fallback = subprocess.run(
                adb_base + ['wpa_cli -i wlan0 scan_results'],
                capture_output=True,
                text=True,
                timeout=8,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if fallback.returncode == 0 and fallback.stdout:
                for entry in self._parse_wpa_cli_scan(fallback.stdout):
                    _merge_network(result_map, entry)
        except Exception as wpa_error:
            silent_print(f"Wi-Fi wpa_cli scan error: {wpa_error}")

        networks = list(result_map.values())
        networks.sort(key=lambda entry: (-_extract_signal_value(entry.get('signal')), (entry.get('ssid') or '').lower()))
        return networks

    def get_host_wifi_ssid(self):
        """Return the SSID of the computer's current Wi-Fi connection if accessible."""
        try:
            system = platform.system()
            if system == "Darwin":
                # Discover Wi-Fi interface
                list_ports = subprocess.run(
                    ["networksetup", "-listallhardwareports"],
                    capture_output=True,
                    text=True,
                    timeout=5,
                )
                if list_ports.returncode != 0 or not list_ports.stdout:
                    return None
                device_name = None
                lines = list_ports.stdout.splitlines()
                for idx, line in enumerate(lines):
                    if line.strip() == "Hardware Port: Wi-Fi":
                        # The following lines contain Device and Ethernet Address
                        for needle in lines[idx + 1: idx + 4]:
                            if needle.strip().startswith("Device:"):
                                device_name = needle.split("Device:", 1)[1].strip()
                                break
                        if device_name:
                            break
                if not device_name:
                    # Fall back to common defaults
                    device_name = "en0"
                airport = subprocess.run(
                    ["networksetup", "-getairportnetwork", device_name],
                    capture_output=True,
                    text=True,
                    timeout=5,
                )
                if airport.returncode == 0 and airport.stdout:
                    if "Current Wi-Fi Network" in airport.stdout:
                        return airport.stdout.split(":", 1)[1].strip() or None
            elif system == "Windows":
                netsh = subprocess.run(
                    ["netsh", "wlan", "show", "interfaces"],
                    capture_output=True,
                    text=True,
                    timeout=5,
                    creationflags=subprocess.CREATE_NO_WINDOW if hasattr(subprocess, "CREATE_NO_WINDOW") else 0,
                )
                if netsh.returncode == 0 and netsh.stdout:
                    connected = False
                    ssid_line = None
                    for line in netsh.stdout.splitlines():
                        line = line.strip()
                        if line.lower().startswith("state"):
                            connected = "connected" in line.lower()
                        if connected and line.lower().startswith("ssid"):
                            # SSID : value
                            parts = line.split(":", 1)
                            if len(parts) == 2:
                                ssid_line = parts[1].strip()
                                break
                    if connected and ssid_line:
                        return ssid_line or None
        except Exception as exc:
            silent_print(f"Host Wi-Fi SSID detection failed: {exc}")
        return None
    
    def _launch_adb_wifi_app_main_activity(self, adb_path, device_id, env):
        """Launch ADB Wi-Fi Reborn on the device to surface first-run dialogs."""
        try:
            result = subprocess.run(
                [
                    str(adb_path),
                    "-s",
                    device_id,
                    "shell",
                    "monkey",
                    "-p",
                    "com.ryosoftware.adbw",
                    "-c",
                    "android.intent.category.LAUNCHER",
                    "1",
                ],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            launched = result.returncode == 0
            if not launched:
                silent_print(
                    "ADB Wi-Fi Reborn launch returned non-zero code: "
                    f"{result.returncode} :: {result.stdout or result.stderr}"
                )
            return launched
        except Exception as exc:
            silent_print(f"Failed to launch ADB Wi-Fi Reborn automatically: {exc}")
            return False
    
    def _launch_wifi_settings_on_y1(self, adb_path, device_id, env):
        """Open the standard Android Wi-Fi settings screen on the Y1."""
        try:
            result = subprocess.run(
                [
                    str(adb_path),
                    "-s",
                    device_id,
                    "shell",
                    "am",
                    "start",
                    "-a",
                    "android.settings.WIFI_SETTINGS",
                ],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode == 0:
                return True, "Wi-Fi settings opened on the Y1."
            message = result.stderr or result.stdout or "Unable to open Wi-Fi settings."
            return False, message.strip()
        except Exception as exc:
            silent_print(f"Failed to open Wi-Fi settings: {exc}")
            return False, str(exc)
    
    def _enable_wifi_radio_on_y1(self, adb_path, device_id, env):
        """Enable the Wi-Fi radio on the Y1 via ADB."""
        try:
            result = subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "svc", "wifi", "enable"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode == 0:
                return True, "Wi-Fi enabled."
            message = result.stderr or result.stdout or "Unable to enable Wi-Fi."
            return False, message.strip()
        except Exception as exc:
            silent_print(f"Failed to enable Wi-Fi radio: {exc}")
            return False, str(exc)
    
    def _disable_wifi_radio_on_y1(self, adb_path, device_id, env):
        """Disable the Wi-Fi radio on the Y1 via ADB."""
        try:
            result = subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "svc", "wifi", "disable"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode == 0:
                return True, "Wi-Fi disabled."
            message = result.stderr or result.stdout or "Unable to disable Wi-Fi."
            return False, message.strip()
        except Exception as exc:
            silent_print(f"Failed to disable Wi-Fi radio: {exc}")
            return False, str(exc)
    
    def _check_adb_wifi_reborn_installed(self, adb_path, device_id, env):
        """Return True if ADB Wi-Fi Reborn is installed on the device."""
        try:
            result = subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "pm", "list", "packages", "com.ryosoftware.adbw"],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            return result.returncode == 0 and "com.ryosoftware.adbw" in (result.stdout or "")
        except Exception as exc:
            silent_print(f"Failed to check ADB Wi-Fi package: {exc}")
            return False
    
    class _WirelessWifiDialog(QDialog):
        networks_ready = Signal(object)

        def __init__(self, parent=None):
            super().__init__(parent)


    def open_wireless_wifi_dialog(self, adb_path_override=None, device_id_override=None, env_override=None):
        """Launch the standalone Wireless Wi-Fi configuration dialog."""
        from PySide6.QtWidgets import (
            QDialog,
            QVBoxLayout,
            QLabel,
            QListWidget,
            QListWidgetItem,
            QHBoxLayout,
            QPushButton,
            QLineEdit,
            QMessageBox,
            QCheckBox,
            QDialogButtonBox,
        )

        context_cache = {'adb_path': None, 'device_id': None, 'env': None}
        if adb_path_override and device_id_override and env_override:
            context_cache['adb_path'] = Path(adb_path_override)
            context_cache['device_id'] = device_id_override
            context_cache['env'] = env_override
        else:
            ready, snapshot = self._ensure_adb_capability('root', "configure Y1 Wi-Fi")
            if not ready:
                return
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB is required to configure Wi-Fi on your Y1.")
                return
            env = self._build_adb_environment()
            device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            if not device_id:
                QMessageBox.warning(self, "Device Not Connected", "Connect your Y1 with the Wi-Fi helper over USB to continue.")
                return
            if device_id != "0123456789ABCDEF":
                QMessageBox.warning(
                    self,
                    "Unsupported Device",
                    "These Wi-Fi tools are intended for the Innioasis Y1. Connect a Y1 over USB to continue."
                )
                return
            context_cache['adb_path'] = Path(adb_path)
            context_cache['device_id'] = device_id
            context_cache['env'] = env

        dialog = self._WirelessWifiDialog(self)
        dialog.setWindowTitle("Wireless ADB Wi-Fi on Y1")
        dialog.setMinimumWidth(520)
        layout = QVBoxLayout(dialog)
        self._last_wifi_dialog = dialog
        dialog._network_presence = getattr(dialog, "_network_presence", {})
        dialog._last_snapshot_id = getattr(dialog, "_last_snapshot_id", 0)
        dialog._last_emitted_snapshot = getattr(dialog, "_last_emitted_snapshot", 0)

        intro = QLabel(
            "Turn on your Y1‚Äôs Wi-Fi to connect it to a network so Fast Update and Smart Drop can run wirelessly. "
            "Keep the device connected over USB while we configure it."
        )
        intro.setWordWrap(True)
        layout.addWidget(intro)

        status_label = QLabel("")
        status_label.setVisible(False)
        layout.addWidget(status_label)
        dialog.status_label = status_label

        refresh_btn = QPushButton("Refresh Networks")
        refresh_btn.setToolTip("Scan your Y1 for nearby Wi-Fi networks")
        refresh_btn.setEnabled(False)
        layout.addWidget(refresh_btn)

        networks_subtitle = QLabel("Networks: scanning‚Ä¶")
        networks_subtitle.setStyleSheet("font-size: 12px; color: #aaaaaa; margin: 4px 0;")
        layout.addWidget(networks_subtitle)
        dialog.networks_subtitle = networks_subtitle

        connected_status_label = QLabel("")
        connected_status_label.setStyleSheet("font-size: 12px; color: #4c8ed9; margin: 0 0 6px 0;")
        connected_status_label.setVisible(False)
        layout.addWidget(connected_status_label)
        dialog.connected_status_label = connected_status_label

        network_list = QListWidget()
        network_list.setMinimumHeight(200)
        network_list.setAlternatingRowColors(True)
        network_list.setSelectionMode(QListWidget.SingleSelection)
        layout.addWidget(network_list)
        dialog.network_list_widget = network_list
        dialog.current_connected_identity = getattr(dialog, "current_connected_identity", None)

        wifi_controls_widget = QWidget()
        wifi_controls_layout = QVBoxLayout(wifi_controls_widget)
        wifi_controls_layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(wifi_controls_widget)

        manual_label = QLabel("Network Details:")
        wifi_controls_layout.addWidget(manual_label)

        ssid_row_widget = QWidget()
        ssid_row_layout = QHBoxLayout(ssid_row_widget)
        ssid_row_layout.setContentsMargins(0, 0, 0, 0)
        ssid_label = QLabel("SSID:")
        ssid_input = QLineEdit()
        ssid_input.setPlaceholderText("Exact network name")
        ssid_row_layout.addWidget(ssid_label)
        ssid_row_layout.addWidget(ssid_input)
        wifi_controls_layout.addWidget(ssid_row_widget)

        password_row_widget = QWidget()
        password_row_layout = QHBoxLayout(password_row_widget)
        password_row_layout.setContentsMargins(0, 0, 0, 0)
        password_label = QLabel("Password:")
        password_input = QLineEdit()
        password_input.setEchoMode(QLineEdit.Password)
        password_row_layout.addWidget(password_label)
        password_row_layout.addWidget(password_input)
        wifi_controls_layout.addWidget(password_row_widget)

        show_password = QCheckBox("Show password")
        show_password.toggled.connect(
            lambda checked: password_input.setEchoMode(QLineEdit.Normal if checked else QLineEdit.Password)
        )
        wifi_controls_layout.addWidget(show_password)

        button_row = QHBoxLayout()
        wifi_settings_btn = QPushButton("Manage Saved Networks")
        connect_btn = QPushButton("Connect Y1 to Wi-Fi")
        button_row.addWidget(wifi_settings_btn)
        button_row.addStretch()
        button_row.addWidget(connect_btn)
        wifi_controls_layout.addLayout(button_row)
        dialog.refresh_button = refresh_btn
        dialog.manage_networks_button = wifi_settings_btn
        dialog.connect_button = connect_btn

        dialog.ssid_input = ssid_input
        dialog.password_input = password_input

        buttons = QDialogButtonBox(QDialogButtonBox.Close)
        buttons.rejected.connect(dialog.reject)
        layout.addWidget(buttons)

        local_futures = set()
        last_selected_key = None
        dialog._wifi_enabled = False
        dialog._wifi_state_known = False
        dialog._context_ready = bool(all(context_cache.values()))

        def prefill_host_ssid():
            if ssid_input.text().strip():
                return
            host_ssid = self.get_host_wifi_ssid()
            if host_ssid:
                ssid_input.setText(host_ssid)
                ssid_input.setCursorPosition(len(host_ssid))

        def _network_identity(data):
            if not data:
                return None
            group_key = (data.get("group_key") or "").strip()
            if group_key:
                return group_key
            bssid = (data.get("bssid") or "").strip().lower()
            if bssid:
                return f"bssid:{bssid}"
            ssid = (data.get("ssid") or "").strip()
            if ssid:
                freq = data.get("frequency") or data.get("channel") or ""
                return f"ssid:{ssid.lower()}::{freq}"
            signal = data.get("signal") or data.get("level")
            frequency = data.get("frequency") or data.get("channel")
            return f"hidden::{frequency}::{signal}"

        def set_controls_enabled(enabled):
            wifi_settings_btn.setEnabled(enabled)
            connect_btn.setEnabled(enabled)
            ssid_input.setEnabled(enabled)
            password_input.setEnabled(enabled)
            show_password.setEnabled(enabled)
            network_list.setEnabled(enabled)
            wifi_controls_widget.setEnabled(enabled)

        set_controls_enabled(False)

        def set_wifi_controls_visible(visible):
            network_list.setVisible(visible)
            wifi_controls_widget.setEnabled(visible)
            if not visible:
                connect_btn.setEnabled(False)
                ssid_input.setEnabled(False)
                password_input.setEnabled(False)
                show_password.setEnabled(False)
                networks_subtitle.setText("Wi-Fi radio off")
            else:
                connect_btn.setEnabled(True)
                ssid_input.setEnabled(True)
                password_input.setEnabled(True)
                show_password.setEnabled(True)
                if dialog.current_connected_identity:
                    networks_subtitle.setText("Connected to network")
                else:
                    networks_subtitle.setText("Networks: scanning‚Ä¶")

        def track_future(fut):
            local_futures.add(fut)
            def _cleanup(_):
                local_futures.discard(fut)
            fut.add_done_callback(_cleanup)
            return fut

        dialog._usb_connected = getattr(dialog, "_usb_connected", False)

        def ensure_wifi_context(show_dialog=True):
            if all(context_cache.values()):
                dialog._context_ready = True
                set_controls_enabled(True)
                refresh_btn.setEnabled(True)
                status_label.setText("Status: Ready‚Äîrefresh to update.")
                dialog._usb_connected = True
                return True

            ready, snapshot = self._ensure_adb_capability('root', "configure Y1 Wi-Fi")
            if not ready:
                dialog._context_ready = False
                refresh_btn.setEnabled(False)
                set_controls_enabled(False)
                set_wifi_controls_visible(False)
                status_label.setText("Status: Waiting for your Y1 with Wi-Fi helper over USB.")
                if dialog._usb_connected:
                    dialog._usb_connected = False
                    QMessageBox.information(
                        dialog,
                        "USB Disconnected",
                        "The USB ADB connection to your Y1 was lost. Reconnect the USB cable to continue configuring Wi-Fi."
                    )
                    dialog.reject()
                return False

            adb_path = self.find_adb_executable()
            if not adb_path:
                dialog._context_ready = False
                refresh_btn.setEnabled(False)
                set_controls_enabled(False)
                if show_dialog:
                    QMessageBox.warning(dialog, "ADB Not Found", "ADB is required to configure Wi-Fi.")
                return False

            env = self._build_adb_environment()
            device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            if not device_id:
                dialog._context_ready = False
                refresh_btn.setEnabled(False)
                set_controls_enabled(False)
                status_label.setText("Status: Waiting for your Y1 with Wi-Fi helper over USB.")
                return False

            if device_id != "0123456789ABCDEF":
                dialog._context_ready = False
                refresh_btn.setEnabled(False)
                set_controls_enabled(False)
                status_label.setText("Status: Unsupported device connected.")
                if show_dialog:
                    QMessageBox.warning(
                        dialog,
                        "Unsupported Device",
                        "These tools are intended for the Innioasis Y1. Connect a Y1 over USB to continue."
                    )
                return False

            context_cache['adb_path'] = Path(adb_path)
            context_cache['env'] = env
            context_cache['device_id'] = device_id
            dialog._context_ready = True
            set_controls_enabled(True)
            refresh_btn.setEnabled(True)
            status_label.setText("Status: Ready‚Äîrefresh to update.")
            dialog._usb_connected = True
            return True

        def populate_networks(networks):
            nonlocal last_selected_key
            dialog._last_snapshot_id += 1
            current_snapshot = dialog._last_snapshot_id

            filtered_networks = []
            for net in networks:
                ssid_val = (net.get("ssid") or "").strip()
                if ssid_val.upper().startswith("NVRAM WARNING: ERR"):
                    continue
                filtered_networks.append(net)
            networks = filtered_networks

            grouped = {}
            presence_map = dialog._network_presence
            for key in list(presence_map.keys()):
                presence_map[key]["seen"] = False
            hidden_counter = 0
            for net in networks:
                ssid_raw = (net.get("ssid") or "").strip()
                bssid_raw = (net.get("bssid") or "").strip()
                freq = net.get("frequency") or net.get("channel")
                signal_val = _extract_signal_value(net.get("signal") or net.get("level"))
                signal_text = f"{signal_val} dBm" if signal_val > -200 else (net.get("signal") or "").strip()
                if ssid_raw:
                    key = f"ssid:{ssid_raw.lower()}"
                elif bssid_raw:
                    key = f"bssid:{bssid_raw.lower()}"
                else:
                    key = f"hidden:{hidden_counter}"
                    hidden_counter += 1
                existing = grouped.get(key)
                display_ssid = ssid_raw if ssid_raw else "(hidden network)"
                entry = {
                    'ssid': ssid_raw,
                    'display_ssid': display_ssid,
                    'bssid': bssid_raw,
                    'frequency': freq,
                    'signal_value': signal_val,
                    'signal': signal_text,
                    'flags': net.get('flags'),
                    'group_key': key,
                    'sources': [net],
                }
                meta = presence_map.setdefault(key, {
                    "count": 0,
                    "last_snapshot": current_snapshot,
                    "seen": True,
                    "data": dict(entry),
                })
                meta["seen"] = True
                meta["last_snapshot"] = current_snapshot
                if existing is None or signal_val > existing['signal_value']:
                    if existing and 'sources' in existing:
                        entry['sources'] = existing['sources'] + [net]
                    grouped[key] = entry
                    meta["data"] = dict(entry)
                else:
                    existing.setdefault('sources', []).append(net)

            aggregated_networks = list(grouped.values())
            for key in list(presence_map.keys()):
                if not presence_map[key].get("seen"):
                    presence_map[key]["count"] += 1
                else:
                    presence_map[key]["count"] = 0
                if presence_map[key].get("count", 0) >= 3:
                    continue
                if key not in grouped:
                    cached_entry = presence_map[key].get("data")
                    if cached_entry:
                        aggregated_networks.append(dict(cached_entry))

            aggregated_networks.sort(
                key=lambda item: (-item.get('signal_value', -200), item.get('display_ssid', '').lower())
            )

            selected_key = None
            current_item = network_list.currentItem()
            if current_item:
                selected_key = _network_identity(current_item.data(Qt.UserRole) or {})
            if not selected_key:
                selected_key = last_selected_key
            scroll_value = network_list.verticalScrollBar().value() if network_list.count() else 0

            network_list.setUpdatesEnabled(False)
            network_list.clear()
            newly_selected_item = None

            if not aggregated_networks:
                placeholder = QListWidgetItem("No networks found")
                placeholder.setData(Qt.UserRole, {"placeholder": True})
                network_list.addItem(placeholder)
                dialog.networks_subtitle.setText("0 available networks")
                status_label.setText("Status: No Wi-Fi networks detected. Move your Y1 closer to the router and refresh.")
                refresh_btn.setEnabled(True)
                network_list.setUpdatesEnabled(True)
                last_selected_key = None
                dialog._network_presence = presence_map
                return

            connected_identity = getattr(dialog, "current_connected_identity", None)
            for agg in aggregated_networks:
                display_name = agg.get("display_ssid") or "(hidden network)"
                signal_display = (agg.get("signal") or "").strip()
                strength = agg.get("signal_value", -200)
                if strength >= -50:
                    strength_text = "Excellent"
                elif strength >= -65:
                    strength_text = "Good"
                elif strength >= -75:
                    strength_text = "Fair"
                elif strength > -90:
                    strength_text = "Weak"
                else:
                    strength_text = "Very weak"
                flags = agg.get("flags") or ""
                security = "Open"
                if flags:
                    upper_flags = flags.upper()
                    if "WPA3" in upper_flags:
                        security = "WPA3"
                    elif "WPA2" in upper_flags and "WPA" in upper_flags:
                        security = "WPA/WPA2"
                    elif "WPA2" in upper_flags:
                        security = "WPA2"
                    elif "WPA" in upper_flags:
                        security = "WPA"
                    elif "WEP" in upper_flags:
                        security = "WEP"
                identity = _network_identity(agg)
                is_connected = identity and identity == connected_identity
                display_entry = dict(agg)
                display_entry["security_label"] = security
                display_entry["is_open"] = (security == "Open")
                display_entry["signal_strength_text"] = strength_text
                display_entry["connected"] = bool(is_connected)
                parts = [
                    display_name,
                    f"Security: {security}",
                    f"Signal: {strength_text}{f' ({signal_display})' if signal_display else ''}",
                ]
                if is_connected:
                    parts.append("Status: Connected")
                display = " ¬∑ ".join(part for part in parts if part)
                item = QListWidgetItem(display)
                item.setData(Qt.UserRole, display_entry)
                network_list.addItem(item)

                if is_connected:
                    item.setSelected(True)
                    network_list.setCurrentItem(item)
                    newly_selected_item = item
                    last_selected_key = identity
                if selected_key and identity == selected_key:
                    network_list.setCurrentItem(item)
                    newly_selected_item = item

            if not newly_selected_item and network_list.count() and selected_key is None and last_selected_key is None:
                network_list.setCurrentRow(0)
                newly_selected_item = network_list.currentItem()

            network_list.setUpdatesEnabled(True)
            if scroll_value and network_list.verticalScrollBar().maximum():
                network_list.verticalScrollBar().setValue(min(scroll_value, network_list.verticalScrollBar().maximum()))

            dialog.networks_subtitle.setText(f"{len(aggregated_networks)} available networks")
            refresh_btn.setEnabled(True)

            if newly_selected_item:
                last_selected_key = _network_identity(newly_selected_item.data(Qt.UserRole) or {})
                post_selection()
            elif not network_list.currentItem():
                last_selected_key = None
            dialog._network_presence = presence_map

        def apply_wifi_state(enabled):
            nonlocal last_selected_key
            enabled = bool(enabled)
            dialog._wifi_enabled = enabled
            dialog._wifi_state_known = True
            if not enabled:
                network_list.setVisible(False)
                last_selected_key = None
                network_list.clear()
                ssid_input.clear()
                password_input.clear()
                show_password.setChecked(False)
                status_label.setText("Status: Y1 Wi-Fi appears to be off. Turn Wi-Fi on from the device, then refresh.")
                dialog.networks_subtitle.setText("Wi-Fi radio off")
                connected_status_label.setVisible(False)
                connected_status_label.setText("")
            else:
                network_list.setVisible(True)
                wifi_controls_widget.setEnabled(True)
                if dialog.current_connected_identity:
                    dialog.networks_subtitle.setText("Connected to network")
                else:
                    dialog.networks_subtitle.setText("Networks: scanning‚Ä¶")

        def update_status(snapshot):
            if snapshot:
                wifi_enabled = snapshot.get("wifi_enabled")
                apply_wifi_state(wifi_enabled)
                if wifi_enabled:
                    ssid = snapshot.get("ssid") or "not connected"
                    state = snapshot.get("state") or "unknown"
                    rssi = snapshot.get("rssi")
                    detail = state
                    if rssi is not None:
                        detail += f", RSSI {rssi} dBm"
                    identity = None
                    bssid = snapshot.get("bssid")
                    if bssid:
                        identity = f"bssid:{bssid.lower()}"
                    elif snapshot.get("ssid"):
                        identity = f"ssid:{snapshot.get('ssid').lower()}"
                    dialog.current_connected_identity = identity
                    connected_status_label.setVisible(True)
                    state_upper = (snapshot.get("state") or "").upper()
                    if state_upper == "COMPLETED" and snapshot.get("ssid"):
                        connected_status_label.setText(f'Currently connected: "{ssid}" ({detail})')
                    else:
                        connected_status_label.setText(f"Currently connected: not connected ({state})")
                else:
                    dialog.current_connected_identity = None
                    connected_status_label.setVisible(True)
                    connected_status_label.setText("Currently connected: not connected")
            else:
                dialog.current_connected_identity = None
                apply_wifi_state(False)
                connected_status_label.setVisible(False)
                connected_status_label.setText("")

        def refresh_status(show_dialog=False):
            if not ensure_wifi_context(show_dialog=show_dialog):
                return
            fut = track_future(
                self._wifi_scan_executor.submit(
                    self._get_wifi_connection_snapshot,
                    context_cache['adb_path'],
                    context_cache['device_id'],
                    context_cache['env'],
                )
            )
            def finished(future):
                snapshot = future.result()
                QTimer.singleShot(0, lambda: update_status(snapshot))
            fut.add_done_callback(finished)

        def refresh_networks(manual=False):
            silent_print(f"refresh_networks called (manual={manual})")
            context_ready = ensure_wifi_context(show_dialog=manual)
            if not context_ready:
                return
            if dialog._wifi_state_known and not dialog._wifi_enabled and not manual:
                status_label.setText("Status: Y1 Wi-Fi appears to be off. Turn Wi-Fi on from the device, then refresh.")
                dialog.networks_subtitle.setText("Wi-Fi radio off")
                refresh_btn.setEnabled(True)
                return

            refresh_btn.setEnabled(False)
            if manual:
                dialog._wifi_state_known = False
                try:
                    ok, msg = self._enable_wifi_radio_on_y1(
                        context_cache['adb_path'],
                        context_cache['device_id'],
                        context_cache['env'],
                    )
                    if not ok:
                        silent_print(f"Unable to ensure Wi-Fi enabled before scan: {msg}")
                except Exception as exc:
                    silent_print(f"Error enabling Wi-Fi before scan: {exc}")
                status_label.setText("Status: Scanning for networks‚Ä¶")
            elif status_label.text() == "Status: Initializing‚Ä¶":
                status_label.setText("Status: Scanning for networks‚Ä¶")

            fut = track_future(
                self._wifi_scan_executor.submit(
                    self._get_wifi_networks_via_adb,
                    context_cache['adb_path'],
                    context_cache['device_id'],
                    context_cache['env'],
                )
            )
            def finished(future):
                try:
                    networks = future.result()
                    silent_print(f"Wi-Fi scan completed: found {len(networks)} networks")
                    dialog.networks_ready.emit(networks)
                except Exception as exc:
                    silent_print(f"Error refreshing networks: {exc}")
                    import traceback
                    silent_print(traceback.format_exc())
                    QTimer.singleShot(0, lambda: status_label.setText(f"Status: Error scanning networks: {str(exc)[:50]}"))
                finally:
                    QTimer.singleShot(0, lambda: refresh_btn.setEnabled(True))
            fut.add_done_callback(finished)

        def launch_settings():
            if not ensure_wifi_context():
                return
            ok, msg = self._launch_wifi_settings_on_y1(
                context_cache['adb_path'],
                context_cache['device_id'],
                context_cache['env'],
            )
            if ok:
                QMessageBox.information(
                    dialog,
                    "Manage Saved Networks",
                    "The Wi-Fi settings screen has been opened on your Y1. Use the device to manage saved networks, then return here when you‚Äôre ready."
                )
            else:
                QMessageBox.warning(dialog, "Wi-Fi Settings", msg or "Unable to open Wi-Fi settings on the device.")

        def on_connect_clicked():
            if not ensure_wifi_context():
                return
            ssid = ssid_input.text().strip()
            password = password_input.text()
            if not ssid:
                item = network_list.currentItem()
                if item:
                    data = item.data(Qt.UserRole) or {}
                    ssid = (data.get("ssid") or "").strip()
                    ssid_input.setText(ssid)
            if not ssid:
                QMessageBox.warning(dialog, "Missing SSID", "Select a network or enter the SSID first.")
                return
            data = (network_list.currentItem().data(Qt.UserRole) if network_list.currentItem() else {}) or {}
            bssid = data.get("bssid")
            connect_btn.setEnabled(False)
            status_label.setText("Status: Pushing Wi-Fi profile to your Y1‚Ä¶")

            fut = track_future(
                self._wifi_scan_executor.submit(
                    self._configure_wifi_network_on_y1,
                    context_cache['adb_path'],
                    context_cache['device_id'],
                    context_cache['env'],
                    ssid,
                    password,
                    bssid,
                )
            )
            def finished(future):
                success, message = future.result()
                def after():
                    connect_btn.setEnabled(True)
                    refresh_status()
                    refresh_networks()
                    if success:
                        settings_ok, settings_msg = self._launch_wifi_settings_on_y1(
                            context_cache['adb_path'],
                            context_cache['device_id'],
                            context_cache['env'],
                        )
                        snapshot = self._get_wifi_connection_snapshot(
                            context_cache['adb_path'],
                            context_cache['device_id'],
                            context_cache['env'],
                        )
                        connected_ssid = (snapshot or {}).get("ssid")
                        info_text = ""
                        if snapshot and snapshot.get("state") == "COMPLETED" and connected_ssid == ssid:
                            info_text = f'The Y1 connected to "{ssid}" successfully.'
                            self._post_wifi_connection_actions(context_cache, dialog)
                        else:
                            info_text = message or "Wi-Fi profile saved. If the device doesn't connect automatically, try again."
                        if settings_ok:
                            info_text += "\n\nWe opened the Y1's Wi-Fi settings so you can finish connecting on the player."
                        else:
                            info_text += f"\n\n{settings_msg or 'Open Wi-Fi settings on the Y1 to choose the network and connect.'}"
                        QMessageBox.information(dialog, "Wi-Fi Profile Sent", info_text)
                        dialog.accept()
                    else:
                        QMessageBox.warning(dialog, "Wi-Fi", message or "Unable to configure Wi-Fi on the Y1.")
                        status_label.setText("Status: Try again after checking the device.")
                QTimer.singleShot(0, after)
            fut.add_done_callback(finished)

        def post_selection():
            nonlocal last_selected_key
            item = network_list.currentItem()
            if item:
                data = item.data(Qt.UserRole) or {}
                if data.get("placeholder"):
                    network_list.clearSelection()
                    last_selected_key = None
                    return
                last_selected_key = _network_identity(data)
                ssid_val = data.get("ssid")
                if ssid_val is not None:
                    ssid_input.setText(ssid_val)
                    ssid_input.setCursorPosition(len(ssid_val))
                if data.get("is_open") and password_input.text():
                    password_input.clear()
                    show_password.setChecked(False)
            else:
                last_selected_key = None
        network_list.itemSelectionChanged.connect(post_selection)

        refresh_btn.clicked.connect(lambda: refresh_networks(manual=True))
        wifi_settings_btn.clicked.connect(launch_settings)
        connect_btn.clicked.connect(on_connect_clicked)

        refresh_timer = QTimer(dialog)
        refresh_timer.setInterval(10000)
        refresh_timer.timeout.connect(lambda: refresh_networks(manual=False))

        status_timer = QTimer(dialog)
        status_timer.setInterval(7000)
        status_timer.timeout.connect(lambda: refresh_status(show_dialog=False))

        def toggle_timers(active):
            if active:
                refresh_timer.start()
                status_timer.start()
            else:
                refresh_timer.stop()
                status_timer.stop()
                for fut in list(local_futures):
                    fut.cancel()

        def cleanup():
            toggle_timers(False)
        dialog.finished.connect(lambda _: cleanup())

        toggle_timers(True)

        def initialize_dialog():
            context_ready = ensure_wifi_context(show_dialog=False)
            if context_ready:
                snapshot = self._get_wifi_connection_snapshot(
                    context_cache['adb_path'],
                    context_cache['device_id'],
                    context_cache['env'],
                )
                if snapshot:
                    update_status(snapshot)
                else:
                    apply_wifi_state(dialog._wifi_enabled)
            else:
                apply_wifi_state(False)
            refresh_networks(manual=False)
            prefill_host_ssid()

        QTimer.singleShot(200, initialize_dialog)
        QTimer.singleShot(500, lambda: refresh_status(show_dialog=False))

        dialog.exec()

    def _post_wifi_connection_actions(self, context_cache, parent_dialog):
        """After confirming Wi-Fi connectivity, ensure wireless ADB is ready."""
        adb_path = context_cache.get('adb_path')
        device_id = context_cache.get('device_id')
        env = context_cache.get('env')
        if not adb_path or not device_id or not env:
            return
        
        # Check if wireless ADB connection already exists
        try:
            result = subprocess.run(
                [str(adb_path), 'devices'],
                capture_output=True,
                text=True,
                timeout=5,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            y1_wifi_devices = []
            for line in (result.stdout or "").splitlines():
                if '\tdevice' in line:
                    dev_id = line.split('\t')[0]
                    if ':' in dev_id and self._is_y1_device_id(adb_path, dev_id, env):
                        y1_wifi_devices.append(dev_id)
            if y1_wifi_devices:
                # Already connected over Wi-Fi ADB.
                return
        except Exception as exc:
            silent_print(f"Unable to check wireless ADB devices: {exc}")
        
        # Verify ADB Wi-Fi Reborn installation
        installed = self._check_adb_wifi_reborn_installed(adb_path, device_id, env)
        if not installed:
            choice = QMessageBox.question(
                parent_dialog,
                "Install ADB Wi-Fi Reborn",
                "ADB Wi-Fi Reborn is required for wireless ADB.\n\n"
                "Would you like to install it now?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            if choice == QMessageBox.Yes:
                parent_dialog.accept()
                self.install_adb_wifi_reborn()
            return
        
        # Offer to run the guided setup so the app launches and requests root
        choice = QMessageBox.question(
            parent_dialog,
            "Finish Wireless ADB Setup",
            "ADB Wi-Fi Reborn is installed but not yet active.\n\n"
            "Would you like to run the guided setup to enable wireless ADB now?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.Yes
        )
        if choice == QMessageBox.Yes:
            parent_dialog.accept()
            launched = self._launch_adb_wifi_app_main_activity(adb_path, device_id, env)
            self._show_adb_wifi_setup_wizard(adb_path, device_id, env, config_pushed=False, app_launched=launched)
    
    def _show_adb_wifi_setup_wizard(self, adb_path, device_id, env, config_pushed, app_launched):
        """Guide the user through post-install steps with a simple wizard."""
        from PySide6.QtWidgets import (
            QDialog,
            QVBoxLayout,
            QLabel,
            QPushButton,
            QHBoxLayout,
            QStackedWidget,
            QWidget,
            QMessageBox,
        )
        
        wizard = QDialog(self)
        wizard.setWindowTitle("ADB Wi-Fi Guided Setup")
        wizard.setMinimumWidth(460)
        layout = QVBoxLayout(wizard)
        
        intro = QLabel(
            "Follow these quick steps on your Y1 to finish enabling wireless ADB. "
            "Use the Next button below‚Äîeach screen explains what to do before you continue."
        )
        intro.setWordWrap(True)
        layout.addWidget(intro)
        
        if not app_launched:
            warning = QLabel(
                "<b>Heads up:</b> We couldn‚Äôt auto-open the ADB Wi-Fi app. "
                "Open it manually from the Rockbox Apps menu, then continue."
            )
        else:
            warning = QLabel(
                "The ADB Wi-Fi Reborn app should already be open on your Y1. "
                "If you don‚Äôt see it, tap Rockbox Apps ‚Ä∫ ADB Wi-Fi. "
                "Accept any prompts before proceeding."
            )
        warning.setWordWrap(True)
        layout.addWidget(warning)
        
        stack = QStackedWidget()
        layout.addWidget(stack)
        
        steps = [
            {
                "title": "Accept the Terms",
                "body": (
                    "On the Y1 screen, accept the Terms of Service in ADB Wi-Fi Reborn. "
                    "This only appears the first time you open the app."
                ),
            },
            {
                "title": "Navigate to Settings",
                "body": (
                    "Tap the ADB Wi-Fi menu button and choose <b>Settings</b>. "
                    "We‚Äôll change two options there."
                ),
            },
            {
                "title": "Enable Root + Run at Boot",
                "body": (
                    "In Settings, enable <b>Run at Boot</b> and confirm the root permission request. "
                    "This keeps wireless ADB available after restarts."
                ),
            },
            {
                "title": "Connect to Your Wi-Fi",
                "body": (
                    "Connect the Y1 to your home Wi-Fi so it can talk to Updater wirelessly. "
                    "You can do this from the device, or click the button below to pick a network from your computer."
                ),
                "add_wifi_button": True,
            },
            {
                "title": "Restart the Y1",
                "body": (
                    "Power the player off, wait a few seconds, then power it on. "
                    "Wireless ADB will start automatically once it rejoins Wi-Fi."
                ),
            },
        ]
        
        if config_pushed:
            steps[2]["body"] = (
                "In Settings you should see that <b>Run at Boot</b> is already enabled. "
                "Confirm that root access stays granted‚Äîtap the option once if the toggle looks disabled."
            )
        
        progress_label = QLabel()
        layout.addWidget(progress_label)
        
        for step in steps:
            page = QWidget()
            page_layout = QVBoxLayout(page)
            title = QLabel(f"<h3>{step['title']}</h3>")
            body = QLabel(step["body"])
            body.setWordWrap(True)
            page_layout.addWidget(title)
            page_layout.addWidget(body)
            
            if step.get("add_wifi_button"):
                hint = QLabel(
                    "We‚Äôll auto-detect the connection once it succeeds. "
                    "Use this if the device doesn‚Äôt have quick access to a keyboard."
                )
                hint.setWordWrap(True)
                page_layout.addWidget(hint)
                
                wifi_btn = QPushButton("Open Wireless Wi-Fi Tools")
                wifi_btn.clicked.connect(
                    lambda: self.open_wireless_wifi_dialog(
                        adb_path_override=adb_path,
                        device_id_override=device_id,
                        env_override=env,
                    )
                )
                page_layout.addWidget(wifi_btn)
                
                settings_btn = QPushButton("Open Wi-Fi Settings on Y1")
                def launch_settings():
                    ok, msg = self._launch_wifi_settings_on_y1(adb_path, device_id, env)
                    if ok:
                        QMessageBox.information(
                            wizard,
                            "Wi-Fi Settings",
                            "Wi-Fi settings launched on your Y1. Connect there, then return to continue."
                        )
                    else:
                        QMessageBox.warning(
                            wizard,
                            "Wi-Fi Settings",
                            msg or "Unable to open Wi-Fi settings on the Y1."
                        )
                settings_btn.clicked.connect(launch_settings)
                page_layout.addWidget(settings_btn)
            
            page_layout.addStretch()
            stack.addWidget(page)
        
        button_row = QHBoxLayout()
        prev_btn = QPushButton("Previous")
        next_btn = QPushButton("Next")
        close_btn = QPushButton("Close")
        button_row.addWidget(prev_btn)
        button_row.addStretch()
        button_row.addWidget(close_btn)
        button_row.addWidget(next_btn)
        layout.addLayout(button_row)
        
        def update_navigation():
            idx = stack.currentIndex()
            total = stack.count()
            progress_label.setText(f"Step {idx + 1} of {total}")
            prev_btn.setEnabled(idx > 0)
            next_btn.setText("Finish" if idx == total - 1 else "Next")
        
        def go_prev():
            idx = stack.currentIndex()
            if idx > 0:
                stack.setCurrentIndex(idx - 1)
                update_navigation()
        
        def go_next():
            idx = stack.currentIndex()
            if idx < stack.count() - 1:
                stack.setCurrentIndex(idx + 1)
                update_navigation()
            else:
                wizard.accept()
        
        prev_btn.clicked.connect(go_prev)
        next_btn.clicked.connect(go_next)
        close_btn.clicked.connect(wizard.reject)
        
        stack.setCurrentIndex(0)
        update_navigation()
        wizard.exec()
    
    def _configure_wifi_network_on_y1(self, adb_path, device_id, env, ssid, password, bssid=None):
        """Edit wpa_supplicant.conf on the Y1 to add/update a network profile."""
        temp_dir = Path(tempfile.mkdtemp(prefix="y1-wifi-"))
        remote_backup = "/sdcard/wpa_supplicant.conf.updater"
        remote_new = "/sdcard/wpa_supplicant.conf.updater.new"
        
        try:
            # 1. Backup current config to accessible storage
            result = subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "su", "-c", f"cp /data/misc/wifi/wpa_supplicant.conf {remote_backup}"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode != 0:
                message = result.stderr or result.stdout or "Unable to back up existing configuration."
                return False, message.strip()
            
            # 2. Pull the file locally
            local_path = temp_dir / "wpa_supplicant.conf"
            result = subprocess.run(
                [str(adb_path), "-s", device_id, "pull", remote_backup, str(local_path)],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode != 0 or not local_path.exists():
                message = result.stderr or result.stdout or "Unable to pull configuration from device."
                return False, message.strip()
            
            content = local_path.read_text()
            escaped_ssid = ssid.replace('"', r'\"')
            escaped_password = password.replace('"', r'\"') if password else ""
            
            lines = content.splitlines()
            cleaned_lines = []
            inside_block = False
            block_lines = []
            skip_block = False
            
            for line in lines:
                stripped = line.strip()
                if stripped.startswith("network={"):
                    inside_block = True
                    skip_block = False
                    block_lines = [line]
                    continue
                
                if inside_block:
                    block_lines.append(line)
                    if stripped.startswith('ssid="'):
                        existing_ssid = stripped.split('ssid="', 1)[1].rstrip('"')
                        if existing_ssid == ssid:
                            skip_block = True
                    if stripped == "}":
                        inside_block = False
                        if not skip_block:
                            cleaned_lines.extend(block_lines)
                        block_lines = []
                    continue
                
                cleaned_lines.append(line)
            
            if inside_block and block_lines and not skip_block:
                cleaned_lines.extend(block_lines)
            
            # Ensure trailing newline
            if cleaned_lines and cleaned_lines[-1].strip():
                cleaned_lines.append("")
            
            # Assemble new block
            new_block = ["network={", f'\tssid="{escaped_ssid}"']
            if password:
                new_block.append(f'\tpsk="{escaped_password}"')
                new_block.append("\tkey_mgmt=WPA-PSK")
            else:
                new_block.append("\tkey_mgmt=NONE")
            if bssid:
                new_block.append(f'\tbssid={bssid.lower()}')
            new_block.append("\tpriority=100")
            new_block.append("\tdisabled=0")
            new_block.append("}")
            
            cleaned_lines.extend(new_block)
            cleaned_lines.append("")
            
            local_path.write_text("\n".join(cleaned_lines))
            
            # 3. Push modified file back
            push_result = subprocess.run(
                [str(adb_path), "-s", device_id, "push", str(local_path), remote_new],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if push_result.returncode != 0:
                message = push_result.stderr or push_result.stdout or "Unable to push the updated configuration."
                return False, message.strip()
            
            # 4. Move into place with correct permissions
            apply_cmd = (
                f"cp {remote_new} /data/misc/wifi/wpa_supplicant.conf && "
                f"chmod 660 /data/misc/wifi/wpa_supplicant.conf && "
                f"chown system:wifi /data/misc/wifi/wpa_supplicant.conf"
            )
            apply_result = subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "su", "-c", apply_cmd],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if apply_result.returncode != 0:
                message = apply_result.stderr or apply_result.stdout or "Unable to apply Wi-Fi configuration."
                return False, message.strip()
            
            # 5. Restart Wi-Fi so the changes take effect
            subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "svc", "wifi", "disable"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            time.sleep(1.5)
            subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "svc", "wifi", "enable"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "am", "broadcast", "-a", "android.net.wifi.SCAN_RESULTS"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            time.sleep(2.0)

            attempts = 3
            connected = False
            snapshot = {}
            for attempt in range(attempts):
                connected, snapshot = self._wait_for_wifi_connection(
                    adb_path,
                    device_id,
                    env,
                    ssid,
                    timeout=15 if attempt == 0 else 20,
                )
                if connected:
                    break
                if attempt < attempts - 1:
                    silent_print(f"Wi-Fi not yet connected to {ssid}; retrying (attempt {attempt + 2}/{attempts}).")
                    subprocess.run(
                        [str(adb_path), "-s", device_id, "shell", "svc", "wifi", "disable"],
                        capture_output=True,
                        text=True,
                        timeout=10,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
                    )
                    time.sleep(1.5)
                    subprocess.run(
                        [str(adb_path), "-s", device_id, "shell", "svc", "wifi", "enable"],
                        capture_output=True,
                        text=True,
                        timeout=10,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
                    )
                    subprocess.run(
                        [str(adb_path), "-s", device_id, "shell", "am", "broadcast", "-a", "android.net.wifi.SCAN_RESULTS"],
                        capture_output=True,
                        text=True,
                        timeout=10,
                        env=env,
                        creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
                    )
                    time.sleep(2.0)

            if connected:
                return True, f'The Y1 connected to "{ssid}".'
            return True, "Wi-Fi profile saved. Give the Y1 a moment to join the network."
        except Exception as exc:
            silent_print(f"Failed to configure Wi-Fi network: {exc}")
            return False, f"Unexpected error configuring Wi-Fi: {exc}"
        finally:
            shutil.rmtree(temp_dir, ignore_errors=True)
            # Clean up remote temp files
            try:
                subprocess.run(
                    [str(adb_path), "-s", device_id, "shell", "su", "-c", f"rm -f {remote_new}"],
                    capture_output=True,
                    text=True,
                    timeout=5,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
                )
            except Exception:
                pass
    
    def _wait_for_wifi_connection(self, adb_path, device_id, env, target_ssid, timeout=30):
        """Poll dumpsys wifi until the specified SSID reports as connected."""
        deadline = time.time() + max(timeout, 5)
        last_snapshot = {}
        while time.time() < deadline:
            snapshot = self._get_wifi_connection_snapshot(adb_path, device_id, env)
            last_snapshot = snapshot or {}
            ssid = (last_snapshot.get("ssid") or "").strip()
            state = (last_snapshot.get("state") or "").upper()
            silent_print(f"Connection poll: state={state} ssid={ssid}")
            if state == "COMPLETED" and ssid == target_ssid:
                return True, last_snapshot
            if state in {"DISCONNECTED", "INACTIVE"} and ssid and ssid != target_ssid:
                break
            time.sleep(2)
        return False, last_snapshot
    
    def _get_wifi_connection_snapshot(self, adb_path, device_id, env):
        """Return current Wi-Fi connection details from dumpsys wifi."""
        try:
            result = subprocess.run(
                [str(adb_path), "-s", device_id, "shell", "dumpsys", "wifi"],
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0,
            )
            if result.returncode != 0 or not result.stdout:
                return {}
            
            state = None
            ssid = None
            bssid = None
            rssi = None
            wifi_enabled = None
            for raw_line in result.stdout.splitlines():
                line = raw_line.strip()
                if line.startswith("Wi-Fi is "):
                    wifi_enabled = "enabled" in line.lower()
                if line.startswith("Supplicant state:"):
                    state = line.split(":", 1)[1].strip()
                elif line.startswith("SSID:"):
                    value = line.split(":", 1)[1].strip()
                    if value and value != "<unknown ssid>":
                        ssid = value
                elif line.startswith("BSSID:"):
                    value = line.split(":", 1)[1].strip()
                    if value and value != "00:00:00:00:00:00":
                        bssid = value.lower()
                elif "RSSI:" in line:
                    try:
                        rssi = int(line.split("RSSI:", 1)[1].split(",", 1)[0].strip())
                    except Exception:
                        continue
            return {"state": state, "ssid": ssid, "bssid": bssid, "rssi": rssi, "wifi_enabled": wifi_enabled}
        except Exception as exc:
            silent_print(f"dumpsys wifi status read failed: {exc}")
            return {}
    
    def _parse_cmd_wifi_scan(self, output):
        """Parse cmd wifi list-scan-results output."""
        networks = []
        current = {}
        for raw_line in output.splitlines():
            line = raw_line.strip()
            if not line:
                if current and current.get('ssid'):
                    networks.append(current)
                current = {}
                continue
            if line.lower().startswith('network'):
                if current and current.get('ssid'):
                    networks.append(current)
                current = {}
                continue
            if 'SSID:' in line:
                current['ssid'] = line.split('SSID:', 1)[1].strip()
            elif 'BSSID:' in line:
                current['bssid'] = line.split('BSSID:', 1)[1].strip()
            elif 'RSSI:' in line:
                current['signal'] = line.split('RSSI:', 1)[1].strip()
            elif 'level:' in line and 'signal' not in current:
                current['signal'] = line.split('level:', 1)[1].strip()
            elif 'frequency:' in line:
                current['frequency'] = line.split('frequency:', 1)[1].strip()
        if current and current.get('ssid'):
            networks.append(current)
        # Deduplicate by SSID/BSSID
        seen = set()
        deduped = []
        for net in networks:
            key = (net.get('ssid'), net.get('bssid'))
            if key in seen:
                continue
            seen.add(key)
            deduped.append(net)
        return deduped
    
    def _parse_wpa_cli_scan(self, output):
        """Parse wpa_cli scan_results output."""
        networks = []
        lines = [line.strip() for line in output.splitlines() if line.strip()]
        if not lines:
            return networks
        for line in lines[1:]:
            parts = line.split('\t')
            if len(parts) >= 5:
                bssid, freq, level, flags, ssid = parts[:5]
                networks.append({
                    'ssid': ssid,
                    'bssid': bssid,
                    'frequency': freq,
                    'signal': f"{level} dBm" if level else None,
                    'flags': flags
                })
        return networks
    
    def _parse_dumpsys_wifi_scan(self, output):
        """Parse the 'Latest scan results' section from dumpsys wifi."""
        networks = []
        in_section = False
        for raw_line in output.splitlines():
            line = raw_line.strip()
            if not line:
                continue
            if line.lower().startswith("latest scan results"):
                in_section = True
                continue
            if not in_section:
                continue
            # end of section
            lower_line = line.lower()
            if lower_line.startswith("locks ") or lower_line.startswith("wifiwatchdog"):
                break
            if line.startswith("BSSID"):
                continue
            match = re.match(r'([0-9A-Fa-f:]{17})\s+(\d+)\s+(-?\d+)\s+(\[[^\]]+\](?:\[[^\]]+\])*)\s+(.*)$', line)
            if match:
                bssid, freq, level, flags, ssid = match.groups()
                networks.append({
                    'ssid': ssid,
                    'bssid': bssid,
                    'frequency': freq,
                    'signal': f"{level} dBm" if level else None,
                    'flags': flags
                })
        return networks
    
    def _connect_wifi_network_via_adb(self, adb_path, device_id, env, ssid, password):
        """Issue adb shell command to connect to Wi-Fi network."""
        safe_ssid = ssid.replace('"', r'\"')
        safe_password = password.replace('"', r'\"')
        base_cmd = f'cmd wifi connect-network "{safe_ssid}"'
        if safe_password:
            base_cmd += f' "{safe_password}"'
        adb_command = [str(adb_path), '-s', device_id, 'shell', 'su', '-c', base_cmd]
        result = subprocess.run(
            adb_command,
            capture_output=True,
            text=True,
            timeout=20,
            env=env,
            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
        )
        stdout = (result.stdout or "").strip()
        stderr = (result.stderr or "").strip()
        message = stdout or stderr or "Command executed."
        success = result.returncode == 0
        if success:
            try:
                subprocess.run(
                    [str(adb_path), '-s', device_id, 'shell', 'su', '-c', 'cmd wifi reconnect'],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
            except Exception as reconnect_error:
                silent_print(f"Wi-Fi reconnect command error: {reconnect_error}")
        return success, message
    
    def _copy_tree_clean_metadata(self, src, dst):
        """Copy directory tree while cleaning macOS metadata files"""
        import shutil
        for item in src.iterdir():
            if self._is_macos_metadata(item):
                silent_print(f"Skipping macOS metadata: {item.name}")
                continue
            src_path = src / item.name
            dst_path = dst / item.name
            if src_path.is_dir():
                if dst_path.exists():
                    self._copy_tree_clean_metadata(src_path, dst_path)
                else:
                    shutil.copytree(src_path, dst_path)
                    self._cleanup_macos_metadata(dst_path)
            else:
                shutil.copy2(src_path, dst_path)
    
    def _select_usb_storage_folder(self, usb_drive_path, file_paths=None):
        """Select destination folder using USB storage mode file system access"""
        try:
            from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QTreeWidget, QTreeWidgetItem, QPushButton, QHBoxLayout, QLineEdit, QMessageBox
            
            usb_path = Path(usb_drive_path)
            if not usb_path.exists():
                QMessageBox.warning(self, "USB Drive Not Found", f"USB drive not found: {usb_drive_path}")
                return None
            
            # Determine suggested folder based on file types
            suggested_folder = self._suggest_folder_by_file_type(file_paths) if file_paths else None
            
            # Show status message while indexing
            if hasattr(self, 'status_label'):
                self.status_label.setText("Indexing folders on USB drive...")
                QApplication.processEvents()
            
            # List folders using file system access
            folders = self._list_usb_storage_folders(usb_path)
            
            # Clear status message after indexing
            if hasattr(self, 'status_label'):
                self.status_label.setText("")
                QApplication.processEvents()
            
            # Create dialog for folder selection
            dialog = QDialog(self)
            dialog.setWindowTitle("Select Destination Folder on Y1 USB Drive")
            dialog.setMinimumWidth(500)
            dialog.setMinimumHeight(400)
            
            layout = QVBoxLayout(dialog)
            
            # Label
            label = QLabel(f"Select the folder on your Y1 USB drive ({usb_drive_path}) where you want to transfer the files:")
            label.setWordWrap(True)
            layout.addWidget(label)
            
            # Tree widget for folders (expandable)
            tree_widget = QTreeWidget()
            tree_widget.setHeaderLabel("Folders")
            tree_widget.setRootIsDecorated(True)
            
            # Helper function to get relative path from USB drive root
            def relative_path(full_path):
                try:
                    return str(Path(full_path).relative_to(usb_path))
                except ValueError:
                    return str(full_path)
            
            # Add root item
            root_item = QTreeWidgetItem(tree_widget, ['/'])
            root_item.setData(0, Qt.UserRole, str(usb_path))
            root_item.setExpanded(True)
            
            # Add top-level folders
            folder_items = {}
            for folder in sorted(folders):
                rel_path = relative_path(folder)
                display = f"/{rel_path}" if rel_path != "." else "/"
                
                # Create item
                item = QTreeWidgetItem([display])
                item.setData(0, Qt.UserRole, str(folder))
                
                # Add placeholder for lazy loading
                placeholder = QTreeWidgetItem(item, ['...'])
                placeholder.setData(0, Qt.UserRole, None)
                
                # Add to root
                root_item.addChild(item)
                folder_items[str(folder)] = item
            
            # Function to load subfolders on demand
            def load_subfolders(item):
                if item.childCount() == 1:
                    child = item.child(0)
                    if child.data(0, Qt.UserRole) is None:  # Placeholder
                        parent_path = Path(item.data(0, Qt.UserRole))
                        if parent_path.exists() and parent_path.is_dir():
                            # Show status message while loading subfolders
                            if hasattr(self, 'status_label'):
                                folder_name = parent_path.name if parent_path.name else "folder"
                                self.status_label.setText(f"Loading subfolders in {folder_name}...")
                                QApplication.processEvents()
                            
                            # Load subfolders using file system access
                            subfolders = self._list_usb_storage_subfolders(parent_path)
                            item.removeChild(child)  # Remove placeholder
                            for subfolder in sorted(subfolders):
                                rel_path = relative_path(subfolder)
                                display = f"/{rel_path}"
                                sub_item = QTreeWidgetItem([display])
                                sub_item.setData(0, Qt.UserRole, str(subfolder))
                                # Add placeholder for nested subfolders
                                placeholder = QTreeWidgetItem(sub_item, ['...'])
                                placeholder.setData(0, Qt.UserRole, None)
                                item.addChild(sub_item)
                                folder_items[str(subfolder)] = sub_item
                            
                            # Clear status message after loading
                            if hasattr(self, 'status_label'):
                                self.status_label.setText("")
                                QApplication.processEvents()
            
            # Connect expansion signal
            tree_widget.itemExpanded.connect(load_subfolders)
            
            # Select suggested folder if available
            if suggested_folder:
                # Map suggested folder to USB drive path
                suggested_usb_path = usb_path / suggested_folder.replace("/storage/sdcard0/", "").lstrip("/")
                if suggested_usb_path.exists():
                    for i in range(root_item.childCount()):
                        child = root_item.child(i)
                        if child.data(0, Qt.UserRole) == str(suggested_usb_path):
                            tree_widget.setCurrentItem(child)
                            break
            
            layout.addWidget(tree_widget)
            
            # Custom folder input
            custom_layout = QHBoxLayout()
            custom_label = QLabel("Or enter custom path:")
            custom_layout.addWidget(custom_label)
            custom_input = QLineEdit()
            custom_input.setPlaceholderText(f"e.g., {usb_drive_path}/Music")
            custom_layout.addWidget(custom_input)
            layout.addLayout(custom_layout)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_btn)
            ok_btn = QPushButton("OK")
            ok_btn.setDefault(True)
            ok_btn.clicked.connect(dialog.accept)
            button_layout.addWidget(ok_btn)
            layout.addLayout(button_layout)
            
            if dialog.exec() == QDialog.Accepted:
                # Get selected folder
                selected_item = tree_widget.currentItem()
                if selected_item:
                    selected_path = selected_item.data(0, Qt.UserRole)
                    if selected_path:
                        return str(selected_path)
                
                # Check custom input
                custom_path = custom_input.text().strip()
                if custom_path:
                    custom_path_obj = Path(custom_path)
                    if custom_path_obj.exists() and custom_path_obj.is_dir():
                        return str(custom_path_obj)
                    else:
                        QMessageBox.warning(self, "Invalid Path", f"The path does not exist:\n{custom_path}")
                        return None
                
                return None
            else:
                return None
                
        except Exception as e:
            silent_print(f"Error selecting USB storage folder: {e}")
            import traceback
            traceback.print_exc()
            QMessageBox.warning(self, "Error", f"Error selecting folder: {str(e)}")
            return None
    
    def _list_usb_storage_folders(self, usb_path):
        """List folders on USB storage drive using file system access"""
        folders = []
        try:
            if not usb_path.exists() or not usb_path.is_dir():
                return folders
            
            # List all directories in USB drive root
            for item in usb_path.iterdir():
                if item.is_dir() and not self._is_macos_metadata(item):
                    folders.append(item)
            
            return folders
        except Exception as e:
            silent_print(f"Error listing USB storage folders: {e}")
            return folders
    
    def _list_usb_storage_subfolders(self, parent_path):
        """List subfolders in a specific directory on USB storage drive"""
        subfolders = []
        try:
            if not parent_path.exists() or not parent_path.is_dir():
                return subfolders
            
            # List all directories in parent path
            for item in parent_path.iterdir():
                if item.is_dir() and not self._is_macos_metadata(item):
                    subfolders.append(item)
            
            return subfolders
        except Exception as e:
            silent_print(f"Error listing USB storage subfolders: {e}")
            return subfolders
    
    def list_device_folders(self, adb_path, device_id, env):
        """List folders on device using ADB"""
        folders = []
        try:
            # Hardcoded mountpoint that contains .rockbox
            mountpoint = "/storage/sdcard0"
            
            # Show status message
            if hasattr(self, 'status_label'):
                self.status_label.setText("Indexing folders on device...")
                QApplication.processEvents()
            
            # Build ADB command to list directories in mountpoint
            adb_cmd = [str(adb_path)]
            if device_id:
                adb_cmd.extend(['-s', device_id])
            
            # List directories in mountpoint using ls command (including hidden folders)
            # Use 'ls -d {mountpoint}/*/' to get visible directories
            adb_cmd.extend(['shell', 'ls', '-d', f'{mountpoint}/*/', '2>/dev/null'])
            
            result = subprocess.run(
                adb_cmd,
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                shell=False,  # Don't use shell, pass command as list
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Process events to keep GUI responsive
            QApplication.processEvents()
            
            if result.returncode == 0:
                # Parse output - each line is a directory path
                for line in result.stdout.strip().split('\n'):
                    line = line.strip()
                    if line and line.startswith(mountpoint + '/'):
                        # Remove trailing slash if present
                        if line.endswith('/'):
                            line = line[:-1]
                        # Skip if it's just mountpoint itself
                        if line != mountpoint and line not in folders:
                            folders.append(line)
            
            # Also list hidden directories (starting with .)
            if hasattr(self, 'status_label'):
                self.status_label.setText("Indexing hidden folders on device...")
                QApplication.processEvents()
            
            adb_cmd_hidden = [str(adb_path)]
            if device_id:
                adb_cmd_hidden.extend(['-s', device_id])
            adb_cmd_hidden.extend(['shell', 'ls', '-d', f'{mountpoint}/.*/', '2>/dev/null'])
            
            result_hidden = subprocess.run(
                adb_cmd_hidden,
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                shell=False,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Process events to keep GUI responsive
            QApplication.processEvents()
            
            if result_hidden.returncode == 0:
                # Parse output for hidden folders
                for line in result_hidden.stdout.strip().split('\n'):
                    line = line.strip()
                    if line and line.startswith(mountpoint + '/') and not line.endswith('/..'):
                        # Remove trailing slash if present
                        if line.endswith('/'):
                            line = line[:-1]
                        # Skip if it's just mountpoint itself or parent directory
                        if line != mountpoint and line != f'{mountpoint}/.' and line not in folders:
                            folders.append(line)
            
            # Also try listing with find command for more comprehensive results
            if hasattr(self, 'status_label'):
                self.status_label.setText("Scanning device directory structure...")
                QApplication.processEvents()
            
            adb_cmd2 = [str(adb_path)]
            if device_id:
                adb_cmd2.extend(['-s', device_id])
            
            # Find all directories in mountpoint (max depth 2 for performance)
            adb_cmd2.extend(['shell', 'find', mountpoint, '-maxdepth', '2', '-type', 'd', '2>/dev/null'])
            
            result2 = subprocess.run(
                adb_cmd2,
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                shell=False,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Process events to keep GUI responsive
            QApplication.processEvents()
            
            if result2.returncode == 0:
                # Parse output
                for line in result2.stdout.strip().split('\n'):
                    line = line.strip()
                    if line and line.startswith(mountpoint + '/') and line != mountpoint and line not in folders:
                        folders.append(line)
            
            # Remove duplicates and sort
            folders = sorted(list(set(folders)))
            
        except Exception as e:
            silent_print(f"Error listing device folders: {e}")
            import traceback
            traceback.print_exc()
        
        return folders
    
    def list_device_subfolders(self, adb_path, device_id, env, parent_path):
        """List subfolders in a specific directory on device (including hidden folders)"""
        subfolders = []
        try:
            # Show status message while loading subfolders
            if hasattr(self, 'status_label'):
                folder_name = Path(parent_path).name if parent_path else "folder"
                self.status_label.setText(f"Loading subfolders in {folder_name}...")
                QApplication.processEvents()
            
            adb_cmd = [str(adb_path)]
            if device_id:
                adb_cmd.extend(['-s', device_id])
            
            # List visible directories in parent path
            adb_cmd.extend(['shell', 'ls', '-d', f'{parent_path}/*/', '2>/dev/null'])
            
            result = subprocess.run(
                adb_cmd,
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                shell=False,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Process events to keep GUI responsive
            QApplication.processEvents()
            
            if result.returncode == 0:
                for line in result.stdout.strip().split('\n'):
                    line = line.strip()
                    if line and line.startswith(parent_path + '/') and line.endswith('/'):
                        # Remove trailing slash
                        folder = line[:-1]
                        if folder not in subfolders:
                            subfolders.append(folder)
            
            # Also list hidden directories (starting with .)
            adb_cmd_hidden = [str(adb_path)]
            if device_id:
                adb_cmd_hidden.extend(['-s', device_id])
            adb_cmd_hidden.extend(['shell', 'ls', '-d', f'{parent_path}/.*/', '2>/dev/null'])
            
            result_hidden = subprocess.run(
                adb_cmd_hidden,
                capture_output=True,
                text=True,
                timeout=10,
                env=env,
                shell=False,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Process events to keep GUI responsive
            QApplication.processEvents()
            
            if result_hidden.returncode == 0:
                for line in result_hidden.stdout.strip().split('\n'):
                    line = line.strip()
                    if line and line.startswith(parent_path + '/') and line.endswith('/'):
                        # Remove trailing slash
                        folder = line[:-1]
                        # Skip parent directory references
                        if not folder.endswith('/..') and folder not in subfolders:
                            subfolders.append(folder)
        except Exception as e:
            silent_print(f"Error listing subfolders for {parent_path}: {e}")
        
        return subfolders
    
    def _suggest_folder_by_file_type(self, file_paths):
        """Suggest destination folder based on file types"""
        if not file_paths:
            return None
        
        # Hardcoded mountpoint that contains .rockbox
        mountpoint = "/storage/sdcard0"
        
        # Determine file types
        audio_extensions = {'.mp3', '.flac', '.ogg', '.wav', '.m4a', '.aac', '.opus', '.wma'}
        image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'}
        video_extensions = {'.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm'}
        document_extensions = {'.pdf', '.doc', '.docx', '.txt', '.rtf'}
        
        audio_count = 0
        image_count = 0
        video_count = 0
        document_count = 0
        
        for file_path in file_paths:
            path = Path(file_path)
            if path.is_file():
                ext = path.suffix.lower()
                if ext in audio_extensions:
                    audio_count += 1
                elif ext in image_extensions:
                    image_count += 1
                elif ext in video_extensions:
                    video_count += 1
                elif ext in document_extensions:
                    document_count += 1
        
        # Suggest folder based on most common file type
        if audio_count > 0:
            return f'{mountpoint}/Music'
        elif image_count > 0:
            return f'{mountpoint}/Pictures'
        elif video_count > 0:
            return f'{mountpoint}/Movies'  # Or DCIM for some devices
        elif document_count > 0:
            return f'{mountpoint}/Documents'
        
        return None
    
    def _is_rockbox_only_zip(self, zip_path):
        """Check if zip contains only a .rockbox folder"""
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                # Get all file names in zip
                file_list = zip_ref.namelist()
                
                if not file_list:
                    return False
                
                # Check if all files are within a .rockbox folder
                all_in_rockbox = True
                has_rockbox = False
                
                for file_name in file_list:
                    # Skip empty directories
                    if file_name.endswith('/'):
                        continue
                    
                    # Skip macOS metadata files/folders
                    if self._is_macos_metadata(file_name):
                        continue
                    
                    # Check if file is in .rockbox folder
                    if file_name.startswith('.rockbox/') or file_name.startswith('.rockbox\\'):
                        has_rockbox = True
                    else:
                        # Check if root level only has .rockbox folder
                        parts = file_name.replace('\\', '/').split('/')
                        if len(parts) > 1 and parts[0].lower() == '.rockbox':
                            has_rockbox = True
                        else:
                            all_in_rockbox = False
                            break
                
                return has_rockbox and all_in_rockbox
        except Exception as e:
            silent_print(f"Error checking rockbox zip: {e}")
            return False
    
    def _is_theme_zip(self, zip_path):
        """Check if zip contains config.json and cover.png (theme files)"""
        try:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                file_list = zip_ref.namelist()
                
                has_config = False
                has_cover = False
                
                for file_name in file_list:
                    # Skip empty directories
                    if file_name.endswith('/'):
                        continue
                    
                    # Skip macOS metadata files/folders
                    if self._is_macos_metadata(file_name):
                        continue
                    
                    name_lower = file_name.lower()
                    # Check for config.json (can be at root or in subfolder)
                    if name_lower.endswith('config.json') or name_lower.endswith('/config.json') or name_lower.endswith('\\config.json'):
                        has_config = True
                    # Check for cover.png (can be at root or in subfolder)
                    if name_lower.endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp')) and 'cover' in name_lower:
                        has_cover = True
                    
                    if has_config and has_cover:
                        return True
                
                return False
        except Exception as e:
            silent_print(f"Error checking theme zip: {e}")
            return False
    
    def _is_theme_folder(self, folder_path):
        """Check if folder contains config.json and cover.png (theme files)"""
        try:
            path = Path(folder_path)
            if not path.is_dir():
                return False
            
            # Check if folder directly contains config.json and cover.png
            has_config = (path / 'config.json').exists() and (path / 'config.json').is_file()
            has_cover = self._has_cover_image(path)
            
            if has_config and has_cover:
                return True
            
            return False
        except Exception as e:
            silent_print(f"Error checking theme folder: {e}")
            return False
    
    def _is_macos_metadata(self, path):
        """Check if path is macOS metadata (should be skipped)"""
        path_str = str(path).replace('\\', '/')  # Normalize path separators
        path_lower = path_str.lower()
        name = Path(path).name
        
        # Check for common macOS metadata folders/files
        if name.startswith('._') or name == '.ds_store' or name == '__macosx':
            return True
        if '_macosx' in path_lower or '__macosx' in path_lower:
            return True
        if '/._' in path_lower or '\\._' in path_lower:
            return True
        if path_lower.endswith('/.ds_store') or path_lower.endswith('\\.ds_store'):
            return True
        
        return False
    
    def _cleanup_macos_metadata(self, directory):
        """Remove macOS metadata files and folders from a directory"""
        removed_count = 0
        try:
            dir_path = Path(directory)
            if not dir_path.exists() or not dir_path.is_dir():
                return removed_count
            
            # Remove macOS metadata files and folders
            for item in dir_path.rglob('*'):
                if self._is_macos_metadata(item):
                    try:
                        if item.is_file():
                            item.unlink()
                            removed_count += 1
                            silent_print(f"Removed macOS metadata file: {item}")
                        elif item.is_dir():
                            import shutil
                            shutil.rmtree(item, ignore_errors=True)
                            removed_count += 1
                            silent_print(f"Removed macOS metadata folder: {item}")
                    except Exception as e:
                        silent_print(f"Error removing macOS metadata {item}: {e}")
            
            return removed_count
        except Exception as e:
            silent_print(f"Error cleaning up macOS metadata: {e}")
            return removed_count
    
    def _cleanup_device_macos_metadata_silent(self, adb_path, device_id, env):
        """Silently remove macOS metadata files from device storage - graceful failure, no user interruption"""
        try:
            if not adb_path or not device_id:
                return
            
            # Run cleanup in background thread to avoid blocking
            import threading
            def cleanup_worker():
                try:
                    self._cleanup_device_macos_metadata_direct(adb_path, device_id, env)
                except Exception as e:
                    # Silent failure - don't interrupt user
                    silent_print(f"Silent cleanup of macOS metadata failed (non-critical): {e}")
            
            cleanup_thread = threading.Thread(target=cleanup_worker, daemon=True)
            cleanup_thread.start()
        except Exception:
            # Silent failure - don't interrupt user
            pass
    
    def _cleanup_device_macos_metadata_direct(self, adb_path, device_id, env):
        """Remove macOS metadata files directly via ADB (for use in worker threads)"""
        try:
            # Common locations where macOS metadata might be found
            storage_paths = [
                "/storage/sdcard0",
                "/sdcard",
                "/storage/emulated/0"
            ]
            
            # macOS metadata patterns to remove
            metadata_patterns = [
                "__MACOSX",
                "_MACOSX",
                "._*",
                ".DS_Store"
            ]
            
            for storage_path in storage_paths:
                # Try to find and remove macOS metadata folders/files
                for pattern in metadata_patterns:
                    try:
                        # Use find command to locate macOS metadata
                        find_cmd = [str(adb_path), '-s', device_id, 'shell', 
                                   f'find {storage_path} -name "{pattern}" -type f -o -name "{pattern}" -type d 2>/dev/null']
                        find_result = subprocess.run(
                            find_cmd,
                            capture_output=True,
                            text=True,
                            timeout=10,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                        
                        if find_result.returncode == 0 and find_result.stdout.strip():
                            # Remove found metadata files/folders
                            for metadata_path in find_result.stdout.strip().split('\n'):
                                if metadata_path.strip():
                                    try:
                                        rm_cmd = [str(adb_path), '-s', device_id, 'shell', 
                                                 f'rm -rf "{metadata_path.strip()}"']
                                        subprocess.run(
                                            rm_cmd,
                                            capture_output=True,
                                            text=True,
                                            timeout=5,
                                            env=env,
                                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                        )
                                        silent_print(f"Removed macOS metadata from device: {metadata_path.strip()}")
                                    except:
                                        pass
                    except:
                        pass
        except Exception as e:
            silent_print(f"Error cleaning up device macOS metadata directly: {e}")
    
    def _cleanup_device_macos_metadata(self, adb_path, device_id, env):
        """Remove macOS metadata files and folders from device storage"""
        try:
            import platform
            
            # Common locations where macOS metadata might be found
            storage_paths = [
                "/storage/sdcard0",
                "/sdcard",
                "/storage/emulated/0"
            ]
            
            # macOS metadata patterns to remove
            metadata_patterns = [
                "__MACOSX",
                "_MACOSX",
                "._*",
                ".DS_Store"
            ]
            
            for storage_path in storage_paths:
                # Try to find and remove macOS metadata folders
                for pattern in metadata_patterns:
                    try:
                        # Use find command to locate macOS metadata
                        find_cmd = [str(adb_path), '-s', device_id, 'shell', 
                                   f'find {storage_path} -name "{pattern}" -type f -o -name "{pattern}" -type d 2>/dev/null']
                        find_result = subprocess.run(
                            find_cmd,
                            capture_output=True,
                            text=True,
                            timeout=10,
                            env=env,
                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                        )
                        
                        if find_result.returncode == 0 and find_result.stdout.strip():
                            # Remove found metadata files/folders
                            for metadata_path in find_result.stdout.strip().split('\n'):
                                if metadata_path.strip():
                                    try:
                                        rm_cmd = [str(adb_path), '-s', device_id, 'shell', 
                                                 f'rm -rf "{metadata_path.strip()}"']
                                        subprocess.run(
                                            rm_cmd,
                                            capture_output=True,
                                            text=True,
                                            timeout=5,
                                            env=env,
                                            creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                                        )
                                        silent_print(f"Removed macOS metadata from device: {metadata_path.strip()}")
                                    except:
                                        pass
                    except:
                        pass
        except Exception as e:
            silent_print(f"Error cleaning up device macOS metadata: {e}")
    
    def _find_theme_folders(self, root_path):
        """Recursively find all theme folders in a directory"""
        theme_folders = []
        try:
            root = Path(root_path)
            if not root.exists():
                return theme_folders
            
            # Check if root itself is a theme folder (skip if it's macOS metadata)
            if root.is_dir() and not self._is_macos_metadata(root) and self._is_theme_folder(root):
                theme_folders.append(str(root))
            
            # Recursively search subdirectories
            if root.is_dir():
                for item in root.rglob('*'):
                    # Skip macOS metadata folders
                    if self._is_macos_metadata(item):
                        continue
                    
                    if item.is_dir() and self._is_theme_folder(item):
                        # Avoid duplicates (if parent is also a theme)
                        is_duplicate = False
                        for existing in theme_folders:
                            existing_path = Path(existing)
                            # Check if this folder is a subdirectory of an existing theme folder
                            try:
                                item.relative_to(existing_path)
                                is_duplicate = True
                                break
                            except ValueError:
                                pass
                            # Check if existing folder is a subdirectory of this folder
                            try:
                                existing_path.relative_to(item)
                                # Remove the existing folder as it's nested in this one
                                theme_folders.remove(existing)
                            except ValueError:
                                pass
                        
                        if not is_duplicate:
                            theme_folders.append(str(item))
            
            return theme_folders
        except Exception as e:
            silent_print(f"Error finding theme folders: {e}")
            return theme_folders

    def _has_cover_image(self, folder_path):
        """Return True if folder contains a cover image (filename includes 'cover')."""
        try:
            path = Path(folder_path)
            if not path.is_dir():
                return False
            cover_extensions = {'.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp'}
            for child in path.iterdir():
                if not child.is_file():
                    continue
                name_lower = child.name.lower()
                if 'cover' in name_lower and child.suffix.lower() in cover_extensions:
                    return True
            return False
        except Exception as cover_error:
            silent_print(f"Error checking cover image in {folder_path}: {cover_error}")
            return False
    
    def _prepare_theme_folder_from_root(self, extracted_root, source_path):
        """If config.json/cover.* live in the root, move them into a dedicated folder."""
        try:
            temp_path = Path(extracted_root)
            if not temp_path.exists() or not temp_path.is_dir():
                return None
            
            config_path = temp_path / "config.json"
            if not config_path.exists() or not self._has_cover_image(temp_path):
                return None
            
            theme_name = Path(source_path).stem or "theme"
            theme_folder = temp_path / theme_name
            theme_folder.mkdir(exist_ok=True)
            
            for item in list(temp_path.iterdir()):
                if item == theme_folder or self._is_macos_metadata(item):
                    continue
                try:
                    shutil.move(str(item), str(theme_folder / item.name))
                except Exception as move_error:
                    silent_print(f"Warning: unable to move {item} into theme folder: {move_error}")
            return theme_folder
        except Exception as root_error:
            silent_print(f"Error preparing root theme folder: {root_error}")
            return None
    
    def merge_rockbox_folder(self, folder_path):
        """Install .rockbox folder contents to device automatically"""
        try:
            # Check for USB storage mode first - if detected, use USB storage mode directly
            usb_drive = self._detect_usb_storage_drive()
            if usb_drive:
                silent_print(f"USB Storage Mode detected, using USB storage drive for .rockbox folder merge: {usb_drive}")
                # Set flag to prevent ADB checks during USB operation
                self.adb_operation_in_progress = True
                try:
                    self._merge_rockbox_folder_via_usb(folder_path, usb_drive)
                finally:
                    self.adb_operation_in_progress = False
                return
            
            ready, snapshot = self._ensure_adb_capability('connected', "Install .rockbox folder")
            if not ready:
                return
            cached_device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            cached_hostname = snapshot.get('hostname')
            cached_device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            cached_device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            # Find ADB executable and device
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB is not available.")
                return
            
            import os
            import platform
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Use unified ADB status method
            status, connected_device_id, device_hostname, details = self.get_unified_adb_status(adb_path, env)
            if (status == 'no_adb' or not connected_device_id) and cached_device_id:
                connected_device_id = cached_device_id
                status = snapshot.get('status', 'adb_only')
                details = snapshot
                if not device_hostname:
                    device_hostname = cached_hostname
            
            if status == 'no_adb' or not connected_device_id:
                QMessageBox.warning(self, "Device Not Connected", "No ADB device is connected.")
                return
            
            # Set flag to prevent periodic ADB checks
            self.adb_operation_in_progress = True
            
            # Show progress
            self.status_label.setText("Installing Rockbox Theme...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            QApplication.processEvents()
            
            mountpoint = "/storage/sdcard0"
            device_rockbox_path = f"{mountpoint}/.rockbox"
            
            # Push folder contents to device - use wildcard to push contents, not the folder itself
            # This merges files into the existing .rockbox folder instead of creating a nested structure
            import os
            folder_path_obj = Path(folder_path)
            
            # Show status
            self.status_label.setText("Installing Rockbox Theme...")
            QApplication.processEvents()
            
            # Clean up macOS metadata from source folder before pushing
            self._cleanup_macos_metadata(folder_path)
            
            # Push each file/directory individually to merge into existing .rockbox
            # First, get list of all items in the folder (skip macOS metadata)
            items_to_push = []
            if folder_path_obj.is_dir():
                for item in folder_path_obj.iterdir():
                    # Skip macOS metadata files/folders
                    if self._is_macos_metadata(item):
                        silent_print(f"Skipping macOS metadata: {item}")
                        continue
                    items_to_push.append(item)
            
            if not items_to_push:
                QMessageBox.warning(self, "Empty Folder", "The .rockbox folder is empty.")
                self.progress_bar.setVisible(False)
                self.adb_operation_in_progress = False
                return
            
            # Push each item to the device's .rockbox folder
            self.progress_bar.setRange(0, len(items_to_push))
            failed_items = []
            
            for idx, item in enumerate(items_to_push):
                self.status_label.setText(f"Installing Rockbox Theme: {item.name}...")
                self.progress_bar.setValue(idx)
                QApplication.processEvents()
                
                # Push item to device's .rockbox folder
                adb_cmd = [str(adb_path), '-s', connected_device_id, 'push', str(item), device_rockbox_path]
                
                push_process = subprocess.Popen(
                    adb_cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                    universal_newlines=True,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
                
                # Read output line by line
                push_output = []
                while True:
                    output = push_process.stdout.readline()
                    if output == '' and push_process.poll() is not None:
                        break
                    if output:
                        line = output.strip()
                        if line:
                            push_output.append(line)
                            self.status_label.setText(f"ADB: {line}")
                            QApplication.processEvents()
                
                return_code = push_process.wait()
                
                if return_code != 0:
                    error_msg = '\n'.join(push_output) if push_output else "Unknown error"
                    failed_items.append(f"{item.name}: {error_msg}")
                    silent_print(f"Failed to push {item.name}: {error_msg}")
            
            # Update progress bar
            self.progress_bar.setValue(len(items_to_push))
            
            if failed_items:
                # Some items failed
                error_msg = f"Some items failed to install:\n\n" + "\n".join(failed_items[:5])
                if len(failed_items) > 5:
                    error_msg += f"\n... and {len(failed_items) - 5} more"
                self.status_label.setText("Partially installed Rockbox Theme")
                QMessageBox.warning(self, "Installation Partially Failed", error_msg)
                self.progress_bar.setVisible(False)
            else:
                # All items succeeded
                self.status_label.setText("Successfully installed Rockbox Theme")
                QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
            
            self.adb_operation_in_progress = False
            
        except Exception as e:
            silent_print(f"Error installing Rockbox Theme: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error installing Rockbox Theme: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
    
    def _merge_rockbox_folder_via_usb(self, folder_path, usb_drive_path):
        """Merge .rockbox folder contents via USB storage mode"""
        try:
            import shutil
            
            folder_path_obj = Path(folder_path)
            if not folder_path_obj.exists() or not folder_path_obj.is_dir():
                QMessageBox.warning(self, "Invalid Folder", "The selected folder does not exist or is not a directory.")
                return
            
            usb_path = Path(usb_drive_path)
            device_rockbox_path = usb_path / ".rockbox"
            
            # Ensure .rockbox directory exists
            device_rockbox_path.mkdir(parents=True, exist_ok=True)
            
            # Show progress
            self.status_label.setText("Installing Rockbox theme via USB storage mode...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            QApplication.processEvents()
            
            # Clean up macOS metadata from source folder before copying
            self._cleanup_macos_metadata(folder_path)
            
            # Get list of all items in the folder (skip macOS metadata)
            items_to_copy = []
            for item in folder_path_obj.iterdir():
                # Skip macOS metadata files/folders
                if self._is_macos_metadata(item):
                    silent_print(f"Skipping macOS metadata: {item}")
                    continue
                items_to_copy.append(item)
            
            if not items_to_copy:
                QMessageBox.warning(self, "Empty Folder", "The .rockbox folder is empty.")
                self.progress_bar.setVisible(False)
                return
            
            # Copy each item to the device's .rockbox folder
            self.progress_bar.setRange(0, len(items_to_copy))
            failed_items = []
            
            for idx, item in enumerate(items_to_copy):
                self.status_label.setText(f"Copying {item.name}...")
                self.progress_bar.setValue(idx)
                QApplication.processEvents()
                
                try:
                    dest_path = device_rockbox_path / item.name
                    
                    if item.is_file():
                        # Copy file
                        shutil.copy2(item, dest_path)
                        silent_print(f"Successfully copied file: {item.name}")
                    elif item.is_dir():
                        # Copy directory, merging if it already exists
                        if dest_path.exists():
                            # Merge directories
                            self._copy_tree_clean_metadata(item, dest_path)
                        else:
                            shutil.copytree(item, dest_path)
                            # Clean macOS metadata after copy
                            self._cleanup_macos_metadata(dest_path)
                        silent_print(f"Successfully copied directory: {item.name}")
                except Exception as e:
                    failed_items.append(f"{item.name}: {str(e)}")
                    silent_print(f"Failed to copy {item.name}: {e}")
            
            # Update progress bar
            self.progress_bar.setValue(len(items_to_copy))
            
            if failed_items:
                # Some items failed
                error_msg = f"Some items failed to install:\n\n" + "\n".join(failed_items[:5])
                if len(failed_items) > 5:
                    error_msg += f"\n... and {len(failed_items) - 5} more"
                self.status_label.setText("Partially installed Rockbox theme")
                QMessageBox.warning(
                    self,
                    "Installation Partially Failed",
                    error_msg + "\n\nFiles will be available after you turn off USB Storage Mode."
                )
                self.progress_bar.setVisible(False)
            else:
                # All items succeeded
                # Count themes installed (check for theme folders)
                theme_count = 0
                for item in items_to_copy:
                    if item.is_dir():
                        # Check if it's a theme folder (has config.json and cover.*)
                        config_path = item / "config.json"
                        cover_files = list(item.glob("cover.*"))
                        if config_path.exists() and cover_files:
                            theme_count += 1
                
                if theme_count > 0:
                    theme_word = "theme" if theme_count == 1 else "themes"
                    self.status_label.setText(f"Successfully installed {theme_count} Rockbox {theme_word}")
                    QMessageBox.information(
                        self,
                        "Installation Complete",
                        f"Successfully installed {theme_count} Rockbox {theme_word}.\n\n"
                        "Files will be available after you turn off USB Storage Mode."
                    )
                else:
                    self.status_label.setText("Successfully installed Rockbox theme")
                    QMessageBox.information(
                        self,
                        "Installation Complete",
                        "Successfully installed Rockbox theme.\n\n"
                        "Files will be available after you turn off USB Storage Mode."
                    )
                QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
            
        except Exception as e:
            silent_print(f"Error merging .rockbox folder via USB: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            QMessageBox.warning(self, "Error", f"Failed to merge .rockbox folder: {str(e)}")
    
    def _copy_tree_clean_metadata(self, src, dst):
        """Copy directory tree while cleaning macOS metadata files"""
        import shutil
        for item in src.iterdir():
            if self._is_macos_metadata(item):
                silent_print(f"Skipping macOS metadata: {item.name}")
                continue
            src_path = src / item.name
            dst_path = dst / item.name
            if src_path.is_dir():
                if dst_path.exists():
                    self._copy_tree_clean_metadata(src_path, dst_path)
                else:
                    shutil.copytree(src_path, dst_path)
                    self._cleanup_macos_metadata(dst_path)
            else:
                shutil.copy2(src_path, dst_path)
    
    def install_apk(self, apk_path):
        """Install APK file on device via ADB"""
        try:
            # Note: APK installation will work via ADB if available, or fail gracefully if USB Storage Mode is active
            # No need to prompt user to turn off USB Storage Mode - they can use USB Storage Mode for file transfers instead
            ready, snapshot = self._ensure_adb_capability('connected', "APK installation")
            if not ready:
                return
            is_rooted = bool(snapshot.get('rooted', False))
            # Find ADB executable and device
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB is not available.")
                return
            
            import os
            import platform
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Resolve connected device via unified status broker
            connected_device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            if not connected_device_id:
                status, connected_device_id, device_hostname, details = self.get_unified_adb_status(adb_path, env)
            else:
                status = snapshot.get('status', 'no_adb')
            if status == 'no_adb' or not connected_device_id:
                QMessageBox.warning(self, "Device Not Connected", "No ADB device is connected.")
                return
            
            # Verify APK file exists
            apk_path_obj = Path(apk_path)
            if not apk_path_obj.exists():
                QMessageBox.warning(self, "File Not Found", f"APK file not found: {apk_path}")
                return
            
            # Set flag to prevent periodic ADB checks
            self.adb_operation_in_progress = True
            
            # Show progress
            self.status_label.setText(f"Installing {apk_path_obj.name}...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            QApplication.processEvents()
            
            # Create and start APK install worker
            self.apk_worker = APKInstallWorker(adb_path, connected_device_id, env, str(apk_path_obj), is_rooted=is_rooted)
            self.apk_worker.status_update.connect(self._on_apk_install_status)
            self.apk_worker.completed.connect(self._on_apk_install_complete)
            self.apk_worker.start()
            
        except Exception as e:
            silent_print(f"Error installing APK: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error installing APK: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
            QMessageBox.warning(self, "Installation Error", f"Error installing APK: {str(e)}")
    
    def _on_apk_install_status(self, message):
        """Handle status updates from APK install worker"""
        self.status_label.setText(message)
        QApplication.processEvents()
    
    def _on_apk_install_complete(self, success, message):
        """Handle completion of APK installation"""
        self.adb_operation_in_progress = False
        self.progress_bar.setVisible(False)
        
        if success:
            self.status_label.setText(message)
            QTimer.singleShot(2000, lambda: self.status_label.setText(""))
            QMessageBox.information(self, "Installation Complete", message)
        else:
            self.status_label.setText(f"Installation failed: {message}")
            QMessageBox.warning(self, "Installation Failed", message)
    
    def merge_rockbox_zip(self, zip_path):
        """Extract and install .rockbox zip contents to device automatically"""
        try:
            ready, _ = self._ensure_adb_capability('connected', "Install .rockbox theme from zip")
            if not ready:
                return
            
            import tempfile
            
            # Extract to temporary directory
            temp_dir = tempfile.mkdtemp()
            try:
                self.status_label.setText("Extracting Rockbox Theme...")
                QApplication.processEvents()
                
                # Extract zip, filtering out macOS metadata
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                    for member in zip_ref.namelist():
                        # Skip macOS metadata files/folders
                        if self._is_macos_metadata(member):
                            silent_print(f"Skipping macOS metadata: {member}")
                            continue
                        
                        # Extract member with proper path handling
                        try:
                            zip_ref.extract(member, temp_dir)
                        except Exception as e:
                            silent_print(f"Error extracting {member}: {e}")
                            continue
                
                # Clean up any macOS metadata that might have been extracted
                self._cleanup_macos_metadata(temp_dir)
                
                # Find .rockbox folder in extracted contents
                rockbox_folder = None
                temp_path = Path(temp_dir)
                
                # Check if .rockbox is at root
                if (temp_path / '.rockbox').exists() and (temp_path / '.rockbox').is_dir():
                    rockbox_folder = temp_path / '.rockbox'
                else:
                    # Check subdirectories
                    for item in temp_path.iterdir():
                        if item.is_dir() and item.name.lower() == '.rockbox':
                            rockbox_folder = item
                            break
                    if not rockbox_folder:
                        for candidate in temp_path.rglob('.rockbox'):
                            if candidate.is_dir():
                                rockbox_folder = candidate
                                break
                
                if rockbox_folder:
                    # Merge the folder
                    self.merge_rockbox_folder(str(rockbox_folder))
                else:
                    QMessageBox.warning(self, "Invalid Zip", "Zip file does not contain a .rockbox folder.")
                    self.progress_bar.setVisible(False)
            finally:
                # Clean up temp directory
                try:
                    shutil.rmtree(temp_dir)
                except:
                    pass
        except Exception as e:
            silent_print(f"Error merging rockbox zip: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
    
    def get_unified_adb_status(self, adb_path=None, env=None, blocking=None, force_refresh=False):
        """
        Unified method to get ADB connection status.
        
        Args:
            adb_path: Optional override for the adb executable path.
            env: Optional environment mapping to pass to adb calls.
            blocking: When True, perform a fresh detection synchronously.
                      When False, return the cached snapshot and schedule an async refresh if needed.
                      Defaults to False on the GUI thread and True on background threads.
            force_refresh: When True, schedule a forced refresh even if the cached snapshot is fresh.
        
        Returns:
            ('no_adb' | 'adb_only' | 'adb_root', device_id, hostname, details_dict)
        """
        app = QApplication.instance()
        gui_thread = app.thread() if app else None
        is_gui_thread = gui_thread is not None and QThread.currentThread() == gui_thread

        if blocking is None:
            blocking = not is_gui_thread

        if blocking:
            status, device_id, hostname, details = self.adb_status_broker.compute_snapshot(adb_path, env)
            payload = {
                'status': status,
                'device_id': device_id,
                'hostname': hostname,
                'last_checked': datetime.now(),
            }
            if isinstance(details, dict):
                payload.update(details)
            snapshot = self.adb_status_broker.update_snapshot(**payload)
            self.adb_status_broker.flush_callbacks(snapshot)
            return status, device_id, hostname, details

        snapshot = self.adb_status_broker.get_snapshot() or {}
        status = snapshot.get('status', 'no_adb')
        device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
        hostname = snapshot.get('hostname')
        details = dict(snapshot)

        should_refresh = force_refresh
        last_checked = snapshot.get('last_checked')
        if not should_refresh:
            if not isinstance(last_checked, datetime):
                should_refresh = True
            else:
                try:
                    should_refresh = (datetime.now() - last_checked).total_seconds() > 3.0
                except Exception:
                    should_refresh = True

        if should_refresh:
            refresh_reason = "unified_status(force)" if force_refresh else "unified_status(stale)"
            self.adb_status_broker.request_refresh(force=force_refresh, reason=refresh_reason)

        return status, device_id, hostname, details
    
    def _get_connected_device_id(self, adb_path, env):
        """Helper function to get connected device ID (uses unified method)"""
        status, device_id, _, _ = self.get_unified_adb_status(adb_path, env)
        return device_id
    
    def install_theme_folder(self, theme_folder_path, connected_device_id, adb_path, env):
        """Install a single theme folder to device"""
        try:
            mountpoint = "/storage/sdcard0"
            themes_root = f"{mountpoint}/Themes"
            # Ensure Themes directory exists before pushing content
            try:
                subprocess.run(
                    [str(adb_path), '-s', connected_device_id, 'shell', f'mkdir -p {shlex.quote(themes_root)}'],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
            except Exception as mkdir_error:
                silent_print(f"Warning: unable to ensure Themes directory: {mkdir_error}")
            
            theme_path = Path(theme_folder_path)
            theme_name = theme_path.name
            
            # Remove any existing copy before pushing to avoid stale assets
            dest_path = f"{themes_root}/{theme_name}"
            try:
                subprocess.run(
                    [str(adb_path), '-s', connected_device_id, 'shell', f'rm -rf {shlex.quote(dest_path)}'],
                    capture_output=True,
                    text=True,
                    timeout=10,
                    env=env,
                    creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
                )
            except Exception as rm_error:
                silent_print(f"Warning: unable to remove existing theme {theme_name}: {rm_error}")
            
            # Push theme folder to device Themes directory
            self.status_label.setText(f"Pushing theme '{theme_name}' to Themes on Y1‚Ä¶")
            QApplication.processEvents()
            
            adb_cmd = [str(adb_path), '-s', connected_device_id, 'push', str(theme_path), themes_root]
            
            push_process = subprocess.Popen(
                adb_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True,
                env=env,
                creationflags=subprocess.CREATE_NO_WINDOW if platform.system() == "Windows" else 0
            )
            
            # Read output line by line
            while True:
                output = push_process.stdout.readline()
                if output == '' and push_process.poll() is not None:
                    break
                if output:
                    line = output.strip()
                    if line:
                        self.status_label.setText(f"ADB: {line}")
                        QApplication.processEvents()
            
            return_code = push_process.wait()
            return return_code == 0
        except Exception as e:
            silent_print(f"Error installing theme folder: {e}")
            return False
    
    def install_theme_folders(self, theme_folder_paths):
        """Install multiple theme folders to device automatically"""
        try:
            # Check for connection (ADB or USB drive) - prompt if needed
            has_connection, connection_type, usb_drive = self._ensure_connection_for_operation("install themes")
            if not has_connection:
                return
            
            # Check for USB storage mode first - if detected, use USB storage mode directly
            if connection_type == "usb_storage" and usb_drive:
                silent_print(f"USB Storage Mode detected, using USB storage drive for theme installation: {usb_drive}")
                # Set flag to prevent ADB checks during USB operation
                self.adb_operation_in_progress = True
                try:
                    self._install_themes_via_usb(theme_folder_paths, usb_drive)
                finally:
                    self.adb_operation_in_progress = False
                return
            
            ready, snapshot = self._ensure_adb_capability('connected', "Install theme folders")
            if not ready:
                return
            cached_device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            # Find ADB executable and device
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB is not available.")
                return
            
            import os
            import platform
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Get connected device ID
            connected_device_id = cached_device_id or self._get_connected_device_id(adb_path, env)
            
            if not connected_device_id:
                QMessageBox.warning(self, "Device Not Connected", "No ADB device is connected.")
                return
            
            # Set flag to prevent periodic ADB checks
            self.adb_operation_in_progress = True
            
            # Show progress
            self.status_label.setText(f"Preparing to install {len(theme_folder_paths)} theme(s)...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, len(theme_folder_paths))
            self.progress_bar.setValue(0)
            QApplication.processEvents()
            
            # Create and start worker thread
            self.theme_install_worker = ThemeInstallWorker(adb_path, connected_device_id, env, theme_folder_paths)
            self.theme_install_worker.status_update.connect(self._on_theme_install_status)
            self.theme_install_worker.progress_update.connect(self._on_theme_install_progress)
            self.theme_install_worker.completed.connect(self._on_theme_folders_install_complete)
            self.theme_install_worker.read_only_error.connect(self._on_theme_read_only_error)
            
            # Start worker thread
            self.theme_install_worker.start()
            
        except Exception as e:
            silent_print(f"Error preparing theme installation: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
    
    def _on_theme_read_only_error(self, theme_folders):
        """Handle read-only errors from theme install worker - fallback to USB storage mode"""
        silent_print(f"Read-only error detected for {len(theme_folders)} theme(s), falling back to USB storage mode")
        self.adb_operation_in_progress = False
        
        # Check for USB storage mode
        usb_drive = self._detect_usb_storage_drive()
        if usb_drive:
            silent_print(f"USB Storage Mode detected, retrying theme installation via USB: {usb_drive}")
            # Set flag to prevent ADB checks during USB operation
            self.adb_operation_in_progress = True
            try:
                self._install_themes_via_usb(theme_folders, usb_drive)
            finally:
                self.adb_operation_in_progress = False
        else:
            # No USB drive detected - theme installation requires USB Storage Mode or ADB
            self.status_label.setText("Theme installation failed (read-only). USB Storage Mode or ADB connection required.")
            self.progress_bar.setVisible(False)
            QMessageBox.warning(
                self,
                "Theme Installation Failed",
                "Theme installation failed because the device storage is read-only.\n\n"
                "Theme installation requires either:\n"
                "‚Ä¢ USB Storage Mode enabled, or\n"
                "‚Ä¢ ADB connection (USB or Wi-Fi)"
            )
    
    def _install_themes_via_usb(self, theme_folder_paths, usb_drive_path):
        """Install themes via USB storage mode"""
        try:
            import shutil
            
            usb_path = Path(usb_drive_path)
            themes_path = usb_path / ".rockbox" / "themes"
            
            # Ensure themes directory exists
            themes_path.mkdir(parents=True, exist_ok=True)
            
            # Show progress
            self.status_label.setText(f"Installing {len(theme_folder_paths)} theme(s) via USB storage mode...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, len(theme_folder_paths))
            self.progress_bar.setValue(0)
            QApplication.processEvents()
            
            success_count = 0
            failed_themes = []
            
            for i, theme_folder_path in enumerate(theme_folder_paths):
                try:
                    theme_path = Path(theme_folder_path)
                    theme_name = theme_path.name
                    
                    # Update progress
                    self.progress_bar.setValue(i)
                    self.status_label.setText(f"Copying theme '{theme_name}'...")
                    QApplication.processEvents()
                    
                    if not theme_path.exists():
                        failed_themes.append(f"{theme_name} (not found)")
                        continue
                    
                    # Copy theme folder to USB drive themes directory
                    dest_path = themes_path / theme_name
                    
                    if dest_path.exists():
                        # Remove existing theme first
                        shutil.rmtree(dest_path)
                    
                    # Copy theme folder, cleaning macOS metadata
                    shutil.copytree(theme_path, dest_path)
                    self._cleanup_macos_metadata(dest_path)
                    
                    success_count += 1
                    silent_print(f"Successfully copied theme '{theme_name}' to USB drive")
                    
                except Exception as e:
                    failed_themes.append(f"{Path(theme_folder_path).name} ({str(e)})")
                    silent_print(f"Error copying theme {theme_folder_path}: {e}")
            
            # Hide progress bar
            self.progress_bar.setVisible(False)
            
            # Show completion message
            if success_count == len(theme_folder_paths):
                self.status_label.setText(f"Successfully installed {success_count} theme(s) via USB storage mode")
                QMessageBox.information(
                    self,
                    "Theme Installation Complete",
                    f"Successfully installed {success_count} theme(s) to your Y1.\n\n"
                    f"Themes will be available after you turn off USB Storage Mode."
                )
            elif success_count > 0:
                self.status_label.setText(f"Installed {success_count} of {len(theme_folder_paths)} theme(s)")
                failed_list = '\n'.join(failed_themes)
                QMessageBox.warning(
                    self,
                    "Partial Installation",
                    f"Installed {success_count} of {len(theme_folder_paths)} theme(s).\n\n"
                    f"Failed themes:\n{failed_list}\n\n"
                    f"Themes will be available after you turn off USB Storage Mode."
                )
            else:
                self.status_label.setText("Theme installation failed")
                failed_list = '\n'.join(failed_themes)
                QMessageBox.warning(
                    self,
                    "Installation Failed",
                    f"Failed to install all themes:\n\n{failed_list}"
                )
            
            self.adb_operation_in_progress = False
            
        except Exception as e:
            silent_print(f"Error installing themes via USB: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
    
    def _on_theme_install_status(self, message):
        """Handle status updates from theme install worker"""
        self.status_label.setText(message)
        QApplication.processEvents()
    
    def _on_theme_install_progress(self, current, total):
        """Handle progress updates from theme install worker"""
        self.progress_bar.setRange(0, total)
        self.progress_bar.setValue(current)
        QApplication.processEvents()
    
    def start_redundant_files_cleanup(self):
        """Start redundant files cleanup in background thread"""
        try:
            # Create and start cleanup worker
            self.cleanup_worker = CleanupWorker()
            self.cleanup_worker.status_update.connect(self._on_cleanup_status)
            self.cleanup_worker.progress_update.connect(self._on_cleanup_progress)
            self.cleanup_worker.completed.connect(self._on_cleanup_complete)
            self.cleanup_worker.start()
        except Exception as e:
            silent_print(f"Error starting cleanup worker: {e}")
    
    def _on_cleanup_status(self, message):
        """Handle status updates from cleanup worker"""
        # Only show in status if it's significant (not just "No files to clean up")
        if "Cleaned up" in message or "Error" in message:
            silent_print(f"Cleanup: {message}")
    
    def _on_cleanup_progress(self, current, total):
        """Handle progress updates from cleanup worker"""
        # Progress is handled silently - no UI update needed for background cleanup
        pass
    
    def _on_cleanup_complete(self, removed_count):
        """Handle completion of cleanup"""
        if removed_count > 0:
            silent_print(f"Background cleanup completed: {removed_count} files removed")
        self.cleanup_worker = None
    
    def download_url_and_process(self, url_string):
        """Download URL and process the file based on its type"""
        try:
            if not self._ensure_adb_idle("a Smart Drop download"):
                return
            
            ready, snapshot = self._ensure_adb_capability('connected', "Smart Drop downloads")
            if not ready:
                return
            
            # Set flag to prevent periodic ADB checks during download
            self.adb_operation_in_progress = True
            
            # Show progress
            self.status_label.setText(f"Downloading from URL...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            QApplication.processEvents()
            
            # Create and start URL download worker
            self.url_download_worker = URLDownloadWorker(url_string)
            self.url_download_worker.status_update.connect(self._on_url_download_status)
            self.url_download_worker.progress_update.connect(self._on_url_download_progress)
            self.url_download_worker.completed.connect(self._on_url_download_complete)
            self.url_download_worker.start()
            
        except Exception as e:
            silent_print(f"Error starting URL download: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error downloading URL: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
            QMessageBox.warning(self, "Download Error", f"Error downloading URL: {str(e)}")
    
    def _on_url_download_status(self, message):
        """Handle status updates from URL download worker"""
        self.status_label.setText(message)
        QApplication.processEvents()
    
    def _on_url_download_progress(self, progress):
        """Handle progress updates from URL download worker"""
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(progress)
        QApplication.processEvents()
    
    def _on_url_download_complete(self, file_path, file_type):
        """Handle completion of URL download and process the file"""
        self.adb_operation_in_progress = False
        self.progress_bar.setVisible(False)
        
        if not file_path or file_type == "error":
            self.status_label.setText("Download failed")
            QMessageBox.warning(self, "Download Failed", "Failed to download file from URL.")
            return
        
        if file_type == "cancelled":
            self.status_label.setText("Download cancelled")
            return
        
        # Process file based on type
        try:
            if file_type == "theme_zip":
                # Install as Rockbox theme
                if hasattr(self, 'install_theme_zip'):
                    self.status_label.setText("Installing Rockbox Theme...")
                    QApplication.processEvents()
                    self.install_theme_zip(file_path)
                else:
                    QMessageBox.warning(self, "Not Supported", "Theme installation not available.")
            elif file_type == "rockbox_zip":
                # Install as .rockbox folder
                if hasattr(self, 'merge_rockbox_zip'):
                    self.status_label.setText("Installing Rockbox Theme...")
                    QApplication.processEvents()
                    self.merge_rockbox_zip(file_path)
                else:
                    QMessageBox.warning(self, "Not Supported", "Rockbox installation not available.")
            elif file_type == "rom_zip":
                # Process as rom.zip
                if hasattr(self, 'process_existing_zip'):
                    zip_path = Path(file_path)
                    repo_name = "rockbox-y1"  # Default
                    version = zip_path.stem
                    self.process_existing_zip(str(zip_path), repo_name, version)
                else:
                    QMessageBox.warning(self, "Not Supported", "Firmware installation not available.")
            elif file_type == "update_zip":
                # Process as update.zip
                is_connected, is_fast_update = self._check_adb_status()
                if is_fast_update:
                    # Use Fast Update
                    if hasattr(self, 'process_existing_zip'):
                        zip_path = Path(file_path)
                        repo_name = "rockbox-y1"  # Default
                        version = zip_path.stem
                        self.process_existing_zip(str(zip_path), repo_name, version)
                    else:
                        QMessageBox.warning(self, "Not Supported", "Fast Update not available.")
                else:
                    QMessageBox.warning(
                        self,
                        "Fast Update Not Available",
                        "Fast Update is not available. The device must be rooted and have the update script installed."
                    )
            elif file_type == "apk":
                # Install APK
                if hasattr(self, 'install_apk'):
                    self.status_label.setText("Installing APK...")
                    QApplication.processEvents()
                    self.install_apk(file_path)
                else:
                    QMessageBox.warning(self, "Not Supported", "APK installation not available.")
            else:
                # Transfer as regular file
                if hasattr(self, 'transfer_files_to_device'):
                    self.status_label.setText("Transferring file...")
                    QApplication.processEvents()
                    self.transfer_files_to_device([file_path])
                else:
                    QMessageBox.warning(self, "Not Supported", "File transfer not available.")
        except Exception as e:
            silent_print(f"Error processing downloaded file: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error processing file: {str(e)[:100]}")
            QMessageBox.warning(self, "Processing Error", f"Error processing downloaded file: {str(e)}")
    
    def _check_adb_status(self):
        """Check ADB status and return (is_connected, is_fast_update_enabled)"""
        try:
            if hasattr(self, 'get_cached_adb_status'):
                snapshot = self.get_cached_adb_status()
                status = snapshot.get('status', 'no_adb')
                is_connected = status in ('adb_only', 'adb_root')
                is_fast_update = bool(snapshot.get('fast_update_ready', False))
                if not is_connected and hasattr(self, 'request_adb_status_update'):
                    self.request_adb_status_update()
                return (is_connected, is_fast_update)
            return (False, False)
        except:
            return (False, False)
    
    def _on_theme_folders_install_complete(self, success, message):
        """Handle completion of theme folders installation"""
        try:
            if success:
                self.status_label.setText(message)
                if "of" in message and "theme(s)" in message:
                    # Partial success
                    QMessageBox.warning(self, "Partial Install", f"{message}. Some themes may have failed to install.")
                QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
            else:
                self.status_label.setText(message)
                QMessageBox.warning(self, "Install Failed", message)
                self.progress_bar.setVisible(False)
        finally:
            self.adb_operation_in_progress = False
    
    def install_theme_zip(self, zip_path):
        """Install theme zip to Themes folder on device automatically"""
        try:
            # Check for connection (ADB or USB drive) - prompt if needed
            has_connection, connection_type, usb_drive = self._ensure_connection_for_operation("install themes")
            if not has_connection:
                return
            
            # Check for USB storage mode first - if detected, use USB storage mode directly
            if connection_type == "usb_storage" and usb_drive:
                silent_print(f"USB Storage Mode detected, using USB storage drive for theme installation: {usb_drive}")
                # Set flag to prevent ADB checks during USB operation
                self.adb_operation_in_progress = True
                try:
                    # Extract and install via USB
                    self._install_theme_zip_via_usb(zip_path, usb_drive)
                finally:
                    self.adb_operation_in_progress = False
                return
            
            ready, snapshot = self._ensure_adb_capability('connected', "Install theme zip")
            if not ready:
                return
            cached_device_id = snapshot.get('active_device_id') or snapshot.get('device_id')
            # Find ADB executable and device
            adb_path = self.find_adb_executable()
            if not adb_path:
                QMessageBox.warning(self, "ADB Not Found", "ADB is not available.")
                return
            
            import os
            import platform
            import tempfile
            env = os.environ.copy()
            if platform.system() == "Darwin":
                homebrew_paths = ["/opt/homebrew/bin", "/usr/local/bin"]
                current_path = env.get("PATH", "")
                for brew_path in homebrew_paths:
                    if brew_path not in current_path:
                        env["PATH"] = f"{brew_path}:{env.get('PATH', '')}"
            
            # Get connected device ID
            connected_device_id = cached_device_id or self._get_connected_device_id(adb_path, env)
            
            if not connected_device_id:
                QMessageBox.warning(self, "Device Not Connected", "No ADB device is connected.")
                return
            
            # Set flag to prevent periodic ADB checks
            self.adb_operation_in_progress = True
            
            # Show progress
            self.status_label.setText("Installing theme to device...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            QApplication.processEvents()
            
            mountpoint = "/storage/sdcard0"
            themes_path = f"{mountpoint}/.rockbox/themes"
            
            # Extract zip to temporary directory
            temp_dir = tempfile.mkdtemp()
            try:
                self.status_label.setText("Extracting theme zip...")
                QApplication.processEvents()
                
                # Extract zip, filtering out macOS metadata
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                    for member in zip_ref.namelist():
                        # Skip macOS metadata files/folders
                        if self._is_macos_metadata(member):
                            silent_print(f"Skipping macOS metadata: {member}")
                            continue
                        
                        # Extract member with proper path handling
                        try:
                            # Use extract() instead of extractall() to handle paths with spaces
                            zip_ref.extract(member, temp_dir)
                        except Exception as e:
                            silent_print(f"Error extracting {member}: {e}")
                            # Continue with other files
                            continue
                
                # Clean up any macOS metadata that might have been extracted
                self._cleanup_macos_metadata(temp_dir)
                
                # Find all theme folders in extracted zip
                temp_path = Path(temp_dir)
                theme_folders = self._find_theme_folders(str(temp_path))
                if not theme_folders:
                    fallback_folder = self._prepare_theme_folder_from_root(temp_path, zip_path)
                    if fallback_folder:
                        theme_folders = [str(fallback_folder)]
                
                if theme_folders:
                    # Install all found theme folders - check for read-only errors and fallback to USB
                    success_count = 0
                    read_only_failed = False
                    for theme_folder in theme_folders:
                        if self.install_theme_folder(theme_folder, connected_device_id, adb_path, env):
                            success_count += 1
                        else:
                            # Check if it was a read-only error by trying to detect USB storage mode
                            usb_drive = self._detect_usb_storage_drive()
                            if usb_drive:
                                read_only_failed = True
                                break
                    
                    if read_only_failed:
                        # Fallback to USB storage mode
                        silent_print("Read-only error detected, falling back to USB storage mode for theme installation")
                        # Set flag to prevent ADB checks during USB operation
                        self.adb_operation_in_progress = True
                        try:
                            self._install_theme_zip_via_usb(zip_path, usb_drive)
                        finally:
                            self.adb_operation_in_progress = False
                    elif success_count == len(theme_folders):
                        self.status_label.setText(f"Successfully installed {success_count} theme(s) to device")
                        QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
                    elif success_count > 0:
                        self.status_label.setText(f"Installed {success_count} of {len(theme_folders)} theme(s)")
                        QMessageBox.warning(self, "Partial Install", f"Installed {success_count} of {len(theme_folders)} theme(s). Some themes may have failed to install.")
                        QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))
                    else:
                        self.status_label.setText("Error installing theme")
                        QMessageBox.warning(self, "Install Failed", "Failed to install theme to device.")
                        self.progress_bar.setVisible(False)
                else:
                    QMessageBox.warning(self, "Invalid Theme", "Theme zip does not contain config.json and a cover image (filename containing 'cover').")
                    self.progress_bar.setVisible(False)
            finally:
                # Clean up temp directory
                try:
                    shutil.rmtree(temp_dir)
                except:
                    pass
            
            self.adb_operation_in_progress = False
            
        except Exception as e:
            silent_print(f"Error installing theme: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
    
    def _install_theme_zip_via_usb(self, zip_path, usb_drive_path):
        """Install theme zip via USB storage mode"""
        try:
            import tempfile
            
            usb_path = Path(usb_drive_path)
            themes_path = usb_path / ".rockbox" / "themes"
            
            # Ensure themes directory exists
            themes_path.mkdir(parents=True, exist_ok=True)
            
            # Show progress
            self.status_label.setText("Extracting theme zip...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate
            QApplication.processEvents()
            
            # Extract zip to temporary directory
            temp_dir = tempfile.mkdtemp()
            try:
                # Extract zip, filtering out macOS metadata
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                    for member in zip_ref.namelist():
                        # Skip macOS metadata files/folders
                        if self._is_macos_metadata(member):
                            silent_print(f"Skipping macOS metadata: {member}")
                            continue
                        
                        # Extract member with proper path handling
                        try:
                            zip_ref.extract(member, temp_dir)
                        except Exception as e:
                            silent_print(f"Error extracting {member}: {e}")
                            continue
                
                # Clean up any macOS metadata that might have been extracted
                self._cleanup_macos_metadata(temp_dir)
                
                # Find all theme folders in extracted zip
                temp_path = Path(temp_dir)
                theme_folders = [Path(f) for f in self._find_theme_folders(str(temp_path))]
                if not theme_folders:
                    fallback_folder = self._prepare_theme_folder_from_root(temp_path, zip_path)
                    if fallback_folder:
                        theme_folders = [fallback_folder]
                
                if theme_folders:
                    # Install themes via USB
                    self._install_themes_via_usb([str(f) for f in theme_folders], usb_drive_path)
                else:
                    QMessageBox.warning(self, "Invalid Theme", "Theme zip does not contain config.json and a cover image (filename containing 'cover').")
                    self.progress_bar.setVisible(False)
            finally:
                # Clean up temp directory
                try:
                    shutil.rmtree(temp_dir)
                except:
                    pass
            
        except Exception as e:
            silent_print(f"Error installing theme zip via USB: {e}")
            import traceback
            traceback.print_exc()
            self.status_label.setText(f"Error: {str(e)[:100]}")
            self.progress_bar.setVisible(False)
            self.adb_operation_in_progress = False
    
    def on_update_send_completed(self, success, message, transfer_method="adb"):
        """Handle completion of update.zip send operation"""
        silent_print(f"Update send completed: success={success}, message={message}, method={transfer_method}")
        if hasattr(self, 'adb_operation_in_progress'):
            self.adb_operation_in_progress = False
        
        self.progress_bar.setVisible(False)
        
        # Re-enable buttons
        self.download_btn.setEnabled(True)
        if hasattr(self, 'send_update_btn'):
            self.send_update_btn.setEnabled(True)
        
        if success:
            silent_print("Update sent successfully! Showing completion dialog...")
            self.status_label.setText("Update sent successfully!")
            
            # Try to run the update script via ADB after USB transfer
            script_success = self.run_update_script_via_adb()
            
            # Track successful fast update for post-reboot ADB status check delay
            if script_success and transfer_method == "adb":
                # Mark that we just completed a fast update - device will reboot
                self._fast_update_just_completed = True
                self._fast_update_completion_time = time.time()
                silent_print("Fast update completed successfully - device will reboot, delaying ADB status checks")
            
            # Get software name for the note
            selected_item = self.package_list.currentItem()
            software_name = "this firmware"
            if selected_item and selected_item.data(Qt.UserRole):
                release_info = selected_item.data(Qt.UserRole)
                software_name = release_info.get('software_name', 'this firmware')
            
            # Show completion dialog with instructions
            if script_success:
                QMessageBox.information(
                    self,
                    "Update Complete! ‚úÖ",
                    f"‚úÖ update.zip has been sent to your Y1.\n\n"
                    f"‚úÖ Update script executed successfully via ADB.\n\n"
                    f"Your Y1 will restart and apply the update automatically.\n\n"
                    f"After reboot, the app will automatically detect Fast Update capability."
                )
                # Delay ADB status refresh after reboot (device needs time to initialize)
                # Wait 30 seconds after expected reboot time for device to fully initialize
                QTimer.singleShot(35000, lambda: self._refresh_adb_status_after_fast_update())
            elif transfer_method == "usb_storage":
                # Only show "IMPORTANT - PLEASE READ" dialog for USB Storage Mode transfers
                QMessageBox.information(
                    self,
                    "Update Sent Successfully! ‚úÖ",
                    f"‚ö†Ô∏è IMPORTANT - PLEASE READ:\n\n"
                    f"If this is the FIRST TIME you install {software_name} on your Y1, if you don't see the Firmware Update option in Main Menu > System, you'll need to use a tool like Innioasis Updater (+ SP Flash Tool or MTKclient) to do this update the first time.\n\n"
                    f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
                    f"üì± Installation Instructions:\n\n"
                    f"1. Safely disconnect your Y1\n\n"
                    f"2. Go to Main Menu > System and click Firmware Update\n\n"
                    f"3. The update process will now run in the background and automatically restart the device once it is done"
                )
            else:
                # ADB transfer but script didn't run - show simple message
                QMessageBox.information(
                    self,
                    "Update Sent Successfully! ‚úÖ",
                    f"‚úÖ update.zip has been sent to your Y1.\n\n"
                    f"Please check your device for update status."
                )
        else:
            # Fail gracefully - don't show error dialog, just update status
            self.status_label.setText("Update transfer completed")
            silent_print(f"Update send failed gracefully: {message}")

    def run_driver_setup(self):
        """Runs the driver setup script (main.py)"""
        try:
            # Get the current directory where firmware_downloader.py is located
            current_dir = Path(__file__).parent
            main_py_path = current_dir / "main.py"

            if not main_py_path.exists():
                QMessageBox.warning(self, "Error", "main.py not found. Please ensure main.py is in the same directory as firmware_downloader.py.")
                return

            # Run main.py
            silent_print("Running main.py for driver setup...")
            self.status_label.setText("Running driver setup...")
            self.download_btn.setEnabled(False) # Disable download button while running
            self.settings_btn.setEnabled(False) # Disable settings button while running

            # Use subprocess to run main.py in the current directory
            if platform.system() == "Windows":
                subprocess.Popen([sys.executable, str(main_py_path)], cwd=str(current_dir), 
                               creationflags=subprocess.CREATE_NO_WINDOW)
            else:
                subprocess.Popen([sys.executable, str(main_py_path)], cwd=str(current_dir))

            # After main.py finishes, revert to startup state
            QTimer.singleShot(1000, self.revert_to_startup_state) # Small delay to allow main.py to start

        except Exception as e:
            silent_print(f"Error running driver setup: {e}")
            self.status_label.setText(f"Error running driver setup: {e}")
            self.download_btn.setEnabled(True)
            self.settings_btn.setEnabled(True)

    def revert_to_startup_state(self):
        """Revert the app to its startup state"""
        # Cancel any existing revert timer to prevent conflicts
        if hasattr(self, '_revert_timer') and self._revert_timer:
            self._revert_timer.stop()
            self._revert_timer = None

        # Load and display presteps.png (startup state)
        self.load_presteps_image()
        
        # Restore left panel to default state
        self.show_left_panel()

        # Reset status
        self.status_label.setText("Ready")

        # Ensure download button is enabled
        self.download_btn.setEnabled(True)
        # Ensure settings button is enabled
        if hasattr(self, 'settings_btn'):
            self.settings_btn.setEnabled(True)
        # Ensure toolkit button is enabled for all platforms
        if hasattr(self, 'toolkit_btn'):
            self.toolkit_btn.setEnabled(True)

    def populate_package_list(self):
        """Populate the package list widget with release information"""
        self.package_list.clear()

        for package in self.packages:
            device_model = package.get('device', '')

            # Device type is now determined from release tags, not manifest
            device_type_text = ""
            device_model_text = f" [{device_model}]" if device_model else ""

            # Get latest release information
            release_info = self.github_api.get_latest_release(package['repo'])
            release_text = ""
            if release_info:
                release_text = f"\nLatest Release: {release_info.get('tag_name', 'Unknown')}"
                if release_info.get('name'):
                    release_text += f" ({release_info['name']})"

            item_text = f"{package['name']}{device_type_text}{device_model_text}\n"
            item_text += f"Repo: {package['repo']}{release_text}\n"
            item_text += f"Handler: {package['handler']}"

            item = QListWidgetItem(item_text)
            item.setData(Qt.UserRole, package)
            self.package_list.addItem(item)

        # Automatically select the first item for improved discoverability
        if self.package_list.count() > 0:
            self.package_list.setCurrentRow(0)
            self.package_list.setFocus()  # Give focus to the list for blue highlight
            self.download_btn.setEnabled(True)
            self.settings_btn.setEnabled(True)
            if hasattr(self, 'toolkit_btn'):
                self.toolkit_btn.setEnabled(True)
            print("DEBUG: Settings button enabled when package selected")
            # Update button text for the first selected item
            first_item = self.package_list.item(0)
            self.update_download_button_text(first_item)

    def update_device_type_visibility(self):
        """Show/hide device type controls based on selected model"""
        selected_model = self.device_model_combo.currentText()
        
        # Show device type controls only if model is or contains "Y1"
        show_type_controls = "Y1" in selected_model.upper()
        
        self.device_type_label.setVisible(show_type_controls)
        self.device_type_combo.setVisible(show_type_controls)
        self.type_help_btn.setVisible(show_type_controls)
    
    def filter_firmware_options(self):
        """Filter software options based on device type and model"""
        # Update device type visibility based on selected model
        self.update_device_type_visibility()
        
        # Repopulate software combo with filtered options
        self.populate_firmware_combo()

        # Update the releases list based on current software selection
        selected_repo = self.firmware_combo.currentData()
        if selected_repo:
            # Specific software selected - show only its releases
            self.populate_releases_list()
        else:
            # "All Software" selected - show all releases
            self.populate_all_releases_list()



    def start_download(self):
        """Start the download and processing process"""
        # Check online status before starting download
        # This prevents users from attempting downloads when offline
        if not self.is_online():
            QMessageBox.warning(
                self,
                "Offline Mode",
                "You are currently offline. Please connect to the internet to download firmware.\n\n"
                "Alternatively, use 'Browse Files' to install firmware from a local file."
            )
            return
        
        if not self._ensure_adb_idle("Install / Restore"):
            return
        
        # Cancel any existing revert timer to prevent conflicts
        if hasattr(self, '_revert_timer') and self._revert_timer:
            self._revert_timer.stop()
            self._revert_timer = None

        # Stop any existing MTK worker to prevent conflicts
        if hasattr(self, 'mtk_worker') and self.mtk_worker:
            self.mtk_worker.stop()
            self.mtk_worker.wait()
            self.mtk_worker = None

        current_item = self.package_list.currentItem()
        if not current_item:
            self.status_label.setText("Error: Please select a release from the list")
            return

        release_info = current_item.data(Qt.UserRole)

        if not release_info:
            self.status_label.setText("Error: Please select a valid release from the list")
            return

        # Get the repository from the release info (for "All Firmware" selection)
        # or from the firmware combo (for specific firmware selection)
        selected_repo = self.firmware_combo.currentData()

        # If "All Software" is selected, we need to get the repo from the release info
        if not selected_repo and 'software_name' in release_info:
            # This is from "All Software" - find the repo for this software
            software_name = release_info['software_name']
            for package in self.packages:
                if package.get('name') == software_name:
                    selected_repo = package.get('repo')
                    break

        if not selected_repo:
            self.status_label.setText("Error: Could not determine repository for selected release")
            return

        if not release_info:
            QMessageBox.warning(self, "Error", f"Failed to get release information for {selected_repo}")
            return

        if not release_info['download_url']:
            # Show what assets are available
            error_msg = f"No rom.zip found in release {selected_repo} for {selected_repo}\n\n"
            error_msg += f"Release: {release_info.get('tag_name', 'Unknown')}\n"
            error_msg += f"Name: {release_info.get('name', 'Unknown')}\n\n"
            error_msg += "Available assets:\n"

            # Try to get asset list for better error reporting
            try:
                url = f"https://api.github.com/repos/{selected_repo}/releases"
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    releases_data = response.json()
                    for release in releases_data:
                        if release.get('tag_name') == selected_repo: # This line seems to be a typo, should be release.get('tag_name')
                            assets = release.get('assets', [])
                            if assets:
                                for asset in assets:
                                    error_msg += f"- {asset['name']}\n"
                            else:
                                error_msg += "- No assets found\n"
                            break
                else:
                    error_msg += "- Could not retrieve asset list\n"
            except:
                error_msg += "- Could not retrieve asset list\n"

            QMessageBox.warning(self, "Error", error_msg)
            return

        # Check if zip file already exists locally
        zip_path = get_zip_path(selected_repo, release_info['tag_name'])
        if zip_path.exists():
            # Zip already exists - check for Fast Update before proceeding
            if self.is_device_fast_update_enabled():
                # Check if this release has update.zip
                assets = release_info.get('assets', [])
                has_update_zip = any(
                    asset.get('name', '').lower() == 'update.zip'
                    for asset in assets
                )
                
                if has_update_zip:
                    # Offer Fast Update instead of regular install
                    reply = QMessageBox.question(
                        self,
                        "Fast Update Available",
                        "Are you sure you want to do a full clean install of this firmware?\n\n"
                        "Your device appears to have Fast Update available, which will keep your bluetooth settings and personal apps in place.\n\n"
                        "Would you like to use Fast Update instead?",
                        QMessageBox.Yes | QMessageBox.No,
                        QMessageBox.Yes
                    )
                    
                    if reply == QMessageBox.Yes:
                        # User chose Fast Update - switch to Fast Update
                        # Find update.zip URL and set it
                        update_asset = next(
                            (asset for asset in assets if asset.get('name', '').lower() == 'update.zip'),
                            None
                        )
                        if update_asset:
                            self.current_update_zip_url = update_asset.get('browser_download_url')
                            # Try Fast Update
                            if self.try_adb_fast_update():
                                return  # Fast Update started, exit
                        # If Fast Update failed or no update.zip found, fall through to regular install
                    # If user chose No, continue with regular install
            
            # Zip already exists - check if ARM64 user can use it
            if platform.system() == "Windows":
                driver_info = self.check_drivers_and_architecture()
                if driver_info['is_arm64']:
                    # ARM64 Windows: Only allow Fast Updates, block full installs
                    # Check if this release has update.zip
                    assets = release_info.get('assets', [])
                    has_update_zip = any(
                        asset.get('name', '').lower() == 'update.zip'
                        for asset in assets
                    )
                    
                    if has_update_zip and self.is_device_fast_update_enabled():
                        # Has update.zip and device supports Fast Update - offer Fast Update
                        update_asset = next(
                            (asset for asset in assets if asset.get('name', '').lower() == 'update.zip'),
                            None
                        )
                        if update_asset:
                            self.current_update_zip_url = update_asset.get('browser_download_url')
                            if self.try_adb_fast_update():
                                return  # Fast Update started, exit
                    else:
                        # No update.zip or device doesn't support Fast Update - skip silently
                        silent_print("ARM64 Windows detected without Fast Update capability for this release; skipping install.")
                        self.status_label.setText("Fast Update isn't available for this release on Windows ARM64.")
                        return
            
            # Zip already exists - automatically use it for seamless experience
            silent_print(f"Using existing zip file: {zip_path.name}")
            self.status_label.setText("Using existing zip file. Extracting...")
            self.process_existing_zip(zip_path, selected_repo, release_info['tag_name'])
            return

        # Check for Fast Update before starting regular download
        if self.is_device_fast_update_enabled():
            # Check if this release has update.zip
            assets = release_info.get('assets', [])
            has_update_zip = any(
                asset.get('name', '').lower() == 'update.zip'
                for asset in assets
            )
            
            if has_update_zip:
                # Offer Fast Update instead of regular install
                reply = QMessageBox.question(
                    self,
                    "Fast Update Available",
                    "Are you sure you want to do a full clean install of this firmware?\n\n"
                    "Your device appears to have Fast Update available, which will keep your bluetooth settings and personal apps in place.\n\n"
                    "Would you like to use Fast Update instead?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                
                if reply == QMessageBox.Yes:
                    # User chose Fast Update - switch to Fast Update
                    # Find update.zip URL and set it
                    update_asset = next(
                        (asset for asset in assets if asset.get('name', '').lower() == 'update.zip'),
                        None
                    )
                    if update_asset:
                        self.current_update_zip_url = update_asset.get('browser_download_url')
                        # Try Fast Update
                        if self.try_adb_fast_update():
                            return  # Fast Update started, exit
                    # If Fast Update failed or no update.zip found, fall through to regular install
                # If user chose No, continue with regular install

        # Check if ARM64 user is trying to do a full install (block it)
        if platform.system() == "Windows":
            driver_info = self.check_drivers_and_architecture()
            if driver_info['is_arm64']:
                # ARM64 Windows: Block full installs, only allow Fast Updates
                silent_print("ARM64 Windows detected during Install/Restore; operation skipped.")
                self.status_label.setText("Install / Restore isn't available on Windows ARM64. Please use Fast Update.")
                return

        # Check storage space before starting download/extraction (full firmware install requires 6GB)
        # Note: Fast Updates have already exited above, so this is always a full install
        has_enough_space, available_gb, error_message = self._check_storage_space(required_gb=6)
        if not has_enough_space:
            QMessageBox.warning(
                self,
                "Insufficient Storage Space",
                error_message
            )
            self.status_label.setText(f"Insufficient storage space ({available_gb:.2f} GB available, 6 GB required)")
            return

        # Switch from release notes view to image view when download starts
        if hasattr(self, 'image_notes_stack') and self.image_notes_stack:
            self.image_notes_stack.setCurrentIndex(0)  # Switch to image view (page 0)
            # Update title back to "Getting Ready:" when showing images
            if hasattr(self, 'output_group'):
                self.output_group.setTitle("Getting Ready:")
        
        # Show paperclip message during download
        self.show_paperclip_message()
        
        # Start download worker
        self.download_worker = DownloadWorker(release_info['download_url'], selected_repo, release_info['tag_name'])
        self.download_worker.progress_updated.connect(self.progress_bar.setValue)
        self.download_worker.status_updated.connect(self.status_label.setText)
        self.download_worker.download_completed.connect(self.on_download_completed)

        self.download_btn.setEnabled(False)
        self.settings_btn.setEnabled(False)
        self.progress_bar.setVisible(True)
        self.progress_bar.setValue(0)

        silent_print(f"Starting download for {selected_repo}...")
        silent_print(f"Release: {release_info['tag_name']}")
        silent_print(f"Download URL: {release_info['download_url']}")

        self.download_worker.start()

    def process_existing_zip(self, zip_path, repo_name, version):
        """Process an existing zip file (extract and prepare for installation)"""
        try:
            # Convert zip_path to Path object if it's a string
            if isinstance(zip_path, str):
                zip_path = Path(zip_path)
            
            # Check if ARM64 user is trying to do a full install (block it)
            if platform.system() == "Windows":
                driver_info = self.check_drivers_and_architecture()
                if driver_info['is_arm64']:
                    # ARM64 Windows: silently prevent full installs
                    silent_print("ARM64 Windows: process_existing_zip aborted (Install/Restore unavailable).")
                    self.status_label.setText("Install / Restore isn't available on Windows ARM64. Please use Fast Update.")
                    return
            
            # Check storage space before extracting (full firmware install requires 6GB)
            has_enough_space, available_gb, error_message = self._check_storage_space(required_gb=6)
            if not has_enough_space:
                QMessageBox.warning(
                    self,
                    "Insufficient Storage Space",
                    error_message
                )
                self.status_label.setText(f"Insufficient storage space ({available_gb:.2f} GB available, 6 GB required)")
                return
            
            # Switch from release notes view to image view when extraction starts
            if hasattr(self, 'image_notes_stack') and self.image_notes_stack:
                self.image_notes_stack.setCurrentIndex(0)  # Switch to image view (page 0)
                # Update title back to "Getting Ready:" when showing images
                if hasattr(self, 'output_group'):
                    self.output_group.setTitle("Getting Ready:")
            
            # Show paperclip message during extraction
            self.show_paperclip_message()
            
            self.status_label.setText("Extracting existing zip file...")
            self.progress_bar.setVisible(True)
            self.progress_bar.setValue(0)
            
            # Simulate progress for zip processing
            self.progress_bar.setValue(25)
            self.status_label.setText("Extracting existing zip file...")
            
            # Extract the zip file
            extracted_files = []
            with zipfile.ZipFile(str(zip_path), 'r') as zip_ref:
                extracted_files = safe_extractall(zip_ref, ".", zip_path.name)
            
            # Log extracted files for cleanup
            log_extracted_files(extracted_files)
            
            self.progress_bar.setValue(75)
            self.status_label.setText("Checking required files...")
            
            # Check if required files exist
            required_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
            missing_files = []
            for file in required_files:
                if not Path(file).exists():
                    missing_files.append(file)
            
            if missing_files:
                self.progress_bar.setVisible(False)
                error_msg = f"Missing required files: {', '.join(missing_files)}"
                self.status_label.setText("Missing required firmware files.")
                QMessageBox.warning(self, "Missing Files", error_msg)
                return
            
            self.progress_bar.setValue(100)
            self.status_label.setText("Extraction completed. Files ready for installation.")
            
            # Handle installation based on selected method
            silent_print("=== FIRMWARE FILES READY ===")
            silent_print(f"Selected installation method: {getattr(self, 'installation_method', 'guided')}")
            
            # Use QTimer to delay the installation method execution slightly
            QTimer.singleShot(2000, self.handle_installation_method)  # 2 second delay
            
        except Exception as e:
            self.progress_bar.setVisible(False)
            error_msg = f"Error processing existing zip file: {str(e)}"
            QMessageBox.critical(self, "Error", error_msg)
            self.status_label.setText("Error processing existing zip file.")
            silent_print(f"Existing zip processing error: {e}")
        
        finally:
            # Hide progress bar after processing
            QTimer.singleShot(2000, lambda: self.progress_bar.setVisible(False))

    def on_download_completed(self, success, output):
        """Handle download completion"""
        self.download_btn.setEnabled(True)
        self.settings_btn.setEnabled(True)
        self.progress_bar.setVisible(False)

        if success:
            self.status_label.setText("Download and processing completed successfully")
            print("=== PROCESSING COMPLETED ===")
            print("Firmware files have been downloaded and extracted successfully.")

            # Check if required files exist and handle installation based on selected method
            required_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
            if all(Path(file).exists() for file in required_files):
                silent_print("=== FIRMWARE FILES READY ===")
                silent_print(f"Selected installation method: {getattr(self, 'installation_method', 'guided')}")

                # Handle installation based on selected method
                QTimer.singleShot(2000, self.handle_installation_method)  # 2 second delay
        else:
            self.status_label.setText("Download or processing failed")
            silent_print("=== PROCESSING FAILED ===")

        silent_print(output)

    def handle_installation_method(self):
        """Handle installation based on the selected method in settings"""
        # Check storage space before starting installation (full firmware install requires 6GB)
        # Note: This is always a full install, not Fast Update, so storage check is required
        has_enough_space, available_gb, error_message = self._check_storage_space(required_gb=6)
        if not has_enough_space:
            QMessageBox.warning(
                self,
                "Insufficient Storage Space",
                error_message
            )
            self.status_label.setText(f"Insufficient storage space ({available_gb:.2f} GB available, 6 GB required)")
            return
        
        # Check driver status for Windows users
        if platform.system() == "Windows":
            driver_info = self.check_drivers_and_architecture()
            
            if driver_info['is_arm64']:
                # ARM64 Windows: No installation methods available
                silent_print("=== ARM64 WINDOWS - NO INSTALLATION METHODS AVAILABLE ===")
                self.status_label.setText("Install / Restore is unavailable on Windows ARM64.")
                return
                
            elif not driver_info['can_install_firmware'] and not driver_info.get('has_mtk_driver') and not driver_info.get('has_usbdk_driver'):
                # No drivers detected: Show warning but allow fallback methods instead of blocking
                silent_print("=== NO SPECIFIC DRIVERS DETECTED - USING FALLBACK METHODS ===")
                QMessageBox.information(
                    self,
                    "Using Fallback Methods",
                    "No specific drivers detected. The application will attempt installation using default methods.\n\n"
                    "If installation fails, consider installing drivers for better compatibility.\n\n"
                    "Click OK to continue with fallback methods or Cancel to install drivers."
                )
                # Continue with fallback methods instead of returning
                
            else:
                # Use selected method (driver validation will happen later)
                method = getattr(self, 'installation_method', 'guided')
        else:
            # Non-Windows: Use selected method
            method = getattr(self, 'installation_method', 'guided')
        
        silent_print(f"Handling installation method: {method}")
        
        # Store the attempted method for "Try Again" functionality
        self.last_attempted_method = method
        
        if platform.system() == "Windows":
            # Check if the selected method is available based on drivers
            available_methods = driver_info.get('available_methods', ['guided', 'mtkclient'])
            if method not in available_methods:
                # Method not available, fall back to first available method
                if available_methods:
                    method = available_methods[0]
                    silent_print(f"Selected method not available, falling back to: {method}")
                else:
                    # Ultimate fallback: use guided method to avoid blocking functionality
                    method = 'guided'
                    silent_print(f"No specific methods available, using fallback method: {method}")
            
            # Windows method order: SP Flash Tool methods first, then Guided/MTKclient
            if method == "spflash":
                # Method 1: Guided - same as pressing "Try Method 3" in troubleshooting
                silent_print("=== RUNNING GUIDED METHOD 1 ===")
                # Show Method 3 image and launch SP Flash Tool
                self.load_method3_image()
                self.try_method_3()
            elif method == "spflash4":
                # Method 2: SP Flash Tool GUI - launches SP Flash Tool - GUI.lnk from Toolkit directory
                silent_print("=== RUNNING SP FLASH TOOL GUI METHOD 2 ===")
                # Launch SP Flash Tool GUI directly
                self.try_method_4()
            elif method == "spflash_console":
                # Method 3: SP Flash Tool Console Mode - launches SP Flash Tool.lnk from Toolkit directory
                silent_print("=== RUNNING SP FLASH TOOL CONSOLE MODE METHOD 3 ===")
                # Show Method 3 image and launch SP Flash Tool Console Mode
                self.load_method3_image()
                self.try_method_3_console()
            elif method == "guided":
                # Method 4: Guided process
                silent_print("=== RUNNING GUIDED INSTALLATION (SP FLASH TOOL GUI METHOD) ===")
                silent_print("The MTK flash command will now run in this application.")
                silent_print("Please turn off your Y1 when prompted.")
                self.run_mtk_command_guided()
            elif method == "mtkclient":
                # Method 5: MTKclient (advanced) - same as pressing "Try Method 2" in troubleshooting
                silent_print("=== RUNNING MTKCLIENT (ADVANCED) METHOD 5 ===")
                # Show Method 2 image and launch recovery firmware install
                self.load_method2_image()
                self.show_troubleshooting_instructions()
            else:
                # Fallback to SP Flash Tool method 1 if invalid method
                silent_print("=== FALLING BACK TO SP FLASH TOOL METHOD 1 ===")
                self.load_method3_image()
                self.try_method_3()
        else:
            # Non-Windows: Original method order
            if method == "guided":
                # Method 1: Normal guided process (default behavior)
                silent_print("=== RUNNING GUIDED INSTALLATION ===")
                silent_print("The MTK flash command will now run in this application.")
                silent_print("Please turn off your Y1 when prompted.")
                self.run_mtk_command_guided()
            elif method == "mtkclient":
                # Method 2: in Terminal method - same as pressing "Try Method 2" in troubleshooting
                silent_print("=== RUNNING MTKCLIENT METHOD ===")
                # Show Method 2 image and launch recovery firmware install
                self.load_method2_image()
                self.show_troubleshooting_instructions()
            else:
                # Fallback to guided method if invalid method
                silent_print("=== FALLING BACK TO GUIDED METHOD ===")
                self.run_mtk_command_guided()
        
        # Method always defaults to Method 1 on app restart, no need to reset here

    def refresh_all_data(self):
        """Refresh all data (tokens, manifest, device types, models, software) with cache clearing"""
        self.status_label.setText("Refreshing data...")
        silent_print("Refreshing data...")

        # Clear cache to force fresh data
        clear_cache()

        # Download tokens
        tokens = self.config_downloader.download_config()
        if not tokens:
            silent_print("ERROR: Failed to download API tokens")
            QMessageBox.warning(self, "Error", "Failed to download API tokens. Please check your internet connection or try again later.")
            return

        self.github_api = GitHubAPI(tokens)
        silent_print(f"Loaded {len(tokens)} API tokens")

        # Download manifest
        self.packages = self.config_downloader.download_manifest()
        if not self.packages:
            silent_print("ERROR: Failed to download manifest")
            QMessageBox.warning(self, "Error", "Failed to download software manifest. Please check your internet connection or try again later.")
            return

        silent_print(f"Loaded {len(self.packages)} software packages")

        # Repopulate all combos
        self.populate_device_type_combo()
        self.populate_device_model_combo()
        self.populate_firmware_combo()

        # Apply initial filters (Type A and Y1 are already set as defaults)
        self.filter_firmware_options()

        # Show releases based on current software selection (not always "All Software")
        try:
            selected_repo = self.firmware_combo.currentData()
            if selected_repo:
                self.populate_releases_list()
            else:
                self.populate_all_releases_list_progressive()

            self.status_label.setText("Ready")
            silent_print("Data refresh complete.")
        except Exception as e:
            silent_print(f"Error populating releases: {e}")
            self.status_label.setText("Error loading releases - check internet connection")
            # Show a basic message to prevent complete failure
            self.package_list.clear()
            self.package_list.addItem("Error: Could not load releases. Please check your internet connection and try again.")

    def is_dark_mode(self):
        """Detect if the system is in dark mode - consistent with _get_text_color_for_theme"""
        try:
            # Check if the application is using a dark theme
            palette = self.palette()
            bg_color = palette.color(palette.ColorRole.Window)
            # Use lightness (same as _get_text_color_for_theme) for consistency
            is_dark = bg_color.lightness() < 128
            return is_dark
        except:
            # Fallback: try theme monitor
            try:
                if hasattr(self, 'theme_monitor') and self.theme_monitor:
                    current_theme = self.theme_monitor._get_current_theme()
                    return current_theme == "dark"
            except:
                pass
            # Fallback: assume light mode if detection fails
            return False

    def update_image_style(self):
        """Update the image label style based on system theme"""
        is_dark = self.is_dark_mode()
        self.update_creator_label()

        if is_dark:
            # Dark theme styling - use transparent background to preserve PNG transparency
            self.image_label.setStyleSheet("""
                QLabel {
                    background-color: transparent;
                    border: 0.5px solid #2a2a2a;
                    border-radius: 3px;
                    color: white;
                }
            """)
        else:
            # Light theme styling - use transparent background to preserve PNG transparency
            self.image_label.setStyleSheet("""
                QLabel {
                    background-color: transparent;
                    border: 0.5px solid #f0f0f0;
                    border-radius: 3px;
                    color: #333;
                }
            """)

    def refresh_button_styles(self):
        """Native buttons handle their own styling - no intervention needed"""
        pass
    
    def refresh_release_notes_on_theme_change(self):
        """Refresh release notes display when theme changes to update text color"""
        try:
            # Update release notes browser styling
            if hasattr(self, 'release_notes_browser') and self.release_notes_browser:
                try:
                    text_color = self._get_text_color_for_theme()
                    self.release_notes_browser.setStyleSheet(f"""
                        QTextBrowser {{
                            background-color: transparent;
                            border: none;
                            padding: 10px;
                            color: {text_color};
                        }}
                    """)
                except Exception as style_err:
                    silent_print(f"Error updating release notes browser style: {style_err}")
            
            # Check if release notes are currently displayed
            if not hasattr(self, 'image_notes_stack') or not self.image_notes_stack:
                return
            
            # Check if we're currently showing release notes (not the image)
            if self.image_notes_stack.currentIndex() != 1:
                return  # Not showing release notes, no need to refresh
            
            # Get currently selected release
            if not hasattr(self, 'package_list') or not self.package_list:
                return
            
            current_item = self.package_list.currentItem()
            if not current_item:
                return
            
            # Get release data
            release_info = current_item.data(Qt.UserRole)
            if not release_info or not isinstance(release_info, dict):
                return
            
            # Check if it's a link (not a release)
            if release_info.get('is_link'):
                return
            
            # Re-render the release notes with new theme-aware color
            # Temporarily disable the flag to allow re-rendering
            self._displaying_release_notes = False
            try:
                # Re-call on_release_selected to re-render with new theme color
                self.on_release_selected(current_item)
            finally:
                self._displaying_release_notes = False
        except Exception as e:
            silent_print(f"Error refreshing release notes on theme change: {e}")
        
        # Also refresh offline message if it's displayed
        try:
            # Check if offline message might be displayed
            if hasattr(self, 'left_panel') and self.left_panel:
                if not self.left_panel.isVisible():
                    # Left panel is hidden, offline message might be shown
                    # Check if we're showing release notes area
                    if hasattr(self, 'image_notes_stack') and self.image_notes_stack:
                        if self.image_notes_stack.currentIndex() == 1:
                            # Check if there are no releases (offline state)
                            if hasattr(self, 'package_list') and self.package_list:
                                if self.package_list.count() == 0:
                                    # Refresh offline message
                                    has_tokens = hasattr(self.github_api, 'tokens') and len(self.github_api.tokens) > 0
                                    self._show_offline_message(has_tokens)
        except Exception as e:
            silent_print(f"Error refreshing offline message on theme change: {e}")
        
        # Refresh What's New tab if it exists
        try:
            if hasattr(self, 'whats_new_browser') and self.whats_new_browser:
                # Get current version
                current_version = APP_VERSION
                try:
                    version_file = Path(".version")
                    if version_file.exists():
                        with open(version_file, 'r') as f:
                            current_version = f.read().strip() or APP_VERSION
                except:
                    pass
                
                # Get theme-aware text color
                text_color = self._get_text_color_for_theme()
                
                # Re-load release notes with new theme color
                self.load_whats_new_release_notes(self.whats_new_browser)
        except Exception as e:
            silent_print(f"Error refreshing What's New on theme change: {e}")

    def check_theme_change(self):
        """Theme change detection disabled - native buttons handle styling"""
        pass

    def on_palette_changed(self):
        """Handle system theme changes (legacy method)"""
        self.update_image_style()

    def ensure_proper_image_sizing(self):
        """Ensure proper image sizing after window is fully initialized"""
        if hasattr(self, '_presteps_pixmap') and self._presteps_pixmap:
            self.set_image_with_aspect_ratio(self._presteps_pixmap)

    def switch_to_labs_version(self, event):
        """Switch between firmware_downloader.py and test.py versions"""
        try:
            current_file = Path(__file__).name
            if current_file == "test.py":
                # Currently running test.py, switch to firmware_downloader.py
                target_file = "firmware_downloader.py"
                target_script = "python firmware_downloader.py"
            else:
                # Currently running firmware_downloader.py, switch to test.py
                target_file = "test.py"
                target_script = "python test.py"
            
            # Check if target file exists
            if not Path(target_file).exists():
                # If target is test.py, try to download it
                if target_file == "test.py":
                    if self.download_test_py():
                        # File downloaded successfully, continue with launch
                        pass
                    else:
                        QMessageBox.warning(self, "Download Failed", 
                                          "Could not download test.py from innioasis.app. Please check your internet connection.")
                        return
                else:
                    QMessageBox.warning(self, "File Not Found", 
                                      f"Could not find {target_file}. Please ensure both files are in the same directory.")
                    return
            
            # Show confirmation dialog
            if current_file == "test.py":
                # Currently in labs mode, asking to disable
                dialog_title = "Disable Labs Mode"
                dialog_text = f"Testing features are currently ENABLED (running {current_file}).\n\n"
                dialog_text += f"Would you like to go back to the stable version ({target_file})?\n\n"
                dialog_text += "This will close the current application and launch the stable version."
            else:
                # Currently in stable mode, asking to enable
                dialog_title = "Enable Labs Mode"
                dialog_text = f"Testing features are currently DISABLED (running {current_file}).\n\n"
                dialog_text += f"Would you like to enable experimental features ({target_file})?\n\n"
                dialog_text += "This will close the current application and launch the labs version."
            
            reply = QMessageBox.question(
                self,
                dialog_title,
                dialog_text,
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            
            if reply == QMessageBox.Yes:
                # Launch the target script
                if platform.system() == "Windows":
                    subprocess.Popen([sys.executable, target_file], 
                                   creationflags=subprocess.CREATE_NO_WINDOW)
                else:
                    subprocess.Popen([sys.executable, target_file])
                
                # Close the current app after a short delay
                QTimer.singleShot(1000, self.close)
                
        except Exception as e:
            QMessageBox.warning(self, "Switch Error", f"Error switching versions: {str(e)}")

    def _handle_update_from_settings(self, settings_dialog):
        """Handle update button pressed within Settings dialog"""
        version = getattr(self, '_latest_app_version', None)
        if version:
            self.show_update_release_notes(version)
        else:
            QMessageBox.information(self, "Up to Date", "You're already running the latest version.")

    def show_update_release_notes(self, version):
        """Show release notes dialog for the latest update"""
        try:
            # Get release data from stored cache or fetch it
            release_data = self._get_release_data(version)
            
            if not release_data:
                # Fallback: show simple message and allow update
                reply = QMessageBox.question(
                    self,
                    "Update Available",
                    f"Version {version} is now available.\n\n"
                    "Would you like to update now?",
                    QMessageBox.Yes | QMessageBox.No,
                    QMessageBox.Yes
                )
                if reply == QMessageBox.Yes:
                    self.launch_updater_script()
                return
            
            # Create dialog
            dialog = QDialog(self)
            dialog.setWindowTitle(f"Update Available - {version}")
            dialog.setMinimumWidth(600)
            dialog.setMinimumHeight(500)
            
            layout = QVBoxLayout(dialog)
            
            # Release notes browser
            browser = QTextBrowser()
            browser.setReadOnly(True)
            browser.setStyleSheet("""
                QTextBrowser {
                    background-color: transparent;
                    border: 1px solid #ccc;
                    padding: 10px;
                }
            """)
            
            # Get theme-aware text color
            text_color = self._get_text_color_for_theme()
            
            # Format release notes
            release_notes = release_data.get('body', '')
            release_name = release_data.get('name', '') or release_data.get('tag_name', '')
            
            # Use the same formatting logic as What's New tab
            self._format_release_notes_for_display(browser, release_notes, release_name, text_color)
            
            layout.addWidget(browser)
            
            # Buttons
            button_layout = QHBoxLayout()
            button_layout.addStretch()
            
            cancel_btn = QPushButton("Cancel")
            cancel_btn.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_btn)
            
            update_btn = QPushButton("Update Now")
            update_btn.setDefault(True)
            update_btn.clicked.connect(lambda: self._confirm_and_update(dialog))
            button_layout.addWidget(update_btn)
            
            layout.addLayout(button_layout)
            
            # Show dialog
            dialog.exec()
            
        except Exception as e:
            silent_print(f"Error showing update release notes: {e}")
            import traceback
            traceback.print_exc()
            # Fallback: show simple message
            reply = QMessageBox.question(
                self,
                "Update Available",
                f"Version {version} is now available.\n\n"
                "Would you like to update now?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            if reply == QMessageBox.Yes:
                self.launch_updater_script()
    
    def _format_release_notes_for_display(self, browser, release_notes, release_name, text_color):
        """Format release notes for display in browser (shared with What's New)"""
        try:
            import html as html_module
            import re
            
            # Show loading message
            loading_html = f"""<html>
            <head>
                <style>
                    body, div, p {{ color: {text_color} !important; }}
                </style>
            </head>
            <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>
                <p style='color: {text_color} !important;'>Loading release notes...</p>
            </body>
            </html>"""
            browser.setHtml(loading_html)
            
            if release_notes and release_name:
                # Escape release name
                safe_release_name = html_module.escape(str(release_name))
                
                notes_html = f"""<html>
                <head>
                    <style>
                        body, div, p, h1, h2, h3, h4, h5, h6, ul, ol, li, span, a {{
                            color: {text_color} !important;
                        }}
                    </style>
                </head>
                <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>"""
                notes_html += f"<h2 style='margin-top: 0; color: {text_color} !important;'>{safe_release_name}</h2>"
                
    # 2025-11-09 22:10:00 UTC - original: The full release body rendered, including preface text above the Changes section.
                filtered_notes = str(release_notes)
                try:
                    raw_lines = filtered_notes.splitlines()
                    anchor_index = None
                    for idx, raw_line in enumerate(raw_lines):
                        stripped = raw_line.strip()
                        if stripped and stripped.lower().startswith("changes"):
                            anchor_index = idx + 1
                            break
                    if anchor_index is not None and anchor_index < len(raw_lines):
                        filtered_notes = "\n".join(raw_lines[anchor_index:]).lstrip()
                    else:
                        filtered_notes = filtered_notes.lstrip()
                    if not filtered_notes.strip():
                        filtered_notes = str(release_notes)
                except Exception as filter_err:
                    silent_print(f"Error trimming release notes to Changes section: {filter_err}")
                    filtered_notes = str(release_notes)

                # Convert markdown to HTML (same logic as What's New)
                body_html = filtered_notes
                body_html = html_module.escape(body_html)
                
                lines = body_html.split('\n')
                converted_lines = []
                in_list = False
                
                for line in lines:
                    line_stripped = line.strip()
                    
                    # Check for headers
                    if line_stripped.startswith('### '):
                        text = line_stripped[4:].strip()
                        if not in_list:
                            converted_lines.append(f'<h4 style="color: {text_color} !important;">{text}</h4>')
                        else:
                            converted_lines.append('</ul>')
                            converted_lines.append(f'<h4 style="color: {text_color} !important;">{text}</h4>')
                            in_list = False
                    elif line_stripped.startswith('## '):
                        text = line_stripped[3:].strip()
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        converted_lines.append(f'<h3 style="color: {text_color} !important;">{text}</h3>')
                    elif line_stripped.startswith('# '):
                        text = line_stripped[2:].strip()
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        converted_lines.append(f'<h2 style="color: {text_color} !important;">{text}</h2>')
                    # Check for lists
                    elif line_stripped.startswith('- ') or line_stripped.startswith('* '):
                        if not in_list:
                            converted_lines.append(f'<ul style="color: {text_color} !important;">')
                            in_list = True
                        text = line_stripped[2:].strip()
                        text = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)
                        converted_lines.append(f'<li style="color: {text_color} !important;">{text}</li>')
                    elif line_stripped == '':
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        converted_lines.append('<br>')
                    else:
                        if in_list:
                            converted_lines.append('</ul>')
                            in_list = False
                        if line_stripped:
                            processed_line = line_stripped
                            processed_line = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', processed_line)
                            converted_lines.append(f'<span style="color: {text_color} !important;">{processed_line}</span><br>')
                
                # Close any open list
                if in_list:
                    converted_lines.append('</ul>')
                
                body_html = ''.join(converted_lines)
                if body_html.strip():
                    if not body_html.strip().startswith('<'):
                        body_html = f'<p style="color: {text_color} !important;">{body_html}</p>'
                
                notes_html += body_html
                notes_html += "</body></html>"
                
                browser.setHtml(notes_html)
            else:
                error_html = f"""<html>
                <head>
                    <style>
                        body, div, p {{ color: {text_color} !important; }}
                    </style>
                </head>
                <body style='font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, Arial, sans-serif; line-height: 1.6; padding: 10px; color: {text_color} !important;'>
                    <p style='color: {text_color} !important;'>Release notes could not be loaded.</p>
                </body>
                </html>"""
                browser.setHtml(error_html)
        except Exception as e:
            silent_print(f"Error formatting release notes: {e}")
            import traceback
            traceback.print_exc()
    
    def _confirm_and_update(self, dialog):
        """Confirm update and launch updater script"""
        dialog.accept()
        self.launch_updater_script()

    def launch_updater_script(self):
        """Silently download and run the latest updater script"""
        # REMOVED: Legacy updater.py method no longer used - app handles updates internally
        # Updates are now handled directly by the app
        QMessageBox.information(
            self,
            "Update Available",
            "Please use the 'Download Selected Version' button in Settings > Update Available / Version tab to update the app."
        )

    def terminate_conflicting_processes_for_update(self):
        """Terminate adb and libusb processes before launching updater"""
        try:
            if platform.system() == "Windows":
                # Windows: Use taskkill to terminate processes
                processes_to_kill = ['adb.exe', 'libusb-1.0.dll']
                
                for process_name in processes_to_kill:
                    try:
                        # Find and kill processes by name
                        result = subprocess.run(['tasklist', '/FO', 'CSV'], 
                                              capture_output=True, text=True, timeout=5)
                        
                        if result.returncode == 0:
                            for line in result.stdout.split('\n'):
                                if process_name.lower() in line.lower():
                                    # Extract PID from CSV format
                                    parts = line.split(',')
                                    if len(parts) >= 2:
                                        pid = parts[1].strip('"')
                                        try:
                                            # Kill the process
                                            subprocess.run(['taskkill', '/PID', pid, '/F'], 
                                                          capture_output=True, timeout=5)
                                            silent_print(f"Terminated {process_name} (PID: {pid}) for update")
                                        except subprocess.TimeoutExpired:
                                            silent_print(f"Timeout killing {process_name} (PID: {pid})")
                                        except Exception as e:
                                            silent_print(f"Error killing {process_name}: {e}")
                    except Exception as e:
                        silent_print(f"Error checking for {process_name}: {e}")
                        
            else:
                # Linux/macOS: Use pkill to terminate processes
                processes_to_kill = ['adb', 'libusb']
                
                for process_name in processes_to_kill:
                    try:
                        subprocess.run(['pkill', '-f', process_name], 
                                      capture_output=True, timeout=5)
                        silent_print(f"Terminated {process_name} processes for update")
                    except subprocess.TimeoutExpired:
                        silent_print(f"Timeout killing {process_name} processes")
                    except Exception as e:
                        silent_print(f"Error killing {process_name}: {e}")
            
            silent_print("Process cleanup completed for update")
            
        except Exception as e:
            silent_print(f"Warning: Could not terminate all conflicting processes: {e}")

    def show_install_error_dialog(self):
        """Show the comprehensive install error dialog with troubleshooting options"""
        # Show comprehensive troubleshooting dialog on all platforms
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Installation Issue")
        msg_box.setText("The firmware installation encountered an issue. This could be due to:\n\n"
                       "‚Ä¢ USB cable was disconnected during installation\n"
                       "‚Ä¢ Connection issue between device and computer\n"
                       "‚Ä¢ Problem with the ROM file used\n"
                       "‚Ä¢ Driver issues or need to reboot PC after installing drivers\n"
                       "‚Ä¢ USB was connected too early during installation\n\n"
                       "Would you like to try a different approach?")
        msg_box.setIcon(QMessageBox.Warning)
        
        # Create simplified buttons: Try Again, Settings, Quit App
        try_again_btn = msg_box.addButton("Try Again", QMessageBox.ActionRole)
        settings_btn = msg_box.addButton("Settings", QMessageBox.ActionRole)
        quit_app_btn = msg_box.addButton("Quit App", QMessageBox.RejectRole)
        
        # Set default button
        msg_box.setDefaultButton(try_again_btn)
        
        reply = msg_box.exec()
        
        clicked_button = msg_box.clickedButton()
        
        if clicked_button == try_again_btn:
            # Try Again - use Method 1 (default method for the platform)
            self.ensure_mtk_process_terminated()  # Ensure MTK process is terminated
            if platform.system() == "Windows":
                # Windows: Use guided SP Flash Tool process (Method 1)
                remove_installation_marker()
                self.try_method_3()
            else:
                # Non-Windows: Use guided MTKclient process (Method 1)
                # Don't clear marker here - it will be cleared after successful installation
                self.show_unplug_prompt_and_retry()
        elif clicked_button == settings_btn:
            # Settings - clear marker, revert to startup state, and open settings dialog
            remove_installation_marker()
            self.revert_to_startup_state()
            self.show_settings_dialog()
        else:
            # Quit App - revert to startup state and exit the application
            self.revert_to_startup_state()
            QApplication.quit()

    def show_unplug_prompt_and_retry(self):
        """Show the unplug Y1 prompt and retry normal installation"""
        # Show the same unplug prompt that's used at the start of normal installation
        reply = QMessageBox.question(
            self,
            "Get Ready",
            "Please make sure your Y1 is NOT plugged in and press OK, then follow the next instructions.",
            QMessageBox.Ok | QMessageBox.Cancel,
            QMessageBox.Cancel
        )

        if reply == QMessageBox.Cancel:
            return

        # Clean up libusb state before starting new MTK operation (Windows only)
        if platform.system() == "Windows":
            self.cleanup_libusb_state()

        # Create installation marker to track progress
        create_installation_marker()

        # Load and display the presteps image first, initsteps will be shown when mtk.py emits first empty line
        self.load_presteps_image()
        
        # Hide left panel for Method 1 installation to focus user attention on instructions
        self.hide_left_panel()

        # Start MTK worker
        # Create debug window if debug mode is enabled
        debug_window = None
        if getattr(self, 'debug_mode', False):
            debug_window = DebugOutputWindow(self)
            debug_window.show()
        
        self.mtk_worker = MTKWorker(debug_mode=getattr(self, 'debug_mode', False), debug_window=debug_window)
        self.mtk_worker.status_updated.connect(self.status_label.setText)
        self.mtk_worker.show_installing_image.connect(self.load_installing_image)
        self.mtk_worker.show_please_wait_image.connect(self.load_please_wait_image)
        self.mtk_worker.show_initsteps_image.connect(self.load_initsteps_image)
        self.mtk_worker.show_instructions_image.connect(self.load_initsteps_image)
        self.mtk_worker.mtk_completed.connect(self.on_mtk_completed)
        self.mtk_worker.handshake_failed.connect(self.on_handshake_failed)
        self.mtk_worker.errno2_detected.connect(self.on_errno2_detected)
        self.mtk_worker.usb_io_error_detected.connect(self.on_usb_io_error_detected)
        self.mtk_worker.backend_error_detected.connect(self.on_backend_error_detected)
        self.mtk_worker.keyboard_interrupt_detected.connect(self.on_keyboard_interrupt_detected)
        self.mtk_worker.disable_update_button.connect(self.disable_update_button)
        self.mtk_worker.enable_update_button.connect(self.enable_update_button)

        self.mtk_worker.start()

        # Disable download button during MTK operation
        self.download_btn.setEnabled(False)
        self.settings_btn.setEnabled(False)

    def show_troubleshooting_instructions(self):
        """Show troubleshooting instructions and launch recovery firmware install"""
        # Show Method 2 image when troubleshooting instructions are displayed
        self.load_method2_image()
        
        if platform.system() == "Windows":
            # Windows: Check if shortcut exists, download if missing
            if not self.ensure_recovery_shortcut():
                return
            
            # Windows-specific Method 2 instructions
            instructions = ("Please follow these steps after you click OK:\n\n"
                          "1. INSERT Paperclip\n"
                          "2. CONNECT your Y1 via USB\n"
                          "3. INSERT Paperclip again\n"
                          "4. WAIT for install to finish then disconnect your Y1\n"
                          "5. HOLD middle button to restart\n\n"
                          "This method shows technical installation details. If it fails, try Method 3 (SP Flash Tool Console Mode).")
        else:
            # Non-Windows baseline Method 2 instructions
            instructions = ("We'll now take you to Terminal to show you what's happening under the hood:\n\n"
                          "\n"
                          "Make sure you have your Y1 disconnected from your computer\n")
        
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("Troubleshooting Instructions - Method 2")
        msg_box.setText(instructions)
        msg_box.setIcon(QMessageBox.Information)
        msg_box.setStandardButtons(QMessageBox.Ok)
        msg_box.setDefaultButton(QMessageBox.Ok)
        
        reply = msg_box.exec()
        
        if reply == QMessageBox.Ok:
            # Launch recovery firmware installer (platform-specific)
            self.launch_recovery_firmware_install()

    def stop_flash_tool_processes(self):
        """Stop any running flash_tool.exe processes to prevent conflicts on Windows"""
        if platform.system() != "Windows":
            return  # Only needed on Windows
            
        try:
            # Use tasklist to find flash_tool.exe processes
            result = subprocess.run(
                ["tasklist", "/FI", "IMAGENAME eq flash_tool.exe", "/FO", "CSV"],
                capture_output=True,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                flash_tool_processes = []
                
                for line in lines[1:]:  # Skip header line
                    if 'flash_tool.exe' in line:
                        # Extract PID from CSV format
                        parts = line.split(',')
                        if len(parts) >= 2:
                            pid = parts[1].strip('"')
                            if pid.isdigit():
                                flash_tool_processes.append(pid)
                
                if flash_tool_processes:
                    silent_print(f"Found {len(flash_tool_processes)} flash_tool.exe processes, stopping them...")
                    
                    # Stop each flash_tool.exe process
                    for pid in flash_tool_processes:
                        try:
                            subprocess.run(
                                ["taskkill", "/PID", pid, "/F"],
                                capture_output=True,
                                creationflags=subprocess.CREATE_NO_WINDOW
                            )
                        except Exception as e:
                            silent_print(f"Failed to stop flash_tool.exe process {pid}: {e}")
                    
                    # Give processes time to terminate (non-blocking)
                    # Note: Removed blocking sleep to improve startup performance
                    
                    silent_print(f"Stopped {len(flash_tool_processes)} flash_tool.exe processes")
                else:
                    silent_print("No flash_tool.exe processes found")
            else:
                silent_print("Could not check for flash_tool.exe processes")
                
        except Exception as e:
            silent_print(f"Error checking for flash_tool.exe processes: {e}")

    def stop_mtk_processes(self):
        """Stop any running mtk.py processes to prevent libusb conflicts on Windows"""
        if platform.system() != "Windows":
            return  # Only needed on Windows
            
        try:
            # Use tasklist to find mtk.py processes
            result = subprocess.run(
                ["tasklist", "/FI", "IMAGENAME eq python.exe", "/FO", "CSV"],
                capture_output=True,
                text=True,
                creationflags=subprocess.CREATE_NO_WINDOW
            )
            
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                mtk_processes = []
                
                for line in lines[1:]:  # Skip header line
                    if 'mtk.py' in line:
                        # Extract PID from CSV format
                        parts = line.split(',')
                        if len(parts) >= 2:
                            pid = parts[1].strip('"')
                            if pid.isdigit():
                                mtk_processes.append(pid)
                
                if mtk_processes:
                    self.status_label.setText(f"Found {len(mtk_processes)} mtk.py processes, stopping them...")
                    
                    # Stop each mtk.py process
                    for pid in mtk_processes:
                        try:
                            subprocess.run(
                                ["taskkill", "/PID", pid, "/F"],
                                capture_output=True,
                                creationflags=subprocess.CREATE_NO_WINDOW
                            )
                        except Exception as e:
                            print(f"Failed to stop mtk.py process {pid}: {e}")
                    
                    # Give processes time to terminate
                    import time
                    time.sleep(1)
                    
                    self.status_label.setText(f"Stopped {len(mtk_processes)} mtk.py processes")
                else:
                    self.status_label.setText("No mtk.py processes found")
                    
        except Exception as e:
            self.status_label.setText(f"Error checking for mtk.py processes: {e}")
            print(f"Error checking for mtk.py processes: {e}")

    def cleanup_libusb_state(self):
        """Clean up libusb state before starting new MTK operations (Windows only)
        
        IMPORTANT: This function should ONLY be called BEFORE starting new MTK operations,
        NEVER during active flashing/installation. It helps resolve libusb conflicts
        that occur when previous MTK processes didn't clean up properly.
        """
        if platform.system() != "Windows":
            return  # Only needed on Windows
            
        try:
            self.status_label.setText("Cleaning up libusb state...")
            
            # Method 1: Try to clear USB device cache using pnputil
            try:
                subprocess.run(
                    ["pnputil", "/enum-devices", "/class", "USB"],
                    capture_output=True,
                    creationflags=subprocess.CREATE_NO_WINDOW,
                    timeout=5
                )
                # This refreshes the USB device list without restarting anything
            except Exception as e:
                print(f"USB device refresh failed: {e}")
            
            # Method 2: Try to reset USB hub service (more aggressive but safer than device restart)
            try:
                # Check if USB hub service is running
                result = subprocess.run(
                    ["sc", "query", "usbhub"],
                    capture_output=True,
                    creationflags=subprocess.CREATE_NO_WINDOW,
                    timeout=5
                )
                
                if result.returncode == 0 and "RUNNING" in result.stdout:
                    # Service is running, try to restart it
                    subprocess.run(
                        ["sc", "stop", "usbhub"],
                        capture_output=True,
                        creationflags=subprocess.CREATE_NO_WINDOW,
                        timeout=5
                    )
                    import time
                    time.sleep(2)  # Wait for service to stop
                    
                    subprocess.run(
                        ["sc", "start", "usbhub"],
                        capture_output=True,
                        creationflags=subprocess.CREATE_NO_WINDOW,
                        timeout=5
                    )
                    time.sleep(3)  # Wait for service to start
                    
                    self.status_label.setText("USB hub service restarted to clear libusb conflicts")
                else:
                    self.status_label.setText("USB hub service not running, skipping restart")
                    
            except Exception as e:
                print(f"USB hub service restart failed: {e}")
            
            # Method 3: Wait a bit for USB subsystem to stabilize
            import time
            time.sleep(2)
            
            self.status_label.setText("Libusb state cleanup completed")
            
        except Exception as e:
            print(f"Error during libusb cleanup: {e}")
            self.status_label.setText("Libusb cleanup failed, continuing anyway")
            # Continue anyway - this is not critical


    def launch_recovery_firmware_install(self):
        """Launch the recovery firmware installer"""
        try:
            if platform.system() == "Windows":
                # Windows: Check if shortcut exists, download if missing
                if not self.ensure_recovery_shortcut():
                    return
                    
                # Look for the .lnk file in the same directory as firmware_downloader.py
                current_dir = Path.cwd()
                recovery_lnk = current_dir / "Recover Firmware Install.lnk"
                
                # On Windows, use os.startfile to launch the .lnk file
                os.startfile(str(recovery_lnk))
                self.status_label.setText("Recovery Firmware Install launched successfully")
            else:
                # Linux/macOS: Open terminal with MTK command
                current_dir = Path.cwd()
                
                # Check if required files exist
                required_files = ["lk.bin", "boot.img", "recovery.img", "system.img", "userdata.img"]
                missing_files = []
                for file in required_files:
                    if not Path(file).exists():
                        missing_files.append(file)

                if missing_files:
                    QMessageBox.warning(
                        self, 
                        "Missing Files", 
                        f"Required firmware files are missing: {', '.join(missing_files)}\n\n"
                        "Please ensure you have extracted the firmware files to the current directory."
                    )
                    return
                
                # Construct the MTK command (same as used in regular installation)
                mtk_command = f"cd '{current_dir}' && python3 mtk.py w uboot,bootimg,recovery,android,usrdata lk.bin,boot.img,recovery.img,system.img,userdata.img"
                
                if platform.system() == "Linux":
                    # Linux: Open terminal with MTK command in separate window
                    terminal_cmd = ["gnome-terminal", "--title=Innioasis Recovery", "--", "bash", "-c", f"{mtk_command}; exec bash"]
                    # Try alternative terminals if gnome-terminal fails
                    alternatives = [
                        ["xterm", "-title", "Innioasis Recovery", "-e", f"bash -c '{mtk_command}; exec bash'"],
                        ["konsole", "--title", "Innioasis Recovery", "-e", f"bash -c '{mtk_command}; exec bash'"],
                        ["xfce4-terminal", "--title=Innioasis Recovery", "-e", f"bash -c '{mtk_command}; exec bash'"]
                    ]
                    
                    success = False
                    for cmd in [terminal_cmd] + alternatives:
                        try:
                            subprocess.Popen(cmd, start_new_session=True)
                            success = True
                            break
                        except FileNotFoundError:
                            continue
                    
                    if not success:
                        QMessageBox.warning(
                            self,
                            "Terminal Not Found",
                            "Could not find a suitable terminal emulator.\n\n"
                            "Please open a terminal manually and run:\n"
                            f"{mtk_command}"
                        )
                        return
                        
                elif platform.system() == "Darwin":  # macOS
                    # macOS: Open Terminal.app with MTK command and activate venv
                    venv_path = Path.home() / "Library/Application Support/Innioasis Updater/venv"
                    script_content = f"""#!/bin/bash
    # Set terminal title
    echo -ne "\\033]0;Innioasis Recovery\\007"

    cd '{current_dir}'

    # Activate virtual environment if it exists
    if [ -f "{venv_path}/bin/activate" ]; then
    source "{venv_path}/bin/activate"
    echo "Virtual environment activated"
    fi

    echo "=========================================="
    echo "  Innioasis Recovery Firmware Install"
    echo "=========================================="
    echo ""
    echo "This terminal window will now run the necessary command needed to install your chosen firmware with MTKclient (mtk.py)"
    echo ""
    echo "Thank you to u/wa-a-melyn from r/innioasis for documenting this process in an accessible way."
    echo ""
    echo "IMPORTANT INSTRUCTIONS:"
    echo "1. Make sure your Y1 device is disconnected from the USB port"
    echo "2. Put your device into Download Mode (Use paperclip to power off)"
    echo "3. Then after pressing Enter..."
    echo "4. Connect your Y1 to the computer by USB"
    echo "5. Wait for the process to complete - this may take several minutes"
    echo "6. Your device will restart automatically when finished"
    echo ""
    echo ""
    echo "Press Enter to start the installation process..."
    read -n 1
    echo ""
    echo "Starting Innioasis Recovery Firmware Install..."
    echo "python3 mtk.py w uboot,bootimg,recovery,android,usrdata lk.bin,boot.img,recovery.img,system.img,userdata.img
    "
    echo ""

    # Run MTK command with python3 (same as used in regular installation)
    python3 mtk.py w uboot,bootimg,recovery,android,usrdata lk.bin,boot.img,recovery.img,system.img,userdata.img

    echo ""
    echo "=========================================="
    echo "MTK command completed."
    echo ""
    if [ $? -eq 0 ]; then
    echo "‚úì Installation appears to have completed successfully!"
    echo "Your device should restart automatically."
    else
    echo "‚ö† Installation may have encountered issues."
    echo "Please check the output above for error messages."
    fi
    echo ""
    echo "Press any key to close this terminal..."
    read -n 1
    """
                    # Create temporary script
                    script_path = current_dir / "mtk_recovery.sh"
                    with open(script_path, 'w') as f:
                        f.write(script_content)
                    
                    # Make script executable
                    os.chmod(script_path, 0o755)
                    
                    # Open Terminal.app with the script
                    subprocess.Popen([
                        "open", "-a", "Terminal", str(script_path)
                    ])
                    
                    # Clean up script after a delay
                    QTimer.singleShot(5000, lambda: script_path.unlink() if script_path.exists() else None)
                
                self.status_label.setText("Recovery Firmware Install launched in terminal")
                
        except Exception as e:
            self.status_label.setText(f"Error launching recovery firmware install: {e}")
            
            # Show error message
            QMessageBox.critical(
                self,
                "Launch Error",
                f"Failed to launch the recovery firmware installer:\n{e}\n\n"
                "Please try launching it manually."
            )

    def check_drivers_and_architecture(self):
        """Check driver availability and system architecture for Windows users"""
        if platform.system() != "Windows":
            return {
                'has_mtk_driver': True,
                'has_usbdk_driver': True,
                'is_arm64': False,
                'available_methods': ['guided', 'mtkclient'],
                'can_install_firmware': True
            }
        
        # Check for ARM64 architecture
        is_arm64 = False
        try:
            machine = platform.machine().lower()
            is_arm64 = machine in ['arm64', 'aarch64']
        except:
            pass
        
        # Check for MTK driver (SP Flash Tool driver)
        has_mtk_driver = False
        try:
            mediatek_driver_file = Path("C:/Program Files/MediaTek/SP Driver/unins000.exe")
            has_mtk_driver = mediatek_driver_file.exists()
            silent_print(f"MTK driver check: {has_mtk_driver} ({mediatek_driver_file})")
        except Exception as e:
            silent_print(f"MTK driver check error: {e}")
        
        # Check for UsbDk driver
        has_usbdk_driver = False
        try:
            usbdk_driver_file = Path("C:/Program Files/UsbDk Runtime Library/UsbDk.sys")
            has_usbdk_driver = usbdk_driver_file.exists()
            silent_print(f"UsbDk driver check: {has_usbdk_driver} ({usbdk_driver_file})")
        except Exception as e:
            silent_print(f"UsbDk driver check error: {e}")
        
        # Determine available methods based on drivers
        available_methods = []
        can_install_firmware = True
        
        if is_arm64:
            # ARM64 Windows: Only allow firmware downloads, no installation methods
            available_methods = []
            can_install_firmware = False
        elif has_mtk_driver and has_usbdk_driver:
            # Both drivers available: All methods available (Windows order: SP Flash Tool first, then Guided/MTKclient)
            available_methods = ['spflash', 'spflash4', 'guided', 'mtkclient']
        elif has_mtk_driver and not has_usbdk_driver:
            # Only MTK driver: Only SP Flash Tool methods available
            available_methods = ['spflash', 'spflash4']
            can_install_firmware = True
        elif not has_mtk_driver and has_usbdk_driver:
            # Only UsbDk driver: Provide guided as default, then mtkclient advanced
            available_methods = ['guided', 'mtkclient']
            can_install_firmware = True
        else:
            # No drivers: Provide default fallback methods instead of blocking functionality
            # Choose defaults based on what might work without specific drivers
            available_methods = ['guided', 'mtkclient']
            can_install_firmware = True
            silent_print("No specific drivers detected, using default fallback methods: guided, mtkclient")
        
        # Summary of driver combinations:
        # - Both drivers: All 5 methods available (SP Flash Tool first, then Guided/MTKclient)
        # - MTK only: Method 1, 2, and 3 (Guided, SP Flash GUI, and SP Flash Console) only
        # - UsbDk only: Method 1 (Guided default) and Method 2 (MTKclient advanced) available  
        # - No drivers: Method 1 (Guided default) and Method 2 (MTKclient advanced) available
        # - ARM64: No methods available (firmware download only)
        
        result = {
            'has_mtk_driver': has_mtk_driver,
            'has_usbdk_driver': has_usbdk_driver,
            'is_arm64': is_arm64,
            'available_methods': available_methods,
            'can_install_firmware': can_install_firmware
        }
        
        silent_print(f"Driver check result: {result}")
        return result

    def download_latest_updater(self):
        """Download the latest updater.py script silently during launch in worker thread"""
        # REMOVED: Legacy updater.py method no longer used - app handles updates internally
        pass

    def _refresh_adb_status_after_fast_update(self):
        """Refresh ADB status after fast update reboot - device needs time to initialize"""
        try:
            silent_print("Refreshing ADB status after fast update reboot...")
            # Clear the fast update completion flag
            self._fast_update_just_completed = False
            # Force a fresh ADB status check
            self.adb_status_broker.request_refresh(force=True, reason="post_fast_update_reboot")
        except Exception as e:
            silent_print(f"Error refreshing ADB status after fast update: {e}")
    
    def _run_independent_update_check(self):
        """Run update check independently of settings dialog - updates main GUI banner immediately"""
        try:
            # Ensure banner exists before checking
            if not hasattr(self, 'update_alert_banner') or not self.update_alert_banner:
                silent_print("Update banner not yet created, retrying check...")
                QTimer.singleShot(500, self._run_independent_update_check)
                return
            
            # Reset attempt counter for independent check
            self._update_check_attempts = 0
            self._update_check_in_progress = False
            # Run the update check - this will call get_latest_github_version independently
            silent_print("Running independent update check for Innioasis Updater...")
            self.check_for_updates_and_show_button()
        except Exception as e:
            silent_print(f"Error running independent update check: {e}")
            import traceback
            traceback.print_exc()
            # Retry after delay
            QTimer.singleShot(2000, self._run_independent_update_check)
    
    def _schedule_update_retry(self, delay_ms=3000):
        """Retry update detection after a delay when initial attempts fail."""
        try:
            if getattr(self, "_update_check_attempts", 0) >= getattr(self, "_max_update_check_attempts", 3):
                return
            delay = max(0, int(delay_ms))
            QTimer.singleShot(delay, self.check_for_updates_and_show_button)
        except Exception as e:
            silent_print(f"Error scheduling update retry: {e}")

    def check_for_updates_and_show_button(self):
        """Check GitHub for newer version and show update button only if needed (runs in worker thread)"""
        if getattr(self, '_update_check_in_progress', False):
            return
        if self._update_check_attempts >= getattr(self, '_max_update_check_attempts', 3):
            return

        self._update_check_attempts += 1
        self._update_check_in_progress = True

        def check_updates_worker():
            """Worker function to check for updates in background thread"""
            try:
                # Check if GUI still exists and is not closing before accessing it
                if not hasattr(self, '_update_check_in_progress'):
                    silent_print("Update check: GUI not initialized, skipping")
                    return
                
                if getattr(self, '_gui_closing', False):
                    silent_print("Update check: GUI closing, skipping")
                    return
                
                silent_print("Update check: Starting GitHub API request...")
                # Get latest release from GitHub (this is now in a worker thread)
                # This call is completely independent of the settings dialog
                latest_version = self.get_latest_github_version()
                silent_print(f"Update check: Got latest version from GitHub: {latest_version}")
                
                # Check again after potentially long-running operation
                if getattr(self, '_gui_closing', False):
                    silent_print("Update check: GUI closing after API call, skipping")
                    return
                
                if latest_version:
                    current_version = self.app_version or APP_VERSION
                    silent_print(f"Update check: Comparing versions - latest: {latest_version}, current: {current_version}")
                    is_newer = self.compare_versions(latest_version, current_version) > 0

                    if not is_newer:
                        silent_print(f"No updates needed (latest: {latest_version}, current: {current_version})")
                        # Use QTimer to safely update UI from worker thread
                        QTimer.singleShot(0, lambda: self._safe_hide_update_button())
                        self._update_check_attempts = self._max_update_check_attempts
                        return

                    silent_print(f"Update check: Newer version found! Latest: {latest_version}, Current: {current_version}")
                    # Use QTimer to safely update UI from worker thread
                    QTimer.singleShot(0, lambda: self._safe_set_update_available(latest_version, current_version))

                    if self._handle_required_update(latest_version, current_version):
                        silent_print("Update check: Required update handled, skipping UI")
                        self._update_check_attempts = self._max_update_check_attempts
                        return

                    if self.suppress_update_notifications:
                        silent_print("Update notifications suppressed by user preference.")
                        QTimer.singleShot(0, lambda: self._safe_suppress_update_ui())
                        self._update_check_attempts = self._max_update_check_attempts
                        return
                    
                    silent_print(f"Update detected: latest={latest_version}, current={current_version} - showing UI")
                    # Newer version available - show button and banner
                    # Store versions in instance variables and use QTimer to call from main thread
                    self._pending_latest_version = str(latest_version)
                    self._pending_current_version = str(current_version)
                    # Use QTimer.singleShot with explicit variable capture - ensure it executes on main thread
                    # Store result and use a timer to check periodically, or use QApplication.postEvent
                    from PySide6.QtWidgets import QApplication
                    # Post a custom event to ensure main thread execution
                    QApplication.postEvent(self, UpdateCheckEvent(latest_version, current_version))
                    self._update_check_attempts = self._max_update_check_attempts
                else:
                    # Failed to get version - don't show button
                    silent_print("Failed to check for updates - no version returned")
                    if not getattr(self, '_gui_closing', False):
                        QTimer.singleShot(3000, lambda: self._safe_schedule_update_retry())
            except Exception as e:
                silent_print(f"Error checking for updates: {e}")
                import traceback
                traceback.print_exc()
                if not getattr(self, '_gui_closing', False):
                    QTimer.singleShot(3000, lambda: self._safe_schedule_update_retry())
            finally:
                # Use QTimer to safely update flag from worker thread
                if not getattr(self, '_gui_closing', False):
                    QTimer.singleShot(0, lambda: setattr(self, '_update_check_in_progress', False) if hasattr(self, '_update_check_in_progress') else None)
        
        # Run in background thread to avoid blocking
        import threading
        check_thread = threading.Thread(target=check_updates_worker, daemon=True)
        check_thread.start()
        # Store thread reference for cleanup (optional, daemon threads will be killed on exit)
        if not hasattr(self, '_update_check_threads'):
            self._update_check_threads = []
        self._update_check_threads.append(check_thread)
    
    def _safe_hide_update_button(self):
        """Safely hide update button - checks if GUI still exists"""
        try:
            if not getattr(self, '_gui_closing', False):
                self._hide_update_button()
        except (RuntimeError, AttributeError) as e:
            silent_print(f"Safe hide update button failed (GUI closing?): {e}")
            pass  # GUI destroyed, ignore
    
    def _safe_set_update_available(self, latest_version, current_version):
        """Safely set update available state - checks if GUI still exists"""
        try:
            if not getattr(self, '_gui_closing', False):
                self._latest_app_version = latest_version
                self.app_update_available = True
        except (RuntimeError, AttributeError) as e:
            silent_print(f"Safe set update available failed (GUI closing?): {e}")
            pass  # GUI destroyed, ignore
    
    def _safe_suppress_update_ui(self):
        """Safely suppress update UI - checks if GUI still exists"""
        try:
            if not getattr(self, '_gui_closing', False):
                self._suppress_update_ui()
        except (RuntimeError, AttributeError) as e:
            silent_print(f"Safe suppress update UI failed (GUI closing?): {e}")
            pass  # GUI destroyed, ignore
    
    def customEvent(self, event):
        """Handle custom events from worker threads"""
        if isinstance(event, UpdateCheckEvent):
            try:
                silent_print(f"customEvent received: latest={event.latest_version}, current={event.current_version}")
                if not getattr(self, '_gui_closing', False):
                    self._process_update_check_result(event.latest_version, event.current_version)
            except Exception as e:
                silent_print(f"Error handling UpdateCheckEvent: {e}")
                import traceback
                traceback.print_exc()
        else:
            super().customEvent(event)
    
    def _process_update_check_result(self, latest_version, current_version):
        """Process update check result on main thread - called from QTimer callback"""
        try:
            silent_print(f"_process_update_check_result called: latest={latest_version}, current={current_version}")
            if not getattr(self, '_gui_closing', False):
                self._safe_show_update_button(latest_version, current_version)
        except Exception as e:
            silent_print(f"Error processing update check result: {e}")
            import traceback
            traceback.print_exc()
    
    def _safe_show_update_button(self, latest_version, current_version):
        """Safely show update button - checks if GUI still exists"""
        try:
            if not getattr(self, '_gui_closing', False):
                silent_print(f"_safe_show_update_button called with latest={latest_version}, current={current_version}")
                # Directly call the method - we're already on main thread via QMetaObject.invokeMethod
                self._show_update_button(latest_version, current_version)
            else:
                silent_print("_safe_show_update_button: GUI closing, skipping")
        except (RuntimeError, AttributeError) as e:
            silent_print(f"Safe show update button failed (GUI closing?): {e}")
            import traceback
            traceback.print_exc()
            pass  # GUI destroyed, ignore
        except Exception as e:
            silent_print(f"Unexpected error in _safe_show_update_button: {e}")
            import traceback
            traceback.print_exc()
    
    def _safe_schedule_update_retry(self):
        """Safely schedule update retry - checks if GUI still exists"""
        try:
            if not getattr(self, '_gui_closing', False):
                self._schedule_update_retry(3000)
        except (RuntimeError, AttributeError) as e:
            silent_print(f"Safe schedule update retry failed (GUI closing?): {e}")
            pass  # GUI destroyed, ignore
    
    def _show_update_button(self, latest_version, current_version):
        """Show update banner (called from main thread) - only banner, no buttons"""
        try:
            silent_print(f"_show_update_button called: latest={latest_version}, current={current_version}")
            # Set update state
            self.app_update_available = True
            self._latest_app_version = latest_version
            silent_print(f"Newer version available: {latest_version} (current: {current_version})")
            silent_print(f"app_update_available={self.app_update_available}, _latest_app_version={self._latest_app_version}")
            
            # Update badges and banner only - no buttons
            self.update_update_badges()
            silent_print("Calling _refresh_update_notice_label...")
            self._refresh_update_notice_label()  # Updates main GUI banner only
            
            # Force banner refresh again after a short delay to ensure it's visible
            QTimer.singleShot(100, self._refresh_update_notice_label)
        except Exception as e:
            silent_print(f"Error showing update banner: {e}")
            import traceback
            traceback.print_exc()

    def _hide_update_button(self):
        """Hide update UI when no update is available"""
        # Remove any update buttons if they exist
        if hasattr(self, 'update_btn_right') and self.update_btn_right:
            self.update_btn_right.setVisible(False)
            self.update_btn_right.deleteLater()
            self.update_btn_right = None
        self.app_update_available = False
        self._update_prompt_triggered = False
        self.update_update_badges()
        self._refresh_update_notice_label()
    
    def _suppress_update_ui(self):
        """Hide CTA elements when notifications are suppressed but keep state for manual checks."""
        # Remove any update buttons if they exist
        if hasattr(self, 'update_btn_right') and self.update_btn_right:
            self.update_btn_right.setVisible(False)
            self.update_btn_right.deleteLater()
            self.update_btn_right = None
        self.update_update_badges()
        self._refresh_update_notice_label()

    def _create_badge_icon(self, diameter=10, color="#FF8800"):
        """Create a circular icon used for update badges."""
        try:
            image = QImage(diameter, diameter, QImage.Format_ARGB32)
            image.fill(Qt.transparent)
            painter = QPainter(image)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setBrush(QColor(color))
            painter.setPen(Qt.NoPen)
            painter.drawEllipse(0, 0, diameter - 1, diameter - 1)
            painter.end()
            return QIcon(QPixmap.fromImage(image))
        except Exception:
            # Fallback to empty icon if painter can't initialize (shouldn't happen)
            return QIcon()

    def has_update_available(self):
        """Return True if a newer application version is available."""
        if not self.app_update_available or not self._latest_app_version:
            return False
        try:
            return self.compare_versions(self._latest_app_version, self.app_version) > 0
        except Exception:
            return False

    def update_update_badges(self):
        """Update visual badges indicating update availability."""
        has_update = self.has_update_available()
        if hasattr(self, 'settings_badge') and self.settings_badge:
            # Keep settings badge hidden - only banner is shown
            self.settings_badge.setVisible(False)

        if hasattr(self, '_active_settings_tab_widget') and self._active_settings_tab_widget is not None:
            try:
                tab_widget = self._active_settings_tab_widget
                tab_index = getattr(self, '_active_updates_tab_index', None)
                if tab_index is not None:
                    self._apply_update_tab_badge(tab_widget, tab_index, has_update)
            except Exception as badge_err:
                silent_print(f"Error refreshing update badge icon: {badge_err}")
        # Only refresh the banner - no buttons
        self._refresh_update_notice_label()

    def _apply_update_tab_badge(self, tab_widget, tab_index, update_available):
        """Set or clear the update badge icon on the Updates tab."""
        if not tab_widget:
            return
        if update_available and self.has_update_available() and self.badge_icon:
            tab_widget.setTabIcon(tab_index, self.badge_icon)
        else:
            tab_widget.setTabIcon(tab_index, QIcon())

    def _show_update_available_dialog(self, latest_version, current_version):
        """Removed: Update dialog - users can click banner to go to settings"""
        # Dialog removed - only banner is shown, clicking banner opens settings
        pass

    def get_latest_github_version(self):
        """Get the latest release version from GitHub (non-blocking, called from worker thread)."""
        try:
            import requests
            
            headers = {'Accept': 'application/vnd.github.v3+json'}
            if hasattr(self, 'github_api') and hasattr(self.github_api, 'tokens') and self.github_api.tokens:
                token = self.github_api.get_next_token()
                if token:
                    headers['Authorization'] = f'token {token}'
            
            response = requests.get(
                'https://api.github.com/repos/y1-community/Innioasis-Updater/releases',
                headers=headers,
                timeout=4
            )
            
            if response.status_code != 200:
                silent_print(f"GitHub API returned status {response.status_code}")
                return None
            
            releases = response.json()
            versions = []
            best_version = None
            best_release = None
            
            best_numeric = None
            for release in releases:
                if release.get('draft'):
                    continue
                tag_name = release.get('tag_name', '')
                version = tag_name.lstrip('vV')
                if not version:
                    continue
                numeric_version = self._parse_semver(version)
                if numeric_version is None:
                    silent_print(f"Skipping non-semver release tag: {tag_name}")
                    continue
                zip_url = release.get('zipball_url', '')
                commit_display = ''
                if zip_url:
                    commit_display = zip_url.rstrip('/').split('/')[-1][:7]
                elif release.get('target_commitish'):
                    commit_display = str(release.get('target_commitish'))[:7]
                versions.append({
                    'version': version,
                    'commit': commit_display,
                    'release': release,
                    'numeric': numeric_version
                })
                if best_version is None or best_numeric is None or numeric_version > best_numeric:
                    best_version = version
                    best_release = release
                    best_numeric = numeric_version
            
            if versions:
                versions.sort(key=lambda x: x['numeric'], reverse=True)
                self.available_versions = [
                    {k: v for k, v in entry.items() if k != 'numeric'}
                    for entry in versions
                ]
                silent_print(f"Loaded {len(versions)} Innioasis Updater releases for selection.")
            else:
                silent_print("No valid releases found when checking GitHub.")
            
            if best_version and best_release:
                if not hasattr(self, '_latest_release_data'):
                    self._latest_release_data = {}
                self._latest_release_data[best_version] = best_release
                return best_version
            return None
        
        except (requests.exceptions.ConnectionError, requests.exceptions.Timeout, requests.exceptions.RequestException) as e:
            silent_print(f"Network error fetching latest version from GitHub (offline?): {e}")
            return None
        except Exception as e:
            silent_print(f"Error fetching latest version from GitHub: {e}")
            return None

    def compare_versions(self, version1, version2):
        """Compare two version strings. Returns 1 if v1 > v2, -1 if v1 < v2, 0 if equal"""
        v1 = self._parse_semver(version1)
        v2 = self._parse_semver(version2)
        if v1 is None or v2 is None:
            # Fallback to lexical comparison if either version isn't semver-compatible
            if str(version1) > str(version2):
                return 1
            if str(version1) < str(version2):
                return -1
            return 0
        
        max_length = max(len(v1), len(v2))
        v1_extended = list(v1) + [0] * (max_length - len(v1))
        v2_extended = list(v2) + [0] * (max_length - len(v2))
        
        for i in range(max_length):
            if v1_extended[i] > v2_extended[i]:
                return 1
            if v1_extended[i] < v2_extended[i]:
                return -1
        return 0
            
    def _parse_semver(self, version):
        """Convert a dotted numeric version string into a tuple of ints. Return None if invalid."""
        if version is None:
            return None
        version_str = str(version).strip()
        if not version_str:
            return None
        if not re.fullmatch(r'\d+(?:\.\d+)*', version_str):
            return None
        try:
            return tuple(int(part) for part in version_str.split('.'))
        except ValueError:
            return None

    def check_for_utility_updates(self):
        """Silently download and run the latest updater.py"""
        try:
            # Silently try to download the latest updater.py
            try:
                updater_url = "https://innioasis.app/updater.py"
                response = requests.get(updater_url, timeout=10)
                response.raise_for_status()

                updater_path = Path("updater.py")
                with open(updater_path, 'wb') as f:
                    f.write(response.content)

                silent_print("Latest updater.py downloaded successfully")
            except Exception as e:
                silent_print(f"Failed to download latest updater.py, using local copy: {e}")
            
            # Run the updater (either downloaded or local)
            self.run_updater()
            
        except Exception as e:
            silent_print(f"Error in check_for_utility_updates: {e}")
            # Still try to run the existing updater
            self.run_updater()

    def run_updater(self):
        """Run the updater.py script"""
        # REMOVED: Legacy updater.py method no longer used - app handles updates internally
        # Updates are now handled directly by the app
        QMessageBox.information(
            self,
            "Update Available",
            "Please use the 'Download Selected Version' button in Settings > Update Available / Version tab to update the app."
        )

    def hide_left_panel(self):
        """Hide the left panel to give more space to the right panel during installation"""
        if not self.panel_hidden and hasattr(self, 'splitter') and hasattr(self, 'left_panel'):
            self.panel_hidden = True
            # Store current sizes before hiding
            self.original_splitter_sizes = self.splitter.sizes()
            # Hide the left panel by setting its size to 0
            self.splitter.setSizes([0, self.splitter.width()])
            # Hide the panel completely
            self.left_panel.hide()
            
            # Move Settings and Toolkit buttons to right panel (before Install from zip button)
            if hasattr(self, 'settings_btn') and hasattr(self, 'toolkit_btn') and hasattr(self, 'coffee_layout'):
                # Remove buttons from left panel layout
                if hasattr(self, 'device_type_layout'):
                    self.device_type_layout.removeWidget(self.settings_btn)
                    self.device_type_layout.removeWidget(self.toolkit_btn)
                
                # Find the position of Install from zip button in coffee_layout
                install_zip_index = -1
                if hasattr(self, 'install_zip_btn'):
                    for i in range(self.coffee_layout.count()):
                        item = self.coffee_layout.itemAt(i)
                        if item and item.widget() == self.install_zip_btn:
                            install_zip_index = i
                            break
                    # If Install from zip button not found, check driver_buttons_container
                    if install_zip_index == -1 and hasattr(self, 'driver_buttons_container'):
                        for i in range(self.coffee_layout.count()):
                            item = self.coffee_layout.itemAt(i)
                            if item and item.widget() == self.driver_buttons_container:
                                install_zip_index = i
                                break
                
                # Insert buttons before Install from zip button (or at the beginning if not found)
                if install_zip_index >= 0:
                    # Insert spacing before buttons
                    self.coffee_layout.insertSpacing(install_zip_index, 4)
                    # Insert Toolkit button first (rightmost)
                    self.coffee_layout.insertWidget(install_zip_index + 1, self.toolkit_btn)
                    # Insert Settings button (left of Toolkit)
                    self.coffee_layout.insertWidget(install_zip_index + 1, self.settings_btn)
                else:
                    # If Install from zip button not found, add at the beginning (before stretch)
                    # Find stretch position
                    stretch_index = -1
                    for i in range(self.coffee_layout.count()):
                        item = self.coffee_layout.itemAt(i)
                        if item and item.spacerItem():
                            stretch_index = i
                            break
                    if stretch_index >= 0:
                        self.coffee_layout.insertSpacing(stretch_index, 4)
                        self.coffee_layout.insertWidget(stretch_index + 1, self.toolkit_btn)
                        self.coffee_layout.insertWidget(stretch_index + 1, self.settings_btn)
                    else:
                        # Fallback: add at the end
                        self.coffee_layout.addSpacing(4)
                        self.coffee_layout.addWidget(self.settings_btn)
                        self.coffee_layout.addWidget(self.toolkit_btn)
                
                # Show buttons if they were hidden
                self.settings_btn.setVisible(True)
                self.toolkit_btn.setVisible(True)

    def show_left_panel(self):
        """Show the left panel and restore original layout"""
        if self.panel_hidden and hasattr(self, 'splitter') and hasattr(self, 'left_panel'):
            self.panel_hidden = False
            # Show the panel
            self.left_panel.show()
            # Restore original sizes
            self.splitter.setSizes(self.original_splitter_sizes)
            
            # Move Settings and Toolkit buttons back to left panel
            if hasattr(self, 'settings_btn') and hasattr(self, 'toolkit_btn') and hasattr(self, 'device_type_layout'):
                # Remove buttons from right panel layout
                if hasattr(self, 'coffee_layout'):
                    self.coffee_layout.removeWidget(self.settings_btn)
                    self.coffee_layout.removeWidget(self.toolkit_btn)
                    # Remove spacing that was added
                    for i in range(self.coffee_layout.count() - 1, -1, -1):
                        item = self.coffee_layout.itemAt(i)
                        if item and item.spacerItem() and item.spacerItem().sizeHint().width() == 4:
                            self.coffee_layout.removeItem(item)
                            break
                
                # Add buttons back to left panel layout (after Type? button, before stretch)
                # Find the position after Type? button
                type_help_index = -1
                for i in range(self.device_type_layout.count()):
                    item = self.device_type_layout.itemAt(i)
                    if item and item.widget() == self.type_help_btn:
                        type_help_index = i
                        break
                
                if type_help_index >= 0:
                    # Insert after Type? button
                    self.device_type_layout.insertWidget(type_help_index + 1, self.settings_btn)
                    self.device_type_layout.insertSpacing(type_help_index + 2, 4)
                    self.device_type_layout.insertWidget(type_help_index + 3, self.toolkit_btn)
                else:
                    # Fallback: add before stretch
                    self.device_type_layout.insertWidget(self.device_type_layout.count() - 1, self.settings_btn)
                    self.device_type_layout.insertSpacing(self.device_type_layout.count() - 1, 4)
                    self.device_type_layout.insertWidget(self.device_type_layout.count() - 1, self.toolkit_btn)

    def flash_image_border(self):
        """Gently flash the white stroke border of the image to highlight it"""
        if hasattr(self, 'image_label'):
            # Store original stylesheet
            original_style = self.image_label.styleSheet()
            
            # Create flashing effect with thicker white border
            flash_style = """
                QLabel {
                    border: 3px solid white;
                    border-radius: 3px;
                }
            """
            
            # Apply flash style
            self.image_label.setStyleSheet(flash_style)
            
            # Restore original style after 500ms
            QTimer.singleShot(500, lambda: self.image_label.setStyleSheet(original_style))

    def show_try_again_dialog(self):
        """Show try again dialog when user spends too long in initsteps phase"""
        try:
            # Stop any running MTK worker
            if hasattr(self, 'mtk_worker') and self.mtk_worker:
                self.mtk_worker.stop()
                self.mtk_worker.wait()
                self.mtk_worker = None
            
            # Show the try again dialog with specific instructions
            reply = QMessageBox.question(
                self,
                "Connection Timeout",
                "The device connection is taking too long. Please disconnect your Y1 and try again.\n\nThis usually means the device wasn't connected properly or the connection was lost.\n\nWould you like to try again?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.Yes
            )
            
            if reply == QMessageBox.Yes:
                # Return to initsteps state to show instructions again
                self.revert_to_startup_state()
                # Show initsteps image to guide user
                self.load_initsteps_image()
            else:
                # Return to ready state
                self.revert_to_startup_state()
                
        except Exception as e:
            silent_print(f"Error showing try again dialog: {e}")
            # Fallback to reverting to startup state
            self.revert_to_startup_state()
if __name__ == "__main__":
    try:
        # Parse command line arguments
        parser = argparse.ArgumentParser(description="Innioasis Firmware Downloader")
        parser.add_argument("--toolkit", action="store_true", 
                          help="Open only the toolkit window")
        parser.add_argument("-sp", action="store_true",
                          help="Skip GUI and launch flash_tool.exe after updating history.ini")
        args = parser.parse_args()
        
        # Update history.ini at launch (prepares valid history.ini for SP Flash Tool)
        update_history_ini()
        
        # If -sp argument is provided, skip GUI entirely and launch flash_tool.exe
        if args.sp:
            current_dir = Path.cwd()
            flash_tool_exe = current_dir / "flash_tool.exe"
            
            if flash_tool_exe.exists():
                # Launch flash_tool.exe without waiting (non-blocking)
                # On Windows, use DETACHED_PROCESS to ensure process is fully detached
                # This prevents blocking subsequent runs when using pythonw.exe
                try:
                    if platform.system() == "Windows":
                        # Use DETACHED_PROCESS and CREATE_NEW_PROCESS_GROUP for proper detachment
                        # This ensures the process doesn't block subsequent runs
                        creation_flags = (
                            subprocess.DETACHED_PROCESS |
                            subprocess.CREATE_NEW_PROCESS_GROUP |
                            subprocess.CREATE_NO_WINDOW
                        )
                        subprocess.Popen(
                            [str(flash_tool_exe)],
                            cwd=str(current_dir),
                            creationflags=creation_flags,
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            stdin=subprocess.DEVNULL
                        )
                    else:
                        # On non-Windows, launch normally
                        subprocess.Popen(
                            [str(flash_tool_exe)],
                            cwd=str(current_dir),
                            stdout=subprocess.DEVNULL,
                            stderr=subprocess.DEVNULL,
                            stdin=subprocess.DEVNULL
                        )
                except Exception as e:
                    # Silent failure for pythonw.exe (no console)
                    # Try to write error to a log file if possible
                    try:
                        error_log = current_dir / "flash_tool_error.log"
                        with open(error_log, 'a') as f:
                            f.write(f"{datetime.now()}: Error launching flash_tool.exe: {e}\n")
                    except:
                        pass
                    sys.exit(1)
                
                # Exit Python script immediately (GUI is not created)
                sys.exit(0)
            else:
                # Silent failure for pythonw.exe (no console)
                sys.exit(1)
        
        # Create the application
        app = QApplication(sys.argv)

        # Let the macOS app wrapper handle the icon display
        # Removed custom icon setting to allow macOS app icon to shine through

        if args.toolkit:
            # Show only the toolkit window
            window = FirmwareDownloaderGUI()
            window.show_tools_dialog()
        else:
            # Create and show the main window
            window = FirmwareDownloaderGUI()
            window.show()
        
        # Clean up redundant files after GUI is shown (non-blocking, in background thread)
        from PySide6.QtCore import QTimer
        QTimer.singleShot(100, window.start_redundant_files_cleanup)

        # Start the application event loop
        sys.exit(app.exec())
    except Exception as e:
        print(f"Error starting application: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
